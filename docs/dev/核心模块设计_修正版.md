# C^ 核心模块设计 (修正版)

> **重要**: 本文档反映项目实际状态，与旧版本文档不一致处以此为准

## 1. 当前实际架构

### 1.1 项目结构现状
```
c-hat/
├── src/                    # 源代码 (62个.h + 8个.cpp)
├── include/               # 公共头文件
├── lib/                   # 标准库 (计划中)
├── tests/                 # 测试代码
├── docs/                  # 文档
├── build/                 # 构建输出
└── CMakeLists.txt         # CMake构建配置
```

### 1.2 核心模块实际状态

| 模块         | 状态     | 责任            | 文件位置      | 预计完成 |
| ------------ | -------- | --------------- | ------------- | -------- |
| 项目基础设施 | ✅ 已完成 | CMake、目录结构 | 根目录        | ✅        |
| 设计文档     | ✅ 已完成 | 语言规范        | docs/design/  | ✅        |
| 开发环境     | ✅ 已完成 | 环境搭建指南    | docs/dev/     | ✅        |
| 词法分析器   | ❌ 未开始 | 识别Token流     | src/lexer/    | Phase 1  |
| 语法分析器   | ❌ 未开始 | 构建AST         | src/parser/   | Phase 1  |
| 抽象语法树   | ❌ 未开始 | 语法结构表示    | src/ast/      | Phase 1  |
| 类型系统     | ❌ 未开始 | 类型检查与推导  | src/types/    | Phase 2  |
| 语义分析     | ❌ 未开始 | 语义正确性检查  | src/semantic/ | Phase 2  |
| 代码生成     | ❌ 未开始 | LLVM IR生成     | src/codegen/  | Phase 1  |
| 标准库       | ❌ 未开始 | 核心功能实现    | lib/          | Phase 4  |

## 2. Phase 1: 最小可行编译器设计

### 2.1 词法分析器 (Lexer) - 优先级最高

#### 2.1.1 设计目标
- **正确识别**: 支持c^所有关键字、操作符、字面量
- **高效处理**: 单次遍历，O(n)时间复杂度
- **错误恢复**: 报告位置，继续处理
- **可扩展**: 易于添加新Token类型

#### 2.1.2 Token类型设计
```cpp
enum class TokenType {
    // 关键字
    KW_FUNC, KW_CLASS, KW_VAR, KW_LET, KW_CONST, KW_RETURN, 
    KW_IF, KW_ELSE, KW_WHILE, KW_FOR, KW_MATCH, KW_IMPORT,
    KW_DEFER, KW_TRY, KW_CATCH, KW_THROW, KW_NOEXCEPT,
    
    // 基础类型
    KW_INT, KW_FLOAT, KW_BOOL, KW_CHAR, KW_STRING,
    KW_BYTE, KW_SHORT, KW_LONG, KW_DOUBLE, KW_VOID,
    
    // 标识符和字面量
    IDENTIFIER, INTEGER_LITERAL, FLOAT_LITERAL, STRING_LITERAL, CHAR_LITERAL,
    
    // 操作符
    PLUS, MINUS, STAR, SLASH, PERCENT, CARET, AMPERSAND, PIPE,
    EQ, EQ_EQ, NEQ, LT, GT, LE, GE, 
    AND_AND, OR_OR, NOT, TILDE, 
    
    // 特殊操作符 (c^特色)
    CARET_CARET,        // ^^ 指针类型/解引用 (修正: 单个 ^)
    DOLLAR,             // $ 倒序索引
    
    // 分隔符
    LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
    LEFT_BRACKET, RIGHT_BRACKET, SEMICOLON, COMMA, COLON,
    ARROW,              // -> 返回类型
    DOT, DOT_DOT,        // . .. 成员访问/范围
    
    // 其他
    EOF_TOKEN
};
```

#### 2.1.3 核心接口设计
```cpp
class Lexer {
public:
    Lexer(const std::string& source);
    
    Token nextToken();           // 获取下一个Token
    Token peekToken(int ahead = 1); // 预览Token
    SourceLocation getCurrentLocation() const;
    
private:
    void skipWhitespace();
    void skipComment();
    Token scanIdentifier();
    Token scanNumber();
    Token scanString();
    Token scanChar();
    Token scanOperator();
    
    char advance();
    char peek(int ahead = 1);
    bool match(char expected);
    bool isAlpha(char c);
    bool isDigit(char c);
    bool isAlphaNumeric(char c);
};
```

### 2.2 语法分析器 (Parser)

#### 2.2.1 设计策略
采用**递归下降解析**，为每个语法产生式编写对应函数：
- 优点：直观、易调试、错误信息友好
- 缺点：左递归需要改写、复杂语法可能效率低

#### 2.2.2 核心解析函数框架
```cpp
class Parser {
public:
    Parser(Lexer& lexer);
    std::unique_ptr<Program> parseProgram();
    
private:
    // 声明解析
    std::unique_ptr<Declaration> parseDeclaration();
    std::unique_ptr<VariableDecl> parseVariableDecl();
    std::unique_ptr<FunctionDecl> parseFunctionDecl();
    
    // 语句解析  
    std::unique_ptr<Statement> parseStatement();
    std::unique_ptr<ExprStmt> parseExprStmt();
    std::unique_ptr<BlockStmt> parseBlockStmt();
    std::unique_ptr<ReturnStmt> parseReturnStmt();
    std::unique_ptr<MatchStmt> parseMatchStmt();
    std::unique_ptr<DeferStmt> parseDeferStmt();
    
    // 表达式解析 (按优先级)
    std::unique_ptr<Expression> parseExpression();
    std::unique_ptr<Expression> parseAssignmentExpr();
    std::unique_ptr<Expression> parseLogicalOrExpr();
    std::unique_ptr<Expression> parseLogicalAndExpr();
    // ... 逐级下降
    std::unique_ptr<Expression> parsePrimaryExpr();
    
    // 工具方法
    void advance();
    bool check(TokenType type);
    bool match(TokenType type);
    void expect(TokenType type, const std::string& message);
};
```

### 2.3 抽象语法树 (AST)

#### 2.3.1 节点层次设计
```cpp
// 基类
class Node {
public:
    virtual ~Node() = default;
    virtual void accept(AstVisitor& visitor) = 0;
    virtual SourceLocation getLocation() const = 0;
};

// 表达式节点
class Expression : public Node {
public:
    virtual std::shared_ptr<Type> getType() const = 0;
};

class BinaryExpr : public Expression {
public:
    BinaryExpr(std::unique_ptr<Expression> left, BinaryOp op, 
               std::unique_ptr<Expression> right);
    void accept(AstVisitor& visitor) override;
    
    std::unique_ptr<Expression> left;
    BinaryOp op;
    std::unique_ptr<Expression> right;
};

class IdentifierExpr : public Expression {
public:
    IdentifierExpr(const std::string& name);
    void accept(AstVisitor& visitor) override;
    
    std::string name;
};

// 声明节点
class Declaration : public Node {};

class FunctionDecl : public Declaration {
public:
    FunctionDecl(const std::string& name, 
                std::vector<std::unique_ptr<ParamDecl>> params,
                std::unique_ptr<Type> returnType,
                std::unique_ptr<BlockStmt> body);
    void accept(AstVisitor& visitor) override;
    
    std::string name;
    std::vector<std::unique_ptr<ParamDecl>> params;
    std::unique_ptr<Type> returnType;
    std::unique_ptr<BlockStmt> body;
};
```

### 2.4 代码生成器 (CodeGen)

#### 2.4.1 LLVM IR 生成策略
- 使用LLVM C++ API直接生成IR
- 每个AST节点对应一个代码生成方法
- 维护符号表管理变量和函数

#### 2.4.2 核心接口
```cpp
class CodeGenerator {
public:
    CodeGenerator();
    std::unique_ptr<llvm::Module> generate(std::unique_ptr<Program> program);
    
private:
    // 表达式生成
    llvm::Value* generateExpression(std::unique_ptr<Expression> expr);
    llvm::Value* generateBinaryExpr(BinaryExpr& expr);
    llvm::Value* generateIdentifier(IdentifierExpr& ident);
    
    // 声明生成  
    void generateFunction(FuncDecl& func);
    void generateVariable(VariableDecl& var);
    
    // 语句生成
    void generateStatement(std::unique_ptr<Statement> stmt);
    void generateReturn(ReturnStmt& ret);
    
    // 工具
    llvm::LLVMContext& getContext() { return context_; }
    llvm::IRBuilder<>& getBuilder() { return builder_; }
    
private:
    llvm::LLVMContext context_;
    llvm::IRBuilder<> builder_;
    std::unique_ptr<llvm::Module> module_;
    std::unordered_map<std::string, llvm::Value*> symbolTable_;
};
```

## 3. 开发优先级与依赖

### 3.1 实现顺序
1. **Lexer** → **Parser** → **AST** → **CodeGen** (线性依赖)
2. 每个阶段都要有对应的测试
3. 保持每次提交都能编译通过

### 3.2 最小可行产品 (MVP)
第一阶段目标: 能编译并运行
```c^
func main() -> int {
    return 42;
}
```

## 4. 测试策略

### 4.1 单元测试
- Lexer: 每个Token类型的识别测试
- Parser: 每个语法结构的解析测试  
- AST: 节点创建和遍历测试
- CodeGen: IR生成正确性测试

### 4.2 集成测试
- 端到端编译测试: .ch文件 → 可执行文件
- 回归测试: 确保新功能不破坏旧功能

---

*文档版本: 2.0.0 (修正版)*
*最后更新: 2026-02-08*