# C^ 编译器开发指南

## 快速开始

### 环境准备
按照 `开发环境搭建.md` 完成环境配置后，执行：

```bash
# 克隆项目 (如果是从现有代码开始)
cd d:/projects/CppProjs/
git clone <your-repo> c-hat
cd c-hat

# 构建当前框架
mkdir build && cd build
cmake ..
cmake --build .
```

### 当前项目状态
⚠️ **重要**: 项目基础框架已搭建，核心模块已实现，需根据最新设计文档进行迭代和新特性支持。

- ✅ 项目结构和CMake配置
- ✅ 完整的语言设计文档
- ✅ 词法分析器 (Lexer) - 需更新支持新关键字 (defer, late, noexcept, concept)
- ✅ 语法分析器 (Parser) - 需支持新语句 (defer, match)
- ✅ AST (抽象语法树) - 需添加新节点
- ✅ 代码生成 (CodeGen) - 基础实现
- ❌ 语义分析 (Semantic) - 需增强严格布尔检查、Concept约束
- ❌ 标准库 (Standard Library) - 尚未实现

## 开发工作流程

### Phase 1: 核心功能迭代 (当前阶段)

#### Step 1: 词法分析器更新
更新 `TokenType` 枚举，支持新的关键字：`defer`, `late`, `noexcept`, `concept`, `requires` 等。
```cpp
// src/lexer/Lexer.h
#pragma once
#include <string>
#include <variant>

enum class TokenType {
    // 从最小集开始
    KW_FUNC, KW_VAR, KW_LET, KW_CONST, KW_RETURN,
    KW_IF, KW_ELSE, KW_WHILE, KW_FOR, KW_MATCH,
    KW_DEFER, KW_LATE, KW_NOEXCEPT, KW_CONCEPT,
    IDENTIFIER, INTEGER_LITERAL, STRING_LITERAL,
    PLUS, MINUS, STAR, SLASH, EQ, SEMICOLON,
    LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
    LEFT_BRACKET, RIGHT_BRACKET, // []
    EOF_TOKEN
};

struct Token {
    TokenType type;
    std::string literal;
    int line;
    int column;
};

class Lexer {
public:
    Lexer(const std::string& source);
    Token nextToken();
    
private:
    void skipWhitespace();
    Token scanIdentifier();
    Token scanNumber();
    Token scanString();
    
    char advance();
    char peek();
    bool isAtEnd();
    
    std::string source_;
    int position_ = 0;
    int line_ = 1;
    int column_ = 1;
};
```

#### Step 3: 实现基础解析器
```cpp
// src/parser/Parser.h  
#pragma once
#include "lexer/Lexer.h"
#include <memory>

class Expr {
public:
    virtual ~Expr() = default;
};

class NumberExpr : public Expr {
public:
    NumberExpr(double value) : value_(value) {}
    double value_;
};

class BinaryExpr : public Expr {
public:
    BinaryExpr(std::unique_ptr<Expr> left, char op, std::unique_ptr<Expr> right)
        : left_(std::move(left)), op_(op), right_(std::move(right)) {}
    
    std::unique_ptr<Expr> left_;
    char op_;
    std::unique_ptr<Expr> right_;
};

class Parser {
public:
    Parser(Lexer& lexer);
    std::unique_ptr<Expr> parseExpression();
    
private:
    std::unique_ptr<Expr> parsePrimary();
    std::unique_ptr<Expr> parseAdditive();
    
    Lexer& lexer_;
    Token currentToken_;
};
```

#### Step 4: 测试驱动开发
为每个组件编写测试：

```cpp
// tests/test_lexer.cpp
#include "lexer/Lexer.h"
#include <gtest/gtest.h>

TEST(LexerTest, BasicTokens) {
    Lexer lexer("func add() { return 42; }");
    
    EXPECT_EQ(lexer.nextToken().type, TokenType::KW_FUNC);
    EXPECT_EQ(lexer.nextToken().type, TokenType::IDENTIFIER);
    // ... 更多测试
}
```

### 开发规范

#### 代码风格
- **命名**: 类型用PascalCase，函数/变量用snake_case
- **缩进**: 4空格
- **行长度**: ≤ 100字符
- **头文件**: 使用 `#pragma once`

#### Git工作流
```bash
# 功能开发
 git checkout -b feature/lexer-basic
 # 开发...
 git commit -m "feat(lexer): implement basic token recognition"
 git push origin feature/lexer-basic
 # 创建PR

# 修复bug  
git checkout -b bugfix/lexer-string-escapes
# 修复...
git commit -m "fix(lexer): handle string escape sequences"
```

#### 提交消息格式
```
type(scope): subject

body

footer
```

**Types**: feat, fix, docs, style, refactor, test, chore
**Scopes**: lexer, parser, ast, codegen, types, semantic, build

示例:
```
feat(lexer): add support for floating point literals

Implemented recognition of decimal floating point numbers
with optional fractional and exponent parts.

Closes #123
```

## 调试技巧

### 1. 词法分析调试
```cpp
void Lexer::debugPrintTokens() {
    Token token;
    do {
        token = nextToken();
        std::cout << "Line " << token.line << ": " 
                  << static_cast<int>(token.type) << " (" << token.literal << ")" << std::endl;
    } while (token.type != TokenType::EOF_TOKEN);
}
```

### 2. 解析过程可视化
```cpp
class DebugParser : public Parser {
public:
    std::unique_ptr<Expr> parseExpression() {
        std::cout << "Parsing expression..." << std::endl;
        auto expr = Parser::parseExpression();
        std::cout << "Expression parsed successfully" << std::endl;
        return expr;
    }
};
```

### 3. AST打印
```cpp
class AstPrinter {
public:
    void print(Expr* expr) {
        if (auto num = dynamic_cast<NumberExpr*>(expr)) {
            std::cout << num->value_;
        } else if (auto bin = dynamic_cast<BinaryExpr*>(expr)) {
            std::cout << "(";
            print(bin->left_.get());
            std::cout << " " << bin->op_ << " ";
            print(bin->right_.get());
            std::cout << ")";
        }
    }
};
```

## 常见问题

### Q: 如何处理复杂的操作符优先级？
A: 使用Pratt解析器或递归下降+优先级爬升：
```cpp
std::unique_ptr<Expr> parseBinaryOp(std::unique_ptr<Expr> left, int minPrecedence) {
    while (getCurrentTokenPrecedence() >= minPrecedence) {
        auto op = consumeToken();
        auto right = parsePrimary();
        
        while (getNextTokenPrecedence() > getCurrentTokenPrecedence()) {
            right = parseBinaryOp(std::move(right), getNextTokenPrecedence());
        }
        
        left = std::make_unique<BinaryExpr>(std::move(left), op, std::move(right));
    }
    return left;
}
```

### Q: LLVM安装路径问题？
A: 在CMakeLists.txt中明确指定：
```cmake
find_package(LLVM REQUIRED CONFIG)
if(NOT LLVM_FOUND)
    message(FATAL_ERROR "LLVM not found. Please set LLVM_DIR")
endif()

# 或者手动指定
set(LLVM_DIR "C:/Program Files/LLVM/lib/cmake/llvm")
```

### Q: 如何处理编码问题？
A: c^使用UTF-8，确保源码和终端都是UTF-8：
```cpp
#include <locale>
#include <codecvt>

std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
std::string utf8 = converter.to_bytes(utf32_char);
```

## 下一步行动

### 本周任务 (Week 1)
- [ ] 创建 `src/lexer/` 目录和基础结构
- [ ] 实现识别关键字、标识符、数字的Lexer
- [ ] 编写基础测试用例
- [ ] 更新README.md说明当前状态

### 本月目标 (Month 1)  
- [ ] 完整词法分析器支持所有Token类型
- [ ] 基础表达式解析器
- [ ] 简单AST节点
- [ ] 能解析 `return 42;` 这样的简单程序

---

**记住**: 这是一个从零开始的编译器项目，保持耐心，重视测试，每次提交都要能编译通过！