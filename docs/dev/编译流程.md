# C^ 语言编译器编译流程

本文档详细介绍 C^ 语言编译器的编译流程，包括词法分析、语法分析、语义分析和代码生成（使用 LLVM）。

## 1. 编译流程概述

C^ 语言编译器的编译流程包括以下几个主要阶段：

1. **词法分析**：将源代码文本转换为词法单元（Token）序列
2. **语法分析**：将词法单元序列转换为抽象语法树（AST）
3. **语义分析**：对抽象语法树进行类型检查、作用域分析等语义检查
4. **代码生成**：将语义分析后的抽象语法树转换为目标代码（使用 LLVM）

## 2. 词法分析

词法分析是编译流程的第一步，由词法分析器（Lexer）完成。词法分析器的主要任务是：

1. **扫描源代码**：从左到右扫描源代码文本
2. **识别词法单元**：将源代码分解为词法单元（Token），如关键字、标识符、字面量、运算符等
3. **忽略空白和注释**：跳过源代码中的空白字符和注释
4. **生成词法单元序列**：将识别出的词法单元按顺序传递给语法分析器

### 2.1 词法分析器实现

C^ 语言编译器的词法分析器实现在 `src/lexer/` 目录中，主要包括：

- `Lexer.h`：定义词法分析器的接口
- `Lexer.cpp`：实现词法分析器的核心逻辑

词法分析器使用状态机来识别词法单元，支持 C^ 语言的所有关键字、标识符、字面量、运算符等。

### 2.2 词法单元类型

词法分析器生成的词法单元类型定义在 `src/lexer/TokenType.h` 文件中，包括：

- **关键字**：如 `func`、`class`、`struct`、`enum`、`import`、`export` 等
- **标识符**：如变量名、函数名、类名等
- **字面量**：如整数、浮点数、字符、字符串、布尔值、空值等
- **运算符**：如 `+`、`-`、`*`、`/`、`=`、`==`、`!=` 等
- **分隔符**：如 `(`、`)`、`{`、`}`、`[`、`]`、`;`、`,` 等

## 3. 语法分析

语法分析是编译流程的第二步，由语法分析器（Parser）完成。语法分析器的主要任务是：

1. **接收词法单元序列**：从词法分析器接收词法单元序列
2. **构建抽象语法树**：根据 C^ 语言的语法规则，将词法单元序列转换为抽象语法树（AST）
3. **语法错误处理**：检测并报告语法错误，如缺少分号、括号不匹配等

### 3.1 语法分析器实现

C^ 语言编译器的语法分析器实现在 `src/parser/` 目录中，主要包括：

- `Parser.h`：定义语法分析器的接口
- `Parser.cpp`：实现语法分析器的核心逻辑

语法分析器使用递归下降法来构建抽象语法树，支持 C^ 语言的所有语法结构。

### 3.2 抽象语法树

抽象语法树（AST）是语法分析的产物，由一系列 AST 节点组成。AST 节点的定义在 `src/ast/` 目录中，主要包括：

- **表达式节点**：如二元表达式、一元表达式、字面量表达式、标识符表达式、函数调用表达式等
- **声明节点**：如变量声明、函数声明、类声明、结构体声明、枚举声明等
- **语句节点**：如表达式语句、复合语句、条件语句、循环语句、跳转语句等
- **类型节点**：如基本类型、指针类型、数组类型、切片类型等

### 3.3 语法规则

C^ 语言的语法规则包括：

- **声明规则**：如变量声明、函数声明、类声明、结构体声明、枚举声明等
- **语句规则**：如表达式语句、复合语句、条件语句、循环语句、跳转语句等
- **表达式规则**：如二元表达式、一元表达式、字面量表达式、标识符表达式、函数调用表达式等
- **类型规则**：如基本类型、指针类型、数组类型、切片类型等

## 4. 语义分析

语义分析是编译流程的第三步，由语义分析器（Semantic Analyzer）完成。语义分析器的主要任务是：

1. **类型检查**：检查表达式和语句的类型是否正确，如赋值语句的左右操作数类型是否兼容
2. **作用域分析**：检查标识符的作用域是否正确，如变量是否在作用域内声明
3. **符号表管理**：维护符号表，记录变量、函数、类等的声明信息
4. **语义错误处理**：检测并报告语义错误，如类型不匹配、未声明的标识符等

### 4.1 语义分析器实现

C^ 语言编译器的语义分析器实现在 `src/semantic/` 目录中，主要包括：

- `SemanticAnalyzer.h`：定义语义分析器的接口
- `SemanticAnalyzer.cpp`：实现语义分析器的核心逻辑
- `SymbolTable.h`：定义符号表的接口
- `SymbolTable.cpp`：实现符号表的核心逻辑

语义分析器使用符号表来管理标识符的声明和使用，支持 C^ 语言的类型系统和作用域规则。

### 4.2 符号表

符号表是语义分析的重要工具，用于记录标识符的声明信息，包括：

- **变量符号**：记录变量的名称、类型、作用域等信息
- **函数符号**：记录函数的名称、参数类型、返回类型、作用域等信息
- **类符号**：记录类的名称、基类、成员等信息

符号表支持作用域嵌套，如全局作用域、函数作用域、类作用域等。

### 4.3 类型系统

C^ 语言的类型系统包括：

- **基本类型**：如 `void`、`bool`、`int`、`double`、`char` 等
- **复合类型**：如指针类型、数组类型、切片类型等
- **用户定义类型**：如类、结构体、枚举等

语义分析器检查表达式和语句的类型是否正确，如赋值语句的左右操作数类型是否兼容、函数调用的实参类型是否与形参类型匹配等。

## 5. 代码生成

代码生成是编译流程的最后一步，由代码生成器（Code Generator）完成。代码生成器的主要任务是：

1. **接收语义分析后的抽象语法树**：从语义分析器接收语义分析后的抽象语法树
2. **生成 LLVM IR**：将抽象语法树转换为 LLVM 中间表示（IR）
3. **优化 LLVM IR**：使用 LLVM 的优化 passes 对生成的 LLVM IR 进行优化
4. **生成目标代码**：将优化后的 LLVM IR 转换为目标代码，如 x86、ARM 等

### 5.1 LLVM 后端实现

C^ 语言编译器的 LLVM 后端实现在 `src/codegen/` 目录中，主要包括：

- `CodeGenerator.h`：定义代码生成器的接口
- `CodeGenerator.cpp`：实现代码生成器的核心逻辑

代码生成器使用 LLVM 的 C++ API 来生成 LLVM IR 和目标代码。

### 5.2 LLVM IR

LLVM 中间表示（IR）是一种与目标平台无关的中间代码，具有以下特点：

- **类型安全**：LLVM IR 是类型安全的，每个值都有明确的类型
- **SSA 形式**：LLVM IR 使用静态单赋值（SSA）形式，每个变量只被赋值一次
- **指令丰富**：LLVM IR 提供了丰富的指令，如算术指令、逻辑指令、控制流指令等

代码生成器将 C^ 语言的抽象语法树转换为 LLVM IR，然后使用 LLVM 的优化 passes 对生成的 LLVM IR 进行优化。

### 5.3 目标代码生成

LLVM 支持多种目标平台，如 x86、ARM、MIPS 等。代码生成器使用 LLVM 的目标代码生成器来将优化后的 LLVM IR 转换为目标平台的机器码。

## 6. 编译流程示例

下面是一个简单的 C^ 语言程序的编译流程示例：

### 6.1 源代码

```cpp
func main() -> int {
  var x: int = 10;
  var y: int = 20;
  return x + y;
}
```

### 6.2 词法分析

词法分析器将源代码转换为词法单元序列：

```
TokenType::Func, TokenType::Identifier("main"), TokenType::LParen, TokenType::RParen,
TokenType::Arrow, TokenType::Int, TokenType::LBrace,
TokenType::Var, TokenType::Identifier("x"), TokenType::Colon, TokenType::Int, TokenType::Assign,
TokenType::IntegerLiteral("10"), TokenType::Semicolon,
TokenType::Var, TokenType::Identifier("y"), TokenType::Colon, TokenType::Int, TokenType::Assign,
TokenType::IntegerLiteral("20"), TokenType::Semicolon,
TokenType::Return, TokenType::Identifier("x"), TokenType::Plus, TokenType::Identifier("y"),
TokenType::Semicolon, TokenType::RBrace
```

### 6.3 语法分析

语法分析器将词法单元序列转换为抽象语法树：

```
FunctionDecl(
  name="main",
  params=[],
  returnType=PrimitiveType(Int),
  body=CompoundStmt(
    statements=[
      VariableDecl(
        name="x",
        type=PrimitiveType(Int),
        initializer=Literal(Integer, "10")
      ),
      VariableDecl(
        name="y",
        type=PrimitiveType(Int),
        initializer=Literal(Integer, "20")
      ),
      ReturnStmt(
        expr=BinaryExpr(
          op=Plus,
          left=Identifier("x"),
          right=Identifier("y")
        )
      )
    ]
  )
)
```

### 6.4 语义分析

语义分析器对抽象语法树进行语义检查：

1. **类型检查**：检查 `x + y` 的类型是否为 `int`，与函数返回类型 `int` 是否兼容
2. **作用域分析**：检查 `x` 和 `y` 是否在作用域内声明
3. **符号表管理**：在符号表中记录 `x` 和 `y` 的声明信息

### 6.5 代码生成

代码生成器将语义分析后的抽象语法树转换为 LLVM IR，然后生成目标代码。

## 7. 使用 LLVM 做后端

使用 LLVM 作为后端的主要步骤：

### 7.1 安装 LLVM

首先，需要安装 LLVM 库和开发工具。可以从 [LLVM 官网](https://llvm.org/) 下载预编译的 LLVM 二进制文件，或者从源代码编译 LLVM。

### 7.2 配置 CMake

在 `CMakeLists.txt` 文件中配置 LLVM 的依赖：

```cmake
find_package(LLVM REQUIRED CONFIG)

message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")

include_directories(${LLVM_INCLUDE_DIRS})
add_definitions(${LLVM_DEFINITIONS})

llvm_map_components_to_libnames(LLVM_LIBS core mcjit native)

add_executable(c_hat_compiler main.cpp)
target_link_libraries(c_hat_compiler ${LLVM_LIBS})
```

### 7.3 生成 LLVM IR

使用 LLVM 的 C++ API 生成 LLVM IR：

```cpp
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/IRBuilder.h"

// 创建 LLVM 上下文
llvm::LLVMContext context;

// 创建模块
std::unique_ptr<llvm::Module> module = std::make_unique<llvm::Module>("c_hat_module", context);

// 创建 IR 构建器
llvm::IRBuilder<> builder(context);

// 生成函数
llvm::FunctionType* funcType = llvm::FunctionType::get(builder.getInt32Ty(), false);
llvm::Function* func = llvm::Function::Create(funcType, llvm::Function::ExternalLinkage, "main", module.get());

// 创建基本块
llvm::BasicBlock* entry = llvm::BasicBlock::Create(context, "entry", func);
builder.SetInsertPoint(entry);

// 生成变量
llvm::Value* x = builder.CreateAlloca(builder.getInt32Ty());
builder.CreateStore(builder.getInt32(10), x);

llvm::Value* y = builder.CreateAlloca(builder.getInt32Ty());
builder.CreateStore(builder.getInt32(20), y);

// 生成加法
llvm::Value* xVal = builder.CreateLoad(builder.getInt32Ty(), x);
llvm::Value* yVal = builder.CreateLoad(builder.getInt32Ty(), y);
llvm::Value* sum = builder.CreateAdd(xVal, yVal, "sum");

// 生成返回
builder.CreateRet(sum);

// 打印 LLVM IR
module->print(llvm::errs(), nullptr);
```

### 7.4 优化 LLVM IR

使用 LLVM 的优化 passes 对生成的 LLVM IR 进行优化：

```cpp
#include "llvm/Transforms/Scalar.h"
#include "llvm/Transforms/Scalar/GVN.h"

// 创建函数传递管理器
llvm::FunctionPassManager fpm(module.get());

// 添加优化 passes
fpm.add(llvm::createPromoteMemoryToRegisterPass()); // 将内存变量提升为寄存器变量
fpm.add(llvm::createInstructionCombiningPass());   // 指令组合优化
fpm.add(llvm::createReassociatePass());           // 重新关联表达式
fpm.add(llvm::createGVNPass());                  // 全局值编号优化
fpm.add(llvm::createCFGSimplificationPass());     // 控制流图简化

// 初始化函数传递管理器
fpm.doInitialization();

// 优化函数
for (auto& func : *module) {
  fpm.run(func);
}

// 打印优化后的 LLVM IR
module->print(llvm::errs(), nullptr);
```

### 7.5 生成目标代码

使用 LLVM 的目标代码生成器生成目标代码：

```cpp
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/MCJIT.h"
#include "llvm/ExecutionEngine/GenericValue.h"

// 创建执行引擎
std::string errStr;
llvm::ExecutionEngine* engine = llvm::EngineBuilder(std::move(module))
  .setErrorStr(&errStr)
  .setMCJITMemoryManager(std::make_unique<llvm::SectionMemoryManager>())
  .create();

if (!engine) {
  llvm::errs() << "Failed to create execution engine: " << errStr << "\n";
  return 1;
}

// 查找函数
llvm::Function* mainFunc = engine->FindFunctionNamed("main");
if (!mainFunc) {
  llvm::errs() << "Failed to find main function\n";
  return 1;
}

// 执行函数
std::vector<llvm::GenericValue> noArgs;
llvm::GenericValue result = engine->runFunction(mainFunc, noArgs);

// 打印结果
llvm::outs() << "Result: " << result.IntVal << "\n";
```

## 8. 总结

C^ 语言编译器的编译流程包括词法分析、语法分析、语义分析和代码生成四个主要阶段。使用 LLVM 作为后端可以简化代码生成过程，同时利用 LLVM 的优化能力生成高效的目标代码。

通过本文档的介绍，希望开发者能够理解 C^ 语言编译器的工作原理，以及如何使用 LLVM 作为后端生成目标代码。
