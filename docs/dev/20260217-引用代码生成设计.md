# 引用代码生成设计文档

## 1. 引用在 LLVM 中的表示

C^ 中的所有引用类型（可变引用 `T&` 和不可变引用 `T!&`）在 LLVM IR 中都表示为 **指针类型**。

### 1.1 类型映射

| C^ 类型 | LLVM IR 类型 | 说明 |
|---------|-------------|------|
| `int` | `i32` | 32位整数 |
| `int&` | `i32*` | 指向 int 的指针 |
| `int!&` | `i32*` | 指向 int 的指针（不可变仅语义检查，代码生成相同） |
| `string` | `%LiteralView` | 字符串类型 |
| `string&` | `%LiteralView*` | 指向字符串的指针 |

### 1.2 不可变性的处理

- **语义分析阶段**：严格检查不可变引用的写入操作
- **代码生成阶段**：可变和不可变引用在 LLVM IR 中都表示为指针，不做特别区分
- 这是因为 LLVM 没有内置的"不可变指针"类型，我们依赖语义分析确保类型安全

---

## 2. 引用作为函数参数的代码生成

### 2.1 参数传递

引用类型的参数在 LLVM IR 中直接作为指针传递：

**C^ 代码：**
```cpp
func increment(int& x) {
    x = x + 1;
}

func print_value(int!& x) {
    print(x);
}
```

**LLVM IR 生成：**
```llvm
define void @increment(i32* %x) {
entry:
  %0 = load i32, i32* %x, align 4
  %1 = add nsw i32 %0, 1
  store i32 %1, i32* %x, align 4
  ret void
}

define void @print_value(i32* %x) {
entry:
  %0 = load i32, i32* %x, align 4
  ; 调用 print 函数
  ret void
}
```

### 2.2 调用点代码生成

**C^ 调用代码：**
```cpp
func main() {
    int a = 42;
    increment(&a);  // 可变引用，显式 &
    print_value(a); // 不可变引用，隐式传递
}
```

**LLVM IR 生成：**
```llvm
define i32 @main() {
entry:
  %a = alloca i32, align 4
  store i32 42, i32* %a, align 4
  
  ; 调用 increment(&a) - 传递 %a 的地址
  call void @increment(i32* %a)
  
  ; 调用 print_value(a) - 隐式转换，同样传递 %a 的地址
  call void @print_value(i32* %a)
  
  ret i32 0
}
```

---

## 3. 引用作为函数返回值的代码生成

### 3.1 返回引用的函数

**C^ 代码：**
```cpp
func get_ref(int& x) -> int& {
    return &x;
}

func get_readonly_ref(int!& x) -> int!& {
    return &x;
}
```

**LLVM IR 生成：**
```llvm
define i32* @get_ref(i32* %x) {
entry:
  ; 直接返回指针
  ret i32* %x
}

define i32* @get_readonly_ref(i32* %x) {
entry:
  ; 直接返回指针（不可变仅语义检查）
  ret i32* %x
}
```

### 3.2 返回引用的调用场景

#### 场景 1：用引用类型接收（保持引用）

**C^ 代码：**
```cpp
func main() {
    int a = 42;
    int& r = get_ref(&a);   // 用可变引用接收
    int!& cr = get_readonly_ref(a); // 用不可变引用接收
    
    r = 100;  // 修改原 a
}
```

**LLVM IR 生成：**
```llvm
define i32 @main() {
entry:
  %a = alloca i32, align 4
  %r = alloca i32*, align 8    ; 存储指针
  %cr = alloca i32*, align 8   ; 存储指针
  
  store i32 42, i32* %a, align 4
  
  ; 调用 get_ref，返回的指针直接存入 %r
  %0 = call i32* @get_ref(i32* %a)
  store i32* %0, i32** %r, align 8
  
  ; 调用 get_readonly_ref，返回的指针直接存入 %cr
  %1 = call i32* @get_readonly_ref(i32* %a)
  store i32* %1, i32** %cr, align 8
  
  ; r = 100：先加载指针，再存储值
  %2 = load i32*, i32** %r, align 8
  store i32 100, i32* %2, align 4
  
  ret i32 0
}
```

#### 场景 2：用值类型接收（自动解引用/拷贝）⭐

这是 C^ 的一个重要特性：当引用返回值被值类型变量接收时，会自动进行解引用和拷贝！

**C^ 代码：**
```cpp
func main() {
    int a = 42;
    int rr = get_readonly_ref(a);  // 用值类型接收，自动解引用！
    
    // rr 是 a 的拷贝，修改 rr 不影响 a
    rr = 100;
}
```

**LLVM IR 生成：**
```llvm
define i32 @main() {
entry:
  %a = alloca i32, align 4
  %rr = alloca i32, align 4
  
  store i32 42, i32* %a, align 4
  
  ; 1. 调用函数，获取指针
  %0 = call i32* @get_readonly_ref(i32* %a)
  
  ; 2. 自动解引用：从指针加载值（关键步骤！）
  %1 = load i32, i32* %0, align 4
  
  ; 3. 存储到值类型变量
  store i32 %1, i32* %rr, align 4
  
  ; rr = 100：只修改拷贝，不影响原 a
  store i32 100, i32* %rr, align 4
  
  ret i32 0
}
```

**关键设计要点：**
- 当接收者是值类型时，编译器自动在返回的指针上执行 `load` 指令
- 这样实现了引用到值的自动解引用和拷贝
- 用户不需要显式写解引用操作，代码更简洁

---

## 4. 悬垂引用问题与设计决策

### 4.1 返回局部变量引用的问题

**C^ 代码（危险示例）：**
```cpp
int!& bad_func() {
    int x = 42;  // 局部变量，函数返回后销毁
    return &x;   // 返回局部变量的引用！
}
```

#### 设计决策 1：语义分析检查

- **当前实现**：编译器会尽力检测这种情况，但不一定能完全检测到（特别是复杂控制流）
- **建议**：未来版本可以添加更严格的生命周期检查（类似 Rust 的 borrow checker）

#### 设计决策 2：用值接收时的行为 ⭐

如果接收者是值类型，即使返回了局部变量的引用，行为也是**拷贝**而不是悬垂引用！

**C^ 代码：**
```cpp
func main() {
    int val = bad_func();  // 用值类型接收
    
    // 虽然 bad_func 返回了局部变量的引用，
    // 但由于 val 是值类型，编译器会：
    // 1. 调用 bad_func() 获取指针（指向已销毁的 x）
    // 2. 立即从该指针加载值（此时 x 可能还在栈上，值是 42）
    // 3. 将值拷贝到 val
    
    // 这是一个"幸运"的拷贝，但本质上仍然是未定义行为！
}
```

**重要说明：**
- 虽然用值接收可以"避免"悬垂引用问题，但这本质上仍然是**未定义行为**
- 局部变量在函数返回后立即销毁，栈空间可能被复用
- 即使当前测试能正常工作，在优化编译或复杂场景下可能崩溃
- **正确做法**：永远不要返回局部变量的引用！

### 4.2 安全的返回引用场景

只有返回生命周期由调用者保证的引用才是安全的：

**C^ 代码（安全）：**
```cpp
// 场景 1：返回传入的引用
int& pass_through(int& x) {
    return &x;  // OK，x 的生命周期由调用者保证
}

// 场景 2：返回结构体成员的引用
class Counter {
private:
    int value;
public:
    func get_value(self) -> int& {
        return &self.value;  // OK，self 的生命周期由调用者保证
    }
}

// 场景 3：返回静态变量的引用
int& get_static() {
    static int s = 42;
    return &s;  // OK，静态变量生命周期是全局的
}
```

---

## 5. 引用自动解引用的完整设计

### 5.1 自动解引用的触发场景

| 场景 | 示例 | 是否自动解引用 |
|------|------|---------------|
| 值类型变量初始化引用返回值 | `int rr = get_ref();` | ✅ 是 |
| 值类型变量赋值引用表达式 | `int x; x = some_ref;` | ✅ 是 |
| 引用类型变量初始化引用返回值 | `int& r = get_ref();` | ❌ 否（保持引用） |
| 引用类型变量赋值引用表达式 | `int& r; r = some_ref;` | ❌ 否（保持引用） |
| 函数参数传递（值类型参数） | `func take_int(int x); take_int(some_ref);` | ✅ 是 |
| 函数参数传递（引用类型参数） | `func take_ref(int& x); take_ref(some_ref);` | ❌ 否 |

### 5.2 类型兼容性检查

在 `src/types/Type.cpp` 中实现的 `isCompatibleWith` 方法：

```cpp
bool Type::isCompatibleWith(const Type& other) const {
    // 先处理引用到值的自动解引用
    if (this->isReference()) {
        const auto *thisRef = static_cast<const ReferenceType *>(this);
        if (thisRef->getBaseType()->isCompatibleWith(other)) {
            return true;  // 引用可以隐式转换为基类型
        }
    }
    if (other.isReference()) {
        const auto *otherRef = static_cast<const ReferenceType *>(&other);
        if (this->isCompatibleWith(*otherRef->getBaseType())) {
            return true;
        }
    }
    
    // ... 其他兼容性检查
}
```

### 5.3 代码生成时的自动解引用

在 `src/llvm/LLVMCodeGenerator.cpp` 中实现的自动解引用：

```cpp
// 在变量初始化时
llvm::Value *initValue = generateExpression(std::move(varDecl->initializer));
if (initValue->getType()->isPointerTy()) {
    // 自动解引用：从指针加载值
    initValue = builder()->CreateLoad(varType, initValue);
}
builder()->CreateStore(initValue, varAlloca);
```

---

## 6. 左值与右值的处理

### 6.1 左值表达式

左值表达式可以取地址，在代码生成中返回指针：

| 表达式类型 | 代码生成返回 | 说明 |
|-----------|-------------|------|
| 变量访问 | `alloca` 指针 | 可以取地址 |
| 成员访问 | GEP 指针 | 可以取地址 |
| 数组下标访问 | GEP 指针 | 可以取地址 |
| 元组下标访问 | ExtractValue 或 GEP | 取决于实现 |

### 6.2 右值表达式

右值表达式不能取地址，在代码生成中返回值：

| 表达式类型 | 代码生成返回 | 说明 |
|-----------|-------------|------|
| 字面量 | 常量值 | 不能取地址 |
| 函数调用（返回值类型） | 值 | 不能取地址 |
| 算术表达式 | 值 | 不能取地址 |

---

## 7. 元组与引用的交互

### 7.1 元组类型的 LLVM 表示

元组在 LLVM IR 中表示为匿名结构体：

**C^ 代码：**
```cpp
var t = (1, 2, "hello");
```

**LLVM IR 生成：**
```llvm
%tuple = type { i32, i32, %LiteralView }

define i32 @main() {
entry:
  %t = alloca %tuple, align 8
  
  ; 初始化各元素
  ; ...
  
  ret i32 0
}
```

### 7.2 元组成员访问

**C^ 代码：**
```cpp
var t = (1, 2);
int a = t[0];  // 下标访问元组成员
```

**LLVM IR 生成（字面量索引）：**
```llvm
; 使用 ExtractValue 从结构体提取字段
%0 = load %tuple, %tuple* %t, align 8
%1 = extractvalue %tuple %0, 0  ; 提取第 0 个元素
store i32 %1, i32* %a, align 4
```

---

## 8. 总结与最佳实践

### 8.1 关键设计要点

1. **引用表示为指针**：所有引用类型在 LLVM IR 中都是指针
2. **自动解引用**：值类型接收引用返回值时自动解引用和拷贝
3. **悬垂引用风险**：返回局部变量引用是未定义行为，即使值接收也不安全
4. **不可变仅语义检查**：代码生成不区分可变和不可变引用

### 8.2 最佳实践

✅ **推荐做法：**
- 用值类型接收引用返回值时，确保引用指向有效对象
- 返回引用时，只返回生命周期由调用者保证的对象（参数、成员、静态变量）
- 大对象优先使用不可变引用传递，避免拷贝

❌ **避免做法：**
- 不要返回局部变量的引用，即使看起来"工作正常"
- 不要依赖值接收来"修复"悬垂引用问题
- 小对象优先使用值传递，避免不必要的引用开销

### 8.3 未来改进方向

1. **生命周期检查**：实现类似 Rust 的 borrow checker，静态检测悬垂引用
2. **移动语义**：完善右值引用和移动语义，避免不必要的拷贝
3. **优化**：在安全的情况下，省略自动解引用的拷贝（如返回值优化）
