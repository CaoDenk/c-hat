# C^ 泛型与元编程设计文档

C^ 的泛型系统旨在结合 C++ Templates 的**高性能**（编译期展开、零运行时开销）与 Rust/Swift Generics 的**安全性**（强类型约束）。

## 1. 泛型基础 (Generics Basics)

### 1.1 泛型类与结构体
使用尖括号 `<T>` 声明类型参数。类型参数可以在类/结构体内部作为普通类型使用。

```cpp
public class Box<T> {
    private T value_;
    
    public func init(value: T) {
        self.value_ = value;
    }
    
    public func get() -> T {
        return self.value_;
    }
}

// 使用
Box<int> intBox = new Box<int>(10);
Box<string> strBox = new Box<string>("Hello");
```

### 1.2 泛型函数
泛型参数位于函数名之后，参数列表之前。

```cpp
public func swap<T>(a: T^, b: T^) {
    T temp = a^;
    a^ = b^;
    b^ = temp;
}
```

### 1.3 泛型参数简写语法
为了避免与继承混淆，C^ **不支持** `<T: Concept>` 这种简写语法（因为 Concept 不是类型，且冒号容易误导为继承）。
所有的泛型约束必须通过 `where` 子句显式声明，或者在参数列表中使用 `Concept<T>` 谓词形式。

```cpp
// 推荐写法 (where 子句)
class Box<T> where Comparable<T> { ... }

// 推荐写法 (Concept<T> 谓词)
// 适用于函数参数，直观表示 "T 必须满足 Concept"
func sort<T>(list: List<T>) where Comparable<T> { ... }

// 错误写法 (C^ 不支持 T: Concept)
// class Box<T: Comparable> { ... } 
```

## 2. 概念与约束 (Concepts & Constraints)

C^ 采用 Concept（概念）作为泛型约束的核心机制，完全对标 C++20 Concepts。

### 2.1 定义概念 (Defining Concepts)
使用 `concept` 关键字定义一组类型必须满足的要求。概念本质上是一个编译期返回 `bool` 的谓词。

**语法形式**：
```ebnf
concept_declaration ::= 'concept' identifier generic_parameter_list? '=' constraint_expression ';'
```

#### 示例：基础概念
```cpp
// 定义一个名为 Addable 的概念
public concept Addable<T> = requires (T x, T y) {
    // 简单表达式需求：必须支持 x + y 操作
    x + y; 
};
```

### 2.2 `requires` 表达式详解
`requires` 表达式是定义概念的核心，它可以引入虚构参数来验证表达式的合法性。

#### 2.2.1 简单表达式需求 (Simple Requirement)
验证表达式是否合法（能编译通过）。

```cpp
requires (T x) {
    x++; // 必须支持自增
    x.to_string(); // 必须有 to_string 方法
}
```

#### 2.2.2 类型需求 (Type Requirement)
验证类型是否存在（通常用于关联类型）。C^ 移除了 `typename` 关键字，直接使用 `T.Type` 语法。

```cpp
public concept Iterable<T> = requires (T x) {
    // T 必须有一个名为 Item 的内嵌类型/关联类型
    T.Item;
    
    // T 必须有一个名为 Iterator 的关联类型
    T.Iterator;
};
```

## 3. 万能引用与完美转发 (Universal References & Perfect Forwarding)

为了支持高性能的泛型包装（Wrappers）和工厂函数（Factories），C^ 引入了**万能引用 (Universal Reference)** 机制，允许函数参数同时绑定左值和右值，并保持其值类别。

### 3.1 万能引用语法 (`T&~`)

在泛型函数中，`T&~` 是一种**参数模式匹配**语法。由于 C^ 强制要求在传递左值引用时使用 `&` 符号，编译器可以直接根据调用处的语法形态来决定参数类型，而**无需**像 C++ 那样污染泛型参数 `T` 的类型。

**规则：`T` 始终推导为值类型。**

| 调用语法 (Call Syntax) | 传入实参 (Argument)     | 推导的 T (Inferred T) | 实例化参数类型 (Instantiated Type) |
| :--------------------- | :---------------------- | :-------------------- | :--------------------------------- |
| `func(rv)`             | 右值 (R-value of `int`) | `int`                 | `int~` (移动引用)                  |
| `func(&lv)`            | 左值引用 (Ref to `int`) | `int`                 | `int&` (左值引用)                  |
| `func(lv)`             | 只读左值 (Const `int`)  | `int`                 | `int!&` (只读引用)                 |

这种设计使得泛型参数 `T` 保持干净（始终是基础类型），避免了 C++ 中 `T` 可能是 `int` 也可能是 `int&` 的混乱情况。

### 3.2 完美转发 (`forward<T>`)

为了将参数以原始的值类别传递给下一个函数，使用 **显式转发强转**：

- `(T&~)x` 表示“把 `x` 作为万能引用语义转发出去”
- 这是语言类型系统的一部分（`&~`），不是标准库函数，也不需要编译器开洞

```cpp
// 泛型工厂函数
func factory<T, Args...>(Args&~... args) -> T {
    // forward 保持 args 的左值/右值属性
    return new T(((Args&~)args)...);
}

class Widget {
    public Widget(int& x) { print("L-value Ref"); }
    public Widget(int~ x) { print("R-value Ref"); }
}

int a = 1;
factory<Widget>(&a);  // 调用 Widget(int&)，输出 "L-value Ref"
factory<Widget>(1);  // 调用 Widget(int~)，输出 "R-value Ref"
```

这里的 `(Args&~)args` 是显式标记：调用点看到它就能明确这是一处“转发”。编译器只需按 `&~` 的规则做类型推导与重载匹配，无需为某个 `forward` 名字提供特殊通道。

### 3.3 为什么需要设计这个？

1.  **消除冗余**：如果没有万能引用，包装函数需要为每个参数写 `const T&` 和 `T&~` 的重载，组合爆炸。
2.  **性能**：确保右值能被移动（零拷贝），左值能被引用（零拷贝），避免不必要的复制。
3.  **一致性**：与 C++ 现代实践保持一致，但语法更符合 C^ (`~` 对应 Move)。
