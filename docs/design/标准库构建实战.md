# 标准库构建实战：从原子到万物

本文档旨在演示如何利用 C^ 的**最小语言内核 (Minimal Language Core)**，在**零依赖**的情况下构建出标准库的核心组件 (`Slice`, `String`, `Vector`)。

如果我们将 C^ 视为一个微内核操作系统，那么编译器只提供最基础的机制（公理），其余一切（机制策略）皆由标准库（用户态）定义。

## 1. 语言内核：必要的内置特性 (The Prerequisites)

为了能够“自举”标准库，编译器**必须**内置以下特性。如果缺少任何一个，标准库将无法高效实现。

| 特性分类     | 内置特性               | 作用           | 理由                                             |
| :----------- | :--------------------- | :------------- | :----------------------------------------------- |
| **物理类型** | `literal_view`         | 只读代码段视图 | 字符串字面量的物理载体，构建 `String` 的原材料。 |
| **物理类型** | `T[N]` (Array)         | 栈上连续内存   | 数据的物理存储容器。                             |
| **物理类型** | `T^` (Pointer)         | 内存地址       | 也就是 `void*` 或 `int*`，操作内存的句柄。       |
| **生命周期** | `~Destructor`          | 作用域结束钩子 | 实现 RAII (智能指针, String) 的基础。            |
| **反射能力** | `@sizeof(T)`           | 编译期获取大小 | `Allocator` 需要知道分配多少字节。               |
| **鸭子协议** | `foreach` -> `.next()` | 语法糖解构     | 编译器不绑定特定 Iterator 类，只认方法签名。     |

---

## 2. 第一块砖：构建 `Slice<T>` (L1 核心)

`Slice<T>` 是标准库的第一公民。它不需要堆内存，不依赖任何系统调用。

### 2.1 需求
我们需要一个类型，能同时指向 `int[5]` (栈数组) 和 `literal_view` (静态区)，并提供下标访问。

### 2.2 实现代码

```cpp
// 这是一个普通的泛型结构体，没有任何编译器魔法
public struct Slice<T> {
    // 依赖内置类型 T^ 和 usize
    T^ ptr;
    usize len;

    // 1. 默认构造
    public Slice() : ptr(null), len(0) {}

    // 核心构造函数
    // C^ 哲学：信任程序员，指针操作不需要 unsafe 块，除非显式标记为安全边界
    public Slice(T^ base, usize length) 
        : ptr(base), len(length) {}

    // 协议构造：支持从 literal_view 隐式转换
    public implicit Slice(literal_view lv) 
        requires type_is_byte_v<T> && is_const_v<T>
    {
        this.ptr = (T^)lv.ptr; 
        this.len = lv.len;
    }

    // 下标操作符：返回引用
    public func operator[](usize index) -> T& {
        // 运行时边界检查
        if (index >= len) { trap(); } 
        
        // 显式返回引用：遵循 C# 风格 (return ref)，必须携带 &
        return &(ptr + index)^;
    }
}

// 使用示例
func main() {
    int[5] arr = [1, 2, 3, 4, 5];
    Slice<int> slice = arr; // 隐式转换

    // 1. 读取 (返回 T&)
    // 如果接收者是引用：
    let& ref = slice[0]; // ref 是 slice[0] 的别名

    // 如果接收者是值：
    var val = slice[0];  // val 是 slice[0] 的拷贝 (通过拷贝构造)
    
    // 2. 写入 (需要 mutable 引用)
    // slice[0] 返回 int&，可直接赋值
    slice[0] = 100; 
}
```

### 2.3 编译器配合 (Protocol)
当用户写 `Slice<byte!> s = "hello";` 时：
1. 编译器生成 `literal_view` (指向 .rodata)。
2. 编译器查找 `Slice` 是否有接受 `literal_view` 的 `implicit constructor`。
3. 发现匹配，生成调用代码。
**结论**：`Slice` 不需要内置，只要编译器支持 `implicit constructor` 协议。

---

## 3. 第二块砖：构建 `String` (L2 动态)

`String` 需要管理堆内存。这需要引入 `Allocator`。

### 3.1 引入 Allocator (系统接口)
标准库必须对接 OS。这通常通过 `extern` 实现。

```cpp
// 假设这是 libc 或 kernel 提供的接口
extern func malloc(usize size) -> byte^;
extern func free(byte^ ptr);
extern func memcpy(byte^ dst, byte^ src, usize len);
```

### 3.2 实现代码

```cpp
public struct String {
    // 组合 L1 的 Slice
    private Slice<byte> view; 
    // 状态位：最高位 1 表示 Static (literal_view)，0 表示 Heap
    private usize capacity_and_flags; 

    // 1. 从字面量构造 (零拷贝)
    // 需要 unsafe，因为我们将只读的 literal_view 强转为 Slice<byte> (内部是 byte^)
    // 这是安全的，因为 capacity_and_flags 标记了 FLAG_STATIC，析构和写入时会检查
    public implicit unsafe String(literal_view lv) {
        // 显式转换指针类型
        this.view.ptr = (byte^)lv.ptr; 
        this.view.len = lv.len;
        this.capacity_and_flags = FLAG_STATIC; 
    }

    // 2. 析构函数 (RAII)
    public ~String() {
        if (!is_static()) {
            free(view.ptr);
        }
    }

    // 3. 写时复制 (COW) 核心逻辑
    private func unshare(usize required_len) {
        if (is_static() || capacity < required_len) {
            // 分配新内存
            usize new_cap = calculate_growth(required_len);
            
            byte^ new_ptr = malloc(new_cap);
            // 拷贝旧数据
            if (view.len > 0) {
                memcpy(new_ptr, view.ptr, view.len);
            }
            // 如果原来是堆内存，释放旧的
            if (!is_static()) { free(view.ptr); }
            
            // 更新指针
            view.ptr = new_ptr;
            capacity_and_flags = new_cap; // 清除 Static 标志
            
        }
    }

    // 4. 修改操作
    public func append(byte b) {
        unshare(view.len + 1); // 确保独占且容量足够
        
        (view.ptr + view.len)^ = b;
        
        view.len++;
    }
}
```

**结论**：`String` 完全是用户态代码。只要语言提供 `literal_view` (来源) 和 `destructor` (清理)，就能构建出高效的字符串类。

---

## 4. 必要的语法糖：循环与迭代

用户希望写 `for (var x in list)`。编译器如何支持？

### 方案 A：硬编码 (C++ style)
编译器寻找 `begin()` 和 `end()` 方法。

### 方案 B：鸭子类型协议 (C^ style)
编译器只需寻找 `.next()` 方法。这是更好的选择，因为它将迭代器模式解耦，任何有 `.next()` 方法的对象都可以被 `foreach` 遍历，保持了语言核心的极简。

```cpp
// 用户定义的迭代器
struct MyIterator {
    // 成员变量应该是 usize 以匹配 Slice.len
    private Slice<T> list;
    private usize idx = 0;

    // 构造函数
    public MyIterator(Slice<T> l) : list(l), idx(0) {}

    // 只要有这个方法，就能被 foreach 使用
    public func next(self) -> Optional<T> {
        if (idx >= list.len) {
            return Optional<T>.None;
        }
        // 指针算术解引用需要 unsafe

        let val = (list.ptr + idx)^;
        idx++;
        return Optional<T>.Some(val);
    }
}

// 编译器展开
// for (var x in iter) { ... }
// 变为：
while (true) {
    var _opt = iter.next();
    if (_opt.is_none()) break;
    var x = _opt.unwrap();
    ...
}
```

**结论**：通过标准化 **Pattern (模式)** 而非 **Type (类型)**，语言核心保持了极简。

## 5. 总结：最小子集

为了构建上述大厦，C^ 语言规范必须承诺提供：

1.  **数据布局**：`struct`, `array`, `ptr`, `literal_view`。
2.  **行为钩子**：`ClassName` (构造), `~ClassName` (析构), `operator` (重载)。
3.  **转换协议**：`implicit` (隐式转换)。
4.  **控制流协议**：`foreach` 对应的 `.next()` 约定。


有了这 5 点，我们不需要在编译器里内置 `String`、`Vector` 或 `Map`，就可以在标准库中实现它们，并且性能与内置完全一致。
