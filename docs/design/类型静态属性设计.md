# C^ 类型静态属性设计

## 1. 设计目标

为 C^ 语言的原子类型和用户定义类型提供**静态属性访问机制**，这些属性是**编译期常量**，不占用类型的内存布局，仅在编译期提供元信息查询能力。

## 2. 核心设计

### 2.1 属性访问语法

使用 `.` 运算符直接在类型上访问静态属性：

```cpp
// 原子类型的静态属性
int.max_value    // int 类型的最大值
int.min_value    // int 类型的最小值
int.bits         // int 类型的位数
int.size         // int 类型的字节大小

// 用户定义类型的静态属性
struct Point {
    int x;
    int y;
    
    // 静态属性
    static const origin = Point { 0, 0 };
}

Point.origin      // Point 类型的静态属性
```

### 2.2 原子类型预定义静态属性

所有原子类型自动提供以下静态属性：

| 属性名        | 类型     | 说明             |
| ------------- | -------- | ---------------- |
| `max_value`   | 对应类型 | 该类型的最大值   |
| `min_value`   | 对应类型 | 该类型的最小值   |
| `bits`        | `long`   | 该类型的位数     |
| `size`        | `long`   | 该类型的字节大小 |
| `is_signed`   | `bool`   | 是否为有符号类型 |
| `is_integer`  | `bool`   | 是否为整数类型   |
| `is_floating` | `bool`   | 是否为浮点类型   |

#### 2.2.1 整数类型属性示例

```cpp
// byte (无符号 8 位)
byte.max_value    // 255
byte.min_value    // 0
byte.bits         // 8
byte.size         // 1
byte.is_signed    // false
byte.is_integer   // true
byte.is_floating  // false

// sbyte (有符号 8 位)
sbyte.max_value   // 127
sbyte.min_value   // -128
sbyte.bits        // 8
sbyte.size        // 1
sbyte.is_signed   // true

// int (有符号 32 位)
int.max_value     // 2147483647
int.min_value     // -2147483648
int.bits          // 32
int.size          // 4

// long (有符号 64 位)
long.max_value    // 9223372036854775807
long.min_value    // -9223372036854775808
long.bits         // 64
long.size         // 8
```

#### 2.2.2 浮点类型属性示例

```cpp
// float
float.max_value   // FLT_MAX
float.min_value   // FLT_MIN
float.bits        // 32
float.size        // 4
float.is_floating // true
float.is_integer  // false

// double
double.max_value  // DBL_MAX
double.min_value  // DBL_MIN
double.bits       // 64
double.size       // 8
```

#### 2.2.3 其他类型属性

```cpp
// bool
bool.max_value    // true
bool.min_value    // false
bool.bits         // 8 (或 1，取决于实现)
bool.size         // 1

// char
char.max_value    // 0x10FFFF (Unicode 最大码点)
char.min_value    // 0
char.bits         // 32
char.size         // 4
```

### 2.3 用户定义类型的静态属性

用户可以在结构体、类中定义静态属性：

```cpp
struct Math {
    static const PI = 3.141592653589793;
    static const E = 2.718281828459045;
}

// 使用
double circumference = 2 * Math.PI * radius;
```

静态属性可以是：
- 编译期常量
- 任意类型的值
- 甚至可以是函数（未来扩展）

### 2.4 编译期求值

所有类型静态属性都是**编译期常量**，可以在 `comptime` 上下文或任何需要常量表达式的地方使用：

```cpp
// 编译期数组大小
int[int.size] buffer;  // int[4] buffer

// 编译期计算
const int MAX_BUFFER = 1024 * 1024;
byte[MAX_BUFFER] data;

// 在 comptime 块中使用
comptime {
    if (int.bits != 32) {
        @error("int must be 32 bits");
    }
}
```

## 3. 实现策略

### 3.1 编译器内部实现

1. **类型属性表**：编译器内部为每个原子类型维护一张属性表
2. **属性解析**：在语义分析阶段，当遇到 `T.attribute` 时，检查 `T` 是否为类型
3. **常量折叠**：在编译期直接计算属性值，不生成运行时代码

### 3.2 与反射系统的关系

类型静态属性与反射系统（`@T`）是**互补**的：

- **类型静态属性**：`T.max_value` - 直接、简洁、常用
- **反射系统**：`@T.max_value` - 更强大、可扩展、用于元编程

两者可以共存，用户可以根据需要选择使用。

## 4. 设计优势

1. **零开销**：静态属性完全在编译期处理，不占用运行时内存
2. **语法简洁**：`int.max_value` 比 `std.numeric.max<int>()` 更直观
3. **类型安全**：编译器在编译期验证属性访问的有效性
4. **可扩展**：未来可以轻松添加更多属性
5. **用户友好**：常见的数值常量（如最大值、位数）唾手可得

## 5. 示例代码

```cpp
// 示例 1：使用类型属性进行边界检查
func clamp(int value, int min, int max) -> int {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

// 使用 int 的属性作为默认值
func safe_clamp(int value) -> int {
    return clamp(value, int.min_value, int.max_value);
}

// 示例 2：编译期选择合适的类型
comptime func choose_type(long required_bits) -> type {
    if (required_bits <= 8) return byte;
    if (required_bits <= 16) return short;
    if (required_bits <= 32) return int;
    return long;
}

// 示例 3：静态属性与反射系统结合
func print_type_info<T>() {
    comptime {
        print("Type: " + @T.name);
        print("Size: " + T.size);
        print("Max: " + T.max_value);
    }
}

// 使用
print_type_info<int>();
```
