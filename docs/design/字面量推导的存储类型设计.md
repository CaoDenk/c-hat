# 字面量推导的存储类型设计（方案B）

## 日期
2026-02-18

## 概述
本文档详细说明 C^ 语言中各种字面量类型的默认存储位置和内存布局，基于方案B设计：
- 数组和元组都是值类型，默认在栈上
- 视图类型需要显式声明
- 形成完美闭环！

---

## 1. 核心设计原则

### 1.1 完美闭环设计
根据方案B，我们形成了完美的闭环设计：

```
值类型（Value Types）
├── 数组 Type[N]    → 默认栈上，拥有数据，可修改
└── 元组 (T1, T2)   → 默认栈上，拥有数据，可修改

视图类型（View Types）
├── 切片 Type[]     → 引用已有数据，可写
└── 只读切片 Type![] → 引用 .rodata，只读
```

### 1.2 存储位置选择的依据
C^ 语言根据以下规则确定字面量的默认存储位置：

| 原则               | 说明                                                 |
| ------------------ | ---------------------------------------------------- |
| **值类型优先**     | 数组和元组都是值类型，默认在栈上                     |
| **视图类型显式**   | 如果需要切片（视图），需要显式声明                   |
| **纯常量只读切片** | 显式声明 `Type![]` 时，放在 `.rodata` 段             |
| **一致设计**       | 数组和元组的默认行为完全一致                         |
| **不可变绑定**     | `let` 声明表示不可变绑定，但不改变值类型本身的可变性 |

### 1.3 var vs let 的区别
C^ 语言中，`var` 和 `let` 的区别是**绑定的可变性**，而不是**值类型的可变性**：

| 语法                                 | 说明                                                                                        |
| ------------------------------------ | ------------------------------------------------------------------------------------------- |
| `var arr = [1, 2, 3];`               | 可变绑定，可以重新赋值 `arr = [4, 5, 6];`（必须是 `int[3]`），也可以修改元素 `arr[0] = 99;` |
| `let arr = [1, 2, 3];`               | 不可变绑定，不能重新赋值，但可以修改元素 `arr[0] = 99;`（因为值类型本身是可修改的）         |
| `const int[3] arr = [1, 2, 3];`      | 不可变值，既不能重新赋值，也不能修改元素（显式类型，推荐写法）                              |
| `let arr: const int[3] = [1, 2, 3];` | 不推荐，显式类型时不需要 `let`（const 是类型的一部分）                                      |

**关键理解**：
- `var`/`let` 控制的是**绑定**（变量名能否指向别的东西）
- 值类型（数组、元组）本身默认是**可修改**的
- 如果需要不可变的值，用 `const` 修饰类型（直接写 `const Type[N]`）
- 数组重新赋值时，**类型必须匹配**（`int[3]` 只能赋值 `int[3]`）

### 1.4 const 的正确写法
C^ 语言中，`const` 是**类型的一部分**，不是绑定的修饰符：

**正确写法1：显式类型**
```cpp
const int[3] arr = [1, 2, 3];
// 存储位置：栈上（const 是类型的一部分，不改变存储位置）
// arr = [4, 5, 6]; // Error: 不能重新赋值
// arr[0] = 99;     // Error: 不能修改元素
```

**正确写法2：类型推导**
```cpp
// 如果需要不可变绑定但值可变
let arr = [1, 2, 3];
// arr = [4, 5, 6]; // Error: 不能重新赋值
arr[0] = 99;       // OK: 可以修改元素
```

**不推荐写法**：
```cpp
// 不推荐：显式类型时不需要 let/var
// let arr: const int[3] = [1, 2, 3];
```

**关键理解**：
- 显式写类型时，直接写 `const Type[N] varName = ...;` 即可
- `const` 是**类型的一部分**，不是绑定的修饰符
- `const int[3]` 仍然是值类型，存储在栈上
- 只有显式声明为视图类型（`Type![]`）时，才会放在 `.rodata`

---

## 2. 数组字面量的存储类型

### 2.1 数组场景总结
| 场景             | 语法                         | 类型      | 存储位置  | 说明                                 |
| ---------------- | ---------------------------- | --------- | --------- | ------------------------------------ |
| **数组字面量**   | `var arr = [1, 2, 3];`       | `Type[N]` | 栈        | 值类型，拥有数据，可修改             |
| **切片初始化**   | `Type[] slice = [1, 2, 3];`  | `Type[]`  | 栈        | 编译器自动创建临时数组，延长生命周期 |
| **显式只读切片** | `Type![] slice = [1, 2, 3];` | `Type![]` | `.rodata` | 只读视图，零成本                     |
| **切片引用**     | `Type[] slice = arr;`        | `Type[]`  | 栈        | 引用已有数据，可写                   |

### 2.2 数组字面量详解
**语法：**
```cpp
var arr = [1, 2, 3];
```

**推导类型：** `Type[3]`（值类型）
**存储位置：** 栈上
**内存布局：**
```
栈
┌─────────────────────────┐
│  Type[3] arr            │
│    [0]: 1               │
│    [1]: 2               │
│    [2]: 3               │
└─────────────────────────┘
```

**说明：**
- 数组是值类型，默认在栈上分配
- 拥有数据所有权，自动管理生命周期
- 支持可修改
- 与元组的默认行为完全一致

### 2.3 显式只读切片（.rodata）
**语法：**
```cpp
int![] slice = [1, 2, 3];
```

**推导类型：** `int![]`（只读切片）
**存储位置：** `.rodata` 段
**内存布局：**
```
.rodata 段
┌─────────────────────────┐
│  [1, 2, 3]             │ ← 常量数组
└─────────────────────────┘
         ↑
         │
    int![] slice
    ┌───────────────┐
    │ ptr: ----------→ .rodata
    │ length: 3     │
    └───────────────┘
```

**说明：**
- 视图类型需要显式声明
- 纯常量数据放在 `.rodata` 段，零成本初始化
- 标记为只读（`![]`），防止意外修改

### 2.4 切片初始化（临时数组延长生命周期）
**语法：**
```cpp
int[] slice = [1, 2, 3];
```

**编译器转换：**
```cpp
// 编译器自动转换为：
int[3] _temp = [1, 2, 3]; // 临时数组，与 slice 同生命周期
int[] slice = _temp;
```

**推导类型：** `int[]`（切片）
**存储位置：** 栈上（临时数组）
**内存布局：**
```
栈
┌─────────────────────────┐
│  int[3] _temp          │ ← 临时数组
│    [0]: 1               │
│    [1]: 2               │
│    [2]: 3               │
└─────────────────────────┘
         ↑
         │
    int[] slice
    ┌───────────────┐
    │ ptr: ----------→ _temp
    │ length: 3     │
    └───────────────┘
```

**说明：**
- 编译器自动创建临时数组，生命周期与 slice 相同
- 避免悬空指针，安全可靠
- 用户体验好，只需要写一行代码
- 符合现代语言（Swift/Rust）的设计习惯

---

## 3. 字符串字面量的存储类型

字符串字面量需要特殊处理，因为它们通常是只读的，而且很长。我们采用混合方案，既保证效率又提供灵活性。

### 3.1 字符串场景总结
| 场景             | 语法                         | 类型          | 存储位置  | 说明               |
| ---------------- | ---------------------------- | ------------- | --------- | ------------------ |
| **字符串字面量** | `var s = "hello";`           | `LiteralView` | `.rodata` | 零拷贝，只读，高效 |
| **显式只读切片** | `byte![] view = "hello";`    | `byte![]`     | `.rodata` | 零拷贝，只读       |
| **栈上字节数组** | `byte[$] s_stack = "hello";` | `byte[N]`     | 栈        | 可修改，显式拷贝   |

### 3.2 字符串字面量详解
**语法：**
```cpp
var s = "hello";
```

**推导类型：** `LiteralView`（编译器内置类型）
**存储位置：** `.rodata` 段
**内存布局：**
```
.rodata 段
┌─────────────────────────┐
│  "hello\0"             │
└─────────────────────────┘
         ↑
         │
    LiteralView s
    ┌───────────────┐
    │ ptr: ----------→ .rodata
    │ len: 5        │
    └───────────────┘
```

**说明：**
- 字符串字面量默认类型是 `LiteralView`，指向 `.rodata`
- 零拷贝，高效
- 只读，不能修改
- 符合常见的语言设计习惯

### 3.3 栈上字节数组（[$] 语法）
**语法：**
```cpp
byte[$] s_stack = "hello";
```

**推导类型：** `byte[5]`（值类型）
**存储位置：** 栈上
**内存布局：**
```
栈
┌─────────────────────────┐
│  byte[5] s_stack       │
│    [0]: 'h'            │
│    [1]: 'e'            │
│    [2]: 'l'            │
│    [3]: 'l'            │
│    [4]: 'o'            │
└─────────────────────────┘
```

**说明：**
- 使用 `[$]` 语法显式要求栈数组
- 编译器自动从字符串字面量推导长度
- 在栈上分配内存，从 `.rodata` 拷贝数据
- 可修改
- 语义清晰："我要栈数组"

### 3.4 完整示例
```cpp
// ========== 字符串字面量（默认 LiteralView，.rodata） ==========
var s = "hello"; // 类型: LiteralView
// s[0] = 'H'; // Error: 只读

// ========== 显式只读切片（与 LiteralView 类似） ==========
byte![] view = "hello"; // 类型: byte![]
// view[0] = 'H'; // Error: 只读

// ========== 栈上字节数组（使用 [$] 语法） ==========
byte[$] s_stack = "hello"; // 类型: byte[5]，栈上分配
s_stack[0] = 'H'; // OK: 可修改

// ========== 显式指定大小 ==========
byte[10] s_fixed = "hello"; // 类型: byte[10]，栈上分配
```

---

## 4. 元组字面量的存储类型

### 4.1 元组场景总结
| 场景           | 语法                       | 类型                 | 存储位置 | 说明                     |
| -------------- | -------------------------- | -------------------- | -------- | ------------------------ |
| **元组字面量** | `var t = (1, 3.14, true);` | `(int, float, bool)` | 栈       | 值类型，拥有数据，可修改 |

### 4.2 元组作为内置类型
元组是 C^ 语言的**内置值类型**，类似于数组，但元素类型可以不同：

| 特性         | 说明                        |
| ------------ | --------------------------- |
| **类型语法** | `(T1, T2, T3)`              |
| **值语法**   | `(val1, val2, val3)`        |
| **访问方式** | `tuple[0]`, `tuple[1]`, ... |
| **存储位置** | 默认栈上                    |
| **可修改**   | 默认可修改                  |
| **值类型**   | 是，拥有数据所有权          |

元组与数组形成完美对称：
- 数组：`Type[N]`，同类型元素，`[val1, val2]`
- 元组：`(T1, T2)`，不同类型元素，`(val1, val2)`

### 4.3 元组字面量详解
**语法：**
```cpp
var tuple = (1, 3.14, true);
```

**推导类型：** `(int, float, bool)`（值类型）
**存储位置：** 栈上
**内存布局：**
```
栈
┌─────────────────────────────────────┐
│  (int, float, bool) tuple          │
│    int: 1           (4 字节)       │
│    float: 3.14      (8 字节)       │
│    bool: true       (1 字节，对齐) │
└─────────────────────────────────────┘
```

**说明：**
- 元组是值类型，默认在栈上分配
- 拥有数据所有权，自动管理生命周期
- 支持不同类型的元素组合
- 支持可修改
- 内存布局遵循 C 语言的结构体对齐规则
- 与数组的默认行为完全一致！

---

## 5. 完整对比（方案B）

### 5.1 数组 vs 元组对比
| 特性             | 数组                   | 元组                       |
| ---------------- | ---------------------- | -------------------------- |
| **语法**         | `var arr = [1, 2, 3];` | `var t = (1, 3.14, true);` |
| **元素类型**     | 必须相同               | 可以不同                   |
| **默认存储位置** | 栈                     | 栈                         |
| **值类型**       | 是                     | 是                         |
| **可修改**       | 是                     | 是                         |
| **所有权**       | 拥有                   | 拥有                       |

**完美一致性！** 数组和元组都是值类型，默认在栈上！

---

## 6. 内存布局详解

### 6.1 数组（值类型，栈上）
```
栈
┌─────────────────────────┐
│  int[3] arr             │
│    [0]: 1               │
│    [1]: 2               │
│    [2]: 3               │
└─────────────────────────┘
```

### 6.2 只读切片（.rodata）
```
.rodata 段
┌─────────────────────────┐
│  [1, 2, 3]             │ ← 常量数组
└─────────────────────────┘
         ↑
         │
    int![] slice
    ┌───────────────┐
    │ ptr: ----------→ .rodata
    │ length: 3     │
    └───────────────┘
```

### 6.3 元组（值类型，栈上）
```
栈
┌─────────────────────────────────────┐
│  (int, float, bool) tuple          │
│    int: 1           (4 字节)       │
│    float: 3.14      (8 字节)       │
│    bool: true       (1 字节，对齐) │
└─────────────────────────────────────┘
```

---

## 7. 编译器实现策略

### 7.1 字面量分析阶段
编译器在语义分析阶段检查字面量：

```cpp
// 伪代码：判断是否是纯常量字面量
bool isPureConstantLiteral(LiteralExpr expr) {
    for (auto element : expr.elements) {
        if (!element.isCompileTimeConstant()) {
            return false;
        }
    }
    return true;
}
```

### 7.2 存储位置选择
```cpp
// 伪代码：选择存储位置
enum class StorageLocation {
    RoData,  // .rodata 段
    Stack,   // 栈
    Heap     // 堆（显式 new）
};

StorageLocation chooseStorageLocation(LiteralExpr expr, Type explicitType) {
    if (explicitType && explicitType.isReadonlySlice()) {
        // 显式声明只读切片
        return StorageLocation::RoData;
    } else {
        // 默认：值类型，栈上
        return StorageLocation::Stack;
    }
}
```

### 7.3 代码生成
**栈上（数组、元组）：**
1. 在栈上分配内存
2. 将字面量元素拷贝到栈上
3. 值类型，拥有数据所有权

**.rodata 段（只读切片）：**
1. 在 `.rodata` 段生成常量数据
2. 生成指向该数据的视图（切片）

---

## 8. 完整示例

```cpp
// ========== 数组字面量（值类型，栈上） ==========
var arr = [1, 2, 3];
// 类型: int[3]（值类型）
// 存储: 栈上
arr[0] = 99; // OK: 可修改

// 含变量的数组
var x = 10;
var arr2 = [x, 20, 30];
// 类型: int[3]（值类型）
// 存储: 栈上
arr2[0] = 99; // OK: 可修改

// ========== 显式只读切片（.rodata） ==========
int![] const_slice = [1, 2, 3];
// 类型: int![]（只读切片）
// 存储: .rodata
// const_slice[0] = 99; // Error: 只读

// ========== 切片初始化（临时数组延长生命周期） ==========
int[] slice = [1, 2, 3];
// 编译器自动创建临时数组 int[3] _temp = [1, 2, 3];
// 类型: int[]（切片）
// 存储: 栈上（引用临时数组）
slice[0] = 99; // OK: 修改临时数组

// ========== 切片引用（引用已有数组） ==========
int[] slice2 = arr;
// 类型: int[]（切片）
// 存储: 栈上（引用 arr）
slice2[0] = 100; // OK: 修改 arr

// ========== 元组（值类型，栈上） ==========
var tuple = (1, 3.14, true);
// 类型: (int, float, bool)（值类型）
// 存储: 栈上
var first = tuple[0];  // 1
var second = tuple[1]; // 3.14
var third = tuple[2];  // true

// ========== 字符串字面量（默认 LiteralView，.rodata） ==========
var s = "hello"; // 类型: LiteralView
// s[0] = 'H'; // Error: 只读

// ========== 显式只读切片（.rodata） ==========
byte![] view = "hello"; // 类型: byte![]
// view[0] = 'H'; // Error: 只读

// ========== 栈上字节数组（使用 [$] 语法） ==========
byte[$] s_stack = "hello"; // 类型: byte[5]，栈上分配
s_stack[0] = 'H'; // OK: 可修改

// ========== 显式指定大小 ==========
byte[10] s_fixed = "hello"; // 类型: byte[10]，栈上分配
```

---

## 9. 设计决策总结

### Q1: 为什么数组和元组都默认在栈上？
**A:**
- 完美一致性：数组和元组都是值类型，默认行为应该一致
- 符合用户直觉：`[1, 2, 3]` 和 `(1, 2, 3)` 都是值
- 简单优雅：不需要 `Type[$]` 语法，默认就是栈数组
- 可修改性：默认可修改，更实用
- 完美闭环：值类型默认栈，视图类型显式声明

### Q2: 如果需要 `.rodata` 的只读切片怎么办？
**A:**
显式声明即可：
```cpp
int![] slice = [1, 2, 3];
```

### Q3: 数组和元组的区别是什么？
**A:**
- **元素类型**：数组要求元素类型相同，元组可以不同
- **语义**：数组用于同类型序列，元组用于不同类型的组合
- **默认存储位置**：两者都默认在栈上（完全一致！）

### Q4: 为什么字符串字面量默认是 LiteralView 而不是栈数组？
**A:**
- **效率优先**：字符串通常只读，不需要拷贝，零拷贝更高效
- **常见场景**：大多数场景下字符串字面量只是被引用，不需要修改
- **灵活性**：需要栈数组时用 `[$]` 语法显式声明

### Q5: 为什么保留 `[$]` 语法用于字符串？
**A:**
- **语义清晰**：明确表示"我要栈数组"
- **自动推导**：自动从字符串字面量推导长度，方便
- **一致性**：与之前的设计保持兼容，不会破坏现有代码

### Q6: var 和 let 的区别是什么？
**A:**
- **var**：可变绑定，可以重新赋值（但类型必须匹配），也可以修改元素
- **let**：不可变绑定，不能重新赋值，但可以修改元素（因为值类型本身是可修改的）
- **const Type[N]**：显式类型，不可变值，既不能重新赋值，也不能修改元素

**关键理解**：
- `var`/`let` 控制的是**绑定**（变量名能否指向别的东西）
- 值类型（数组、元组）本身默认是**可修改**的
- 如果需要不可变的值，用 `const` 修饰类型（直接写 `const Type[N]`）

### Q7: 为什么数组重新赋值时类型必须匹配？
**A:**
- **类型安全**：`int[3]` 是具体类型，大小是类型的一部分
- **一致性**：`int[3]` 和 `int[4]` 是不同的类型，不能互相赋值
- **可预测性**：避免意外改变数组大小导致的错误

**示例：**
```cpp
var arr = [1, 2, 3];    // 类型: int[3]
arr = [4, 5, 6];         // OK: 也是 int[3]
// arr = [4, 5, 6, 7];   // Error: 类型不匹配（int[4] vs int[3]）
```

### Q8: 为什么显式类型时不需要 let/var？
**A:**
- **const 是类型的一部分**：`const int[3]` 是完整的类型声明
- **简洁性**：显式写类型时，直接写 `const Type[N] varName = ...;` 更简洁
- **避免冗余**：`let arr: const int[3] = [1, 2, 3];` 是冗余的

**推荐写法**：
```cpp
const int[3] arr = [1, 2, 3];  // 推荐，简洁明了
```

**不推荐写法**：
```cpp
// let arr: const int[3] = [1, 2, 3];  // 不推荐，冗余
```

### Q9: 为什么元组是内置类型？
**A:**
- **完美对称**：数组 `[1, 2, 3]` 和元组 `(1, 2, 3)` 都是内置值类型
- **简洁性**：不需要像 C++ 那样用 `std::tuple`，直接用 `(1, 2, 3)` 就行
- **一致性**：数组和元组的默认行为完全一致，都在栈上，都可修改
- **实用性**：元组是常用的数据结构，内置支持更方便

---

## 10. 总结

根据方案B，C^ 语言的字面量存储类型设计遵循以下原则：

1. **值类型优先**：数组和元组都是值类型，默认在栈上
2. **视图类型显式**：如果需要切片（视图），需要显式声明
3. **完美一致性**：数组和元组的默认行为完全一致
4. **简单优雅**：不需要 `Type[$]` 语法（数组/元组），默认就是栈数组
5. **字符串特殊处理**：字符串字面量默认是 `LiteralView`（指向 `.rodata`），需要栈数组时用 `[$]` 语法
6. **完美闭环**：值类型默认栈，视图类型显式声明
7. **类型安全**：数组重新赋值时类型必须匹配（`int[3]` 只能赋值 `int[3]`）
8. **灵活的 const**：支持两种 const 写法，用户可以选择自己喜欢的风格

这种设计既保持了 C^ 语言的简洁性，又实现了完美的一致性和闭环！
