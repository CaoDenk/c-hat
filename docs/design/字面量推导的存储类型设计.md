# 字面量推导的存储类型设计（方案B）

## 日期
2026-02-18

## 概述
本文档详细说明 C^ 语言中各种字面量类型的默认存储位置和内存布局，基于方案B设计：
- 数组和元组都是值类型，默认在栈上
- 视图类型需要显式声明
- 形成完美闭环！

---

## 1. 核心设计原则

### 1.1 完美闭环设计
根据方案B，我们形成了完美的闭环设计：

```
值类型（Value Types）
├── 数组 Type[N]    → 默认栈上，拥有数据，可修改
└── 元组 (T1, T2)   → 默认栈上，拥有数据，可修改

视图类型（View Types）
├── 切片 Type[]     → 引用已有数据，可写
└── 只读切片 Type![] → 引用 .rodata，只读
```

### 1.2 存储位置选择的依据
C^ 语言根据以下规则确定字面量的默认存储位置：

| 原则               | 说明                                     |
| ------------------ | ---------------------------------------- |
| **值类型优先**     | 数组和元组都是值类型，默认在栈上         |
| **视图类型显式**   | 如果需要切片（视图），需要显式声明       |
| **纯常量只读切片** | 显式声明 `Type![]` 时，放在 `.rodata` 段 |
| **一致设计**       | 数组和元组的默认行为完全一致             |

---

## 2. 数组字面量的存储类型

### 2.1 数组场景总结
| 场景             | 语法                         | 类型      | 存储位置  | 说明                     |
| ---------------- | ---------------------------- | --------- | --------- | ------------------------ |
| **数组字面量**   | `var arr = [1, 2, 3];`       | `Type[N]` | 栈        | 值类型，拥有数据，可修改 |
| **显式只读切片** | `Type![] slice = [1, 2, 3];` | `Type![]` | `.rodata` | 只读视图，零成本         |
| **切片引用**     | `Type[] slice = arr;`        | `Type[]`  | 栈        | 引用已有数据，可写       |

### 2.2 数组字面量详解
**语法：**
```cpp
var arr = [1, 2, 3];
```

**推导类型：** `Type[3]`（值类型）
**存储位置：** 栈上
**内存布局：**
```
栈
┌─────────────────────────┐
│  Type[3] arr            │
│    [0]: 1               │
│    [1]: 2               │
│    [2]: 3               │
└─────────────────────────┘
```

**说明：**
- 数组是值类型，默认在栈上分配
- 拥有数据所有权，自动管理生命周期
- 支持可修改
- 与元组的默认行为完全一致

### 2.3 显式只读切片（.rodata）
**语法：**
```cpp
int![] slice = [1, 2, 3];
```

**推导类型：** `int![]`（只读切片）
**存储位置：** `.rodata` 段
**内存布局：**
```
.rodata 段
┌─────────────────────────┐
│  [1, 2, 3]             │ ← 常量数组
└─────────────────────────┘
         ↑
         │
    int![] slice
    ┌───────────────┐
    │ ptr: ----------→ .rodata
    │ length: 3     │
    └───────────────┘
```

**说明：**
- 视图类型需要显式声明
- 纯常量数据放在 `.rodata` 段，零成本初始化
- 标记为只读（`![]`），防止意外修改

---

## 3. 元组字面量的存储类型

### 3.1 元组场景总结
| 场景           | 语法                       | 类型                 | 存储位置 | 说明                     |
| -------------- | -------------------------- | -------------------- | -------- | ------------------------ |
| **元组字面量** | `var t = (1, 3.14, true);` | `(int, float, bool)` | 栈       | 值类型，拥有数据，可修改 |

### 3.2 元组字面量详解
**语法：**
```cpp
var tuple = (1, 3.14, true);
```

**推导类型：** `(int, float, bool)`（值类型）
**存储位置：** 栈上
**内存布局：**
```
栈
┌─────────────────────────────────────┐
│  (int, float, bool) tuple          │
│    int: 1           (4 字节)       │
│    float: 3.14      (8 字节)       │
│    bool: true       (1 字节，对齐) │
└─────────────────────────────────────┘
```

**说明：**
- 元组是值类型，默认在栈上分配
- 拥有数据所有权，自动管理生命周期
- 支持不同类型的元素组合
- 支持可修改
- 内存布局遵循 C 语言的结构体对齐规则
- 与数组的默认行为完全一致！

---

## 4. 完整对比（方案B）

### 4.1 数组 vs 元组对比
| 特性             | 数组                   | 元组                       |
| ---------------- | ---------------------- | -------------------------- |
| **语法**         | `var arr = [1, 2, 3];` | `var t = (1, 3.14, true);` |
| **元素类型**     | 必须相同               | 可以不同                   |
| **默认存储位置** | 栈                     | 栈                         |
| **值类型**       | 是                     | 是                         |
| **可修改**       | 是                     | 是                         |
| **所有权**       | 拥有                   | 拥有                       |

**完美一致性！** 数组和元组都是值类型，默认在栈上！

---

## 5. 内存布局详解

### 5.1 数组（值类型，栈上）
```
栈
┌─────────────────────────┐
│  int[3] arr             │
│    [0]: 1               │
│    [1]: 2               │
│    [2]: 3               │
└─────────────────────────┘
```

### 5.2 只读切片（.rodata）
```
.rodata 段
┌─────────────────────────┐
│  [1, 2, 3]             │ ← 常量数组
└─────────────────────────┘
         ↑
         │
    int![] slice
    ┌───────────────┐
    │ ptr: ----------→ .rodata
    │ length: 3     │
    └───────────────┘
```

### 5.3 元组（值类型，栈上）
```
栈
┌─────────────────────────────────────┐
│  (int, float, bool) tuple          │
│    int: 1           (4 字节)       │
│    float: 3.14      (8 字节)       │
│    bool: true       (1 字节，对齐) │
└─────────────────────────────────────┘
```

---

## 6. 编译器实现策略

### 6.1 字面量分析阶段
编译器在语义分析阶段检查字面量：

```cpp
// 伪代码：判断是否是纯常量字面量
bool isPureConstantLiteral(LiteralExpr expr) {
    for (auto element : expr.elements) {
        if (!element.isCompileTimeConstant()) {
            return false;
        }
    }
    return true;
}
```

### 6.2 存储位置选择
```cpp
// 伪代码：选择存储位置
enum class StorageLocation {
    RoData,  // .rodata 段
    Stack,   // 栈
    Heap     // 堆（显式 new）
};

StorageLocation chooseStorageLocation(LiteralExpr expr, Type explicitType) {
    if (explicitType && explicitType.isReadonlySlice()) {
        // 显式声明只读切片
        return StorageLocation::RoData;
    } else {
        // 默认：值类型，栈上
        return StorageLocation::Stack;
    }
}
```

### 6.3 代码生成
**栈上（数组、元组）：**
1. 在栈上分配内存
2. 将字面量元素拷贝到栈上
3. 值类型，拥有数据所有权

**.rodata 段（只读切片）：**
1. 在 `.rodata` 段生成常量数据
2. 生成指向该数据的视图（切片）

---

## 7. 完整示例

```cpp
// ========== 数组字面量（值类型，栈上） ==========
var arr = [1, 2, 3];
// 类型: int[3]（值类型）
// 存储: 栈上
arr[0] = 99; // OK: 可修改

// 含变量的数组
var x = 10;
var arr2 = [x, 20, 30];
// 类型: int[3]（值类型）
// 存储: 栈上
arr2[0] = 99; // OK: 可修改

// ========== 显式只读切片（.rodata） ==========
int![] const_slice = [1, 2, 3];
// 类型: int![]（只读切片）
// 存储: .rodata
// const_slice[0] = 99; // Error: 只读

// ========== 切片引用（引用已有数组） ==========
int[] slice = arr;
// 类型: int[]（切片）
// 存储: 栈上（引用 arr）
slice[0] = 100; // OK: 修改 arr

// ========== 元组（值类型，栈上） ==========
var tuple = (1, 3.14, true);
// 类型: (int, float, bool)（值类型）
// 存储: 栈上
var first = tuple[0];  // 1
var second = tuple[1]; // 3.14
var third = tuple[2];  // true
```

---

## 8. 设计决策总结

### Q1: 为什么数组和元组都默认在栈上？
**A:**
- 完美一致性：数组和元组都是值类型，默认行为应该一致
- 符合用户直觉：`[1, 2, 3]` 和 `(1, 2, 3)` 都是值
- 简单优雅：不需要 `Type[$]` 语法，默认就是栈数组
- 可修改性：默认可修改，更实用
- 完美闭环：值类型默认栈，视图类型显式声明

### Q2: 如果需要 `.rodata` 的只读切片怎么办？
**A:**
显式声明即可：
```cpp
int![] slice = [1, 2, 3];
```

### Q3: 数组和元组的区别是什么？
**A:**
- **元素类型**：数组要求元素类型相同，元组可以不同
- **语义**：数组用于同类型序列，元组用于不同类型的组合
- **默认存储位置**：两者都默认在栈上（完全一致！）

---

## 9. 总结

根据方案B，C^ 语言的字面量存储类型设计遵循以下原则：

1. **值类型优先**：数组和元组都是值类型，默认在栈上
2. **视图类型显式**：如果需要切片（视图），需要显式声明
3. **完美一致性**：数组和元组的默认行为完全一致
4. **简单优雅**：不需要 `Type[$]` 语法，默认就是栈数组
5. **完美闭环**：值类型默认栈，视图类型显式声明

这种设计既保持了 C^ 语言的简洁性，又实现了完美的一致性和闭环！
