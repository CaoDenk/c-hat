# C^ 元组设计文档 (Tuple Design)

## 1. 设计背景

在现代编程中，**轻量级的数据聚合**和**多返回值**是高频需求。C/C++ 传统的 `struct` 定义过于沉重（需要命名、单独声明），而 `std::pair` / `std::tuple` 的语法又过于冗长且缺乏语言级支持（`.first` / `std::get<0>` 体验极差）。

C^ 引入**元组 (Tuple)** 作为内置的一等公民类型，旨在提供一种**零开销、类型安全、语法简洁**的匿名数据结构。

## 2. 核心特性

*   **值类型 (Value Type)**：元组在 C^ 中是栈上分配的匿名结构体（Anonymous Struct）。没有堆分配，没有虚表，性能与手写 struct 完全一致。
*   **消除逗号表达式**：为了支持元组语法 `(a, b)`，C^ **移除了 C 语言风格的逗号运算符**。在 C^ 中，`(a, b)` 永远表示构造一个元组，而不是“执行 a 丢弃结果再执行 b”。
*   **解构 (Destructuring)**：支持模式匹配解构，轻松处理多返回值。

## 3. 语法定义

### 3.1 元组构造与类型

元组使用圆括号 `()` 定义，元素之间用逗号 `,` 分隔。

```cpp
// 1. 推导类型 (Unnamed Tuple)
// 类型为 (int, string, double)
var t1 = (1, "hello", 3.14);

// 2. 显式类型
(int, int) point = (10, 20);

// 3. 命名元组 (Named Tuple)
// 类似于匿名结构体，带有字段名
(int x, int y) p = (10, 20);
```

### 3.2 成员访问

*   **无名元组**：使用编译期下标 `[N]` 访问。这与数组语法统一，但要求 N 必须是编译期常量。
*   **命名元组**：使用字段名访问，也支持下标访问。

```cpp
var t = (100, 200);
print(t[0]); // 100
print(t[1]); // 200

(string name, int age) user = ("Alice", 18);
print(user.name); // "Alice"
print(user[0]);   // "Alice" (仍然有效，等同于 std::get<0>(user))
```

### 3.3 歧义消解

*   **分组 vs 元组**：
    *   `(expr)`：被视为表达式分组（括号）。
    *   `(expr1, expr2)`：被视为元组。
    *   **单元素元组**：C^ **不支持** `(val,)` 这种单元素元组语法。如果需要包装单个值，请使用结构体或直接使用该值。元组至少包含 2 个元素。

## 4. 解构 (Destructuring)

解构是将元组拆解为独立变量的语法糖。

```cpp
func get_rect() -> (int, int) {
    return (1920, 1080);
}

func main() {
    // 1. 声明并解构
    var (w, h) = get_rect();
    
    // 2. 赋值给现有变量
    int x, y;
    (x, y) = get_rect();
    
    // 3. 忽略某些值 (使用下划线 _)
    var (width, _) = get_rect();
    
    // 4. 交换变量 (Swap) - 经典用法
    (x, y) = (y, x);
}
```

## 5. 与逗号运算符的冲突处理

C 语言中的逗号运算符（`a, b` 求值 a 丢弃结果，返回 b）在 C^ 中**被移除**。这解决了 `(a, b)` 到底是“元组”还是“逗号表达式”的二义性。

### 5.1 替代方案

对于习惯使用逗号运算符的场景（主要是 `for` 循环），C^ 在语法层面做了特殊支持，而不是通过通用的运算符。

*   **For 循环**：`for` 语句的 `init` 和 `update` 子句显式允许逗号分隔的表达式列表。

```cpp
// 合法：这是 for 循环特有的语法结构，不是逗号运算符
for (int i = 0, j = 10; i < j; i++, j--) {
    print(i + j);
}
```

*   **宏/代码块**：如果需要顺序执行多个语句并返回最后一个值，请使用代码块表达式（Block Expression，如果支持）或分号。

```cpp
// C 风格 (逗号表达式)
// int x = (foo(), bar()); 

// C^ 风格
foo();
int x = bar();
```

## 6. 内存布局与 ABI

元组在内存中遵循 C 结构体的对齐规则。

*   `(int, int)` 布局等同于 `struct { int f0; int f1; }`。
*   支持按值传递和按引用传递。

```cpp
// 高效传递：使用不可变引用
func process((int, int)!& point) {
    print(point.0);
}
```
