# C^ 运算符优先级与结合性 (Operator Precedence & Associativity)

本文档定义了 C^ 语言中所有运算符的优先级和结合性规则。

## 1. 设计原则

1.  **后缀优先 (Suffix First)**：为了支持流畅的链式调用，所有后缀运算符（包括成员访问 `.`、调用 `()`、后缀解引用 `^`、移动 `~`）必须拥有最高优先级。
2.  **数学直觉 (Mathematical Intuition)**：幂运算 `**` 高于乘除，且为右结合。
3.  **理性修正 (Rational Fixes)**：修复 C/C++ 中历史上反直觉的位运算优先级问题（如 `&` 低于 `==` 的陷阱）。

## 2. 优先级表 (Precedence Table)

优先级从高到低排列。同一行中的运算符优先级相同。

| 优先级 | 运算符                 | 说明                                           | 结合性     |
| :----- | :--------------------- | :--------------------------------------------- | :--------- |
| **0**  | `@`                    | **静态反射** (前缀)，优先级高于成员访问        | 右到左     |
| **1**  | `()` `[]` `.` `->`     | 函数调用、数组索引、成员访问、**指针成员访问** | 左到右     |
|        | `^` `~` `++` `--`      | **后缀操作符**：解引用、移动语义、后缀自增/减  | 左到右     |
|        | `!` (后缀)             | 显式非空断言 (可选特性)                        | 左到右     |
| **2**  | `**`                   | **幂运算** (标准库实现)                        | **右到左** |
| **3**  | `!` `+` `-` `++` `--`  | **前缀操作符**：逻辑非、正负号、前缀自增/减    | 右到左     |
|        | `~`                    | 按位取反 (前缀)                                | 右到左     |
|        | `^`                    | **取地址** (前缀)                              | 右到左     |
|        | `$`                    | **倒序索引** (前缀，如 `$1` 表示倒数第一)      | 右到左     |
|        | `sizeof` `typeof`      | 编译期操作符                                   | 右到左     |
|        | `new` `delete` `await` | 内存与协程操作                                 | 右到左     |
| **4**  | `*` `/` `%`            | 乘、除、取模                                   | 左到右     |
| **5**  | `+` `-`                | 加、减                                         | 左到右     |
| **6**  | `<<` `>>`              | 位移                                           | 左到右     |
| **7**  | `&`                    | **按位与** (注：优先级高于比较)                | 左到右     |
| **8**  | `^`                    | **按位异或**                                   | 左到右     |
| **9**  | `                      | `                                              | **按位或** | 左到右 |
| **10** | `<` `<=` `>` `>=`      | 关系比较                                       | 左到右     |
|        | `is` `as`              | 类型检查与转换                                 | 左到右     |
| **11** | `==` `!=`              | 相等性比较                                     | 左到右     |
| **12** | `&&`                   | 逻辑与                                         | 左到右     |
| **13** | `                      |                                                | `          | 逻辑或 | 左到右 |
| **14** | `..`                   | 范围操作符 (Range)                             | 左到右     |
| **15** | `?:`                   | 三元条件                                       | **右到左** |
| **16** | `=` `+=` `-=` `*=` ... | 赋值与复合赋值                                 | **右到左** |
| **17** | `=>`                   | Lambda/Match 箭头                              | 左到右     |

---

## 3. 关键设计解析


### 3.1 后缀 `^` 与成员访问

为了支持 C^ 特有的指针解引用语法，后缀 `^` 必须具有最高优先级（Level 1）。

*   **场景**：访问指针指向对象的成员。
*   **语法**：`ptr^.field`
*   **解析**：`(ptr^).field`
*   **对比 C++**：C^ 保留了 `->` 作为指针成员访问的语法糖，同时也支持正交的 `^.` 写法。

```cpp
struct Point { int x; int y; }
Point^ p = new Point(10, 20);

// C^ 推荐方式 (C++ 兼容)：
int val1 = p->x;

// 正交方式 (底层等价)：
int val2 = p^.x; 
// 解析顺序：(p^).x
```

### 3.2 幂运算符 `**`

C^ 引入 `**` 作为幂运算符，填补了 C 家族语言的空白。为了符合数学直觉，**其优先级高于前缀负号**。

*   **优先级**：`**` (Level 2) > `-` (Level 3)。
*   **右结合性**：`2 ** 3 ** 2` 等价于 `2 ** (3 ** 2)` = `2 ** 9` = 512。
*   **负号交互**：
    *   `-2 ** 2` 解析为 `-(2 ** 2) = -4` （符合 Python/Ruby 习惯，而非 Excel）。
    *   `2 ** -2` 解析为 `2 ** (-2) = 0.25` （右结合性自然吞噬了右侧的一元表达式）。

*   **实现**：语言本身不内置 `**` 的汇编实现，而是依赖标准库重载。
*   **示例**：
    ```cpp
    // 标准库 Math 模块
    func operator**(double base, double exp) -> double {
        return pow(base, exp);
    }
    
    // 使用
    double res = 2.0 ** 3.0 + 1.0; // 解析：(2.0 ** 3.0) + 1.0
    ```

### 3.3 位运算优先级修正 (Rational Bitwise Precedence)

C/C++ 的一个历史包袱是位运算 (`&` `|` `^`) 的优先级低于比较运算 (`==` `!=`)。
这导致 `if (flags & MASK == 0)` 被错误解析为 `if (flags & (MASK == 0))`。

**C^ 修正方案**：
将位运算优先级提升至关系比较 (`<` `>`) 之前。

*   **新行为**：`flags & MASK == 0` 解析为 `(flags & MASK) == 0`。
*   **理由**：符合直觉，减少括号噪音，消除常见 Bug。

## 4. 潜在争议与待定事项 (RFC)

### 4.1 范围操作符 `..` 的优先级

`..` 用于数组切片 `arr[0..5]` 或迭代器 `for (i in 0..10)`。

*   **当前设定**：优先级较低 (Level 14)，在逻辑运算之后，赋值之前。
*   **影响**：
    *   `0..10 + 1` 解析为 `0..(10 + 1)` 还是 `(0..10) + 1`？
    *   通常我们希望是前者。如果 `..` 优先级太高（如高于 `+`），则 `0..10+1` 变成 `(0..10) + 1`，这是无意义的。
    *   **结论**：`..` 必须低于算术运算。

### 4.2 移位运算 `<<` `>>`

目前将移位运算放在加减法之后 (Level 6)，这与 C++ 保持一致。
但在某些数学场景下，移位被视为乘除法的变体（`x << 1` 即 `x * 2`）。是否应该提高到乘除法级别？
*   **决策**：保持现状。因为移位常用于 IO流操作 (`cout << a + b`)，如果优先级太高，会破坏 `stream << (a+b)` 的习惯。

### 4.3 `as` 类型转换

`as` 的优先级设定为 Level 10（与比较运算同级，但通常结合性是从左到右，所以 `x as int < 10` 解析为 `(x as int) < 10`）。
这通常是安全的。

---

## 5. 总结

C^ 的运算符优先级表在保持 C++ 骨架的基础上，做了三个关键改进：
1.  **后缀绝对优先**：确保 `ptr^.field` 和 `obj~` 的流畅性。
2.  **位运算复位**：修复了 40 年前的历史错误，让位掩码操作符合直觉。
3.  **幂运算归位**：引入右结合的 `**`，完善数学表达。
