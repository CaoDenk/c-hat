# C^ 静态与生命周期设计 (Static & Storage Duration)

本文档阐述 C^ 语言中 `static` 关键字的语义、变量的存储期 (Storage Duration) 以及单例模式的最佳实践。

## 1. 核心理念

C^ 严格区分**值 (Value)**、**类型 (Type)** 和 **存储 (Storage)**。

*   **`const`**：定义**值**的属性（编译期常量）。
*   **`static`**：定义**存储**的属性（静态存储期）。
*   **`let`**：定义**绑定**的属性（运行时不可变）。

## 2. `static` 关键字语义

### 2.1 全局/模块作用域

在模块顶层定义的变量，默认具有模块内部可见性 (`internal`)。加上 `static` 关键字通常用于限制链接性（但在 C^ 中主要通过 `private`/`internal` 控制可见性，`static` 在顶层主要用于类成员）。

### 2.2 类静态成员

与 C++ / C# 类似，`static` 修饰的类成员属于类本身，而非类的实例。

```cpp
class Logger {
    // 静态字段：所有实例共享
    public static int log_level = 1;
    
    // 静态方法：通过类名调用
    public static func set_level(int level) {
        log_level = level;
    }
}
```

### 2.3 局部静态变量 (Local Static)

C^ **支持** 局部静态变量。这是实现单例模式和惰性初始化 (Lazy Initialization) 的基石。

*   **语义**：局部静态变量在**第一次**控制流经过其声明时初始化，并在程序结束时销毁。
*   **线程安全**：C^ 保证局部静态变量的初始化是**线程安全**的（Magic Statics）。编译器会自动插入锁或原子操作来保证这一点。
*   **生命周期**：从首次初始化开始，直到程序终止。

```cpp
func get_counter() -> int {
    // static 变量在函数调用之间保持状态
    // 仅在第一次调用时初始化为 0
    static int count = 0; 
    count++;
    return count;
}
```

## 3. `const` vs `static`

这是 C^ 与 C++ 的一个重要区别。C^ 避免了 C++ 中 `static constexpr` 带来的语义混淆。

### 3.1 局部 `const` (无 `static`)

局部定义的 `const` 仅仅是一个**命名的编译期字面量**。它**不**具备静态存储期，不占用数据段内存（除非取地址），编译器通常将其内联。

```cpp
func process() {
    // 这是一个常量值，不是静态变量
    // 每次调用函数，它只是一个字面量 8080
    const int PORT = 8080; 
    
    // ...
}
```

### 3.2 局部 `static const`

如果你既需要它是编译期常量，又需要它在内存中有唯一的静态地址（例如用于指针标识或减少栈拷贝），则需要显式组合关键字。

```cpp
func get_buffer() -> byte^ {
    // 这是一个静态存在的常量数组
    // 数据存储在只读数据段 (.rodata)
    static const byte[4] MAGIC = [ 0xCA, 0xFE, 0xBA, 0xBE ];
    
    return &MAGIC[0];
}
```

## 4. 单例模式 (Singleton Pattern)

得益于线程安全的局部静态变量，C^ 中实现单例模式非常优雅（Meyers' Singleton 风格）。

### 4.1 推荐实现 (优雅)

```cpp
class Database {
private:
    // 私有构造函数
    private Database() {
        print("Database initialized");
    }

public:
    // 删除拷贝构造和赋值
    delete Database(const Database&);
    delete func operator=(const Database&);

    // 获取实例的静态方法
    public static func instance() -> Database& {
        // 局部静态变量：
        // 1. 延迟初始化 (Lazy)：直到第一次调用 instance() 才创建
        // 2. 线程安全：多线程同时调用也只会初始化一次
        // 3. 自动销毁：程序退出时析构
        static Database db; 
        return db;
    }
    
    public func query(string sql) {
        // ...
    }
}

// 使用
func main() {
    Database.instance().query("SELECT * FROM users");
}
```

### 4.2 为什么这样设计？

1.  **简洁**：不需要手动检查 `if (instance == null)`。
2.  **安全**：避免了 Double-Checked Locking (DCLP) 的复杂性和潜在的内存模型 bug。
3.  **确定性**：利用栈/静态存储区的自动生命周期管理。

## 5. 总结

| 声明方式 | 存储期 (Storage) | 值特性 (Value) | 典型用途 |
| :--- | :--- | :--- | :--- |
| `const int X = 1;` | 无 (编译器内联) | 编译期常量 | 魔法数字、配置常量 |
| `static int X = 1;` | 静态 (Static) | 运行时可变 | 计数器、缓存、单例 |
| `static const int X = 1;` | 静态 (Static) | 编译期常量 | 需要地址的常量表 |
| `let int x = 1;` | 自动 (Stack) | 运行时不可变 | 函数内的临时不可变绑定 |
| `var int x = 1;` | 自动 (Stack) | 运行时可变 | 普通变量 |
