这一路走来，我们共同勾勒出了一门既有 C++ 的力量，又有现代工程学的理性的硬核语言——**C^ (C-Hat)**。它拒绝了垃圾回收（GC）和重型运行时（Runtime），追求极致的**零成本抽象**。

以下是 **C^ 核心语法蓝图**的完整总结：

---

### 1. 变量与基本声明 (Variables & Declarations)

C^ 坚持**类型前置**的传统，强调代码的静态可读性。基础类型系统经过精心设计，严格区分字节与字符。

*   **基础类型**：
    *   **整数**：`byte`/`sbyte` (8位), `short`/`ushort` (16位), `int`/`uint` (32位), `long`/`ulong` (64位)。
    *   **字符**：`char` (32位 Unicode 码点)。
    *   **浮点**：`float`, `double`, `fp16` (半精度), `bf16` (Brain Float)。
    *   **布尔**：`bool`。
*   **字符串**：`string` 和 `string_view` (标准库类型，UTF-8)。
*   **显式声明**：`Type variable_name`。
*   **类型推导**：`var` (可变) / `let` (不可变)。

```cpp
// 基础变量声明
int counter = 0;
byte mask = 0xFF;
char ch = '中'; // 32位 Unicode 字符

// 类型推导
var total = 100;     // int, 可变
let limit = 50;      // int, 不可变
// limit = 60;       // 编译错误

// 字符串 (标准库类型)
string name = "C-Hat"; // 字面量是 literal_view，隐式转换为 string

// 常量
const int MAX_RETRIES = 3;
```

---

### 2. 函数 (Functions)

函数是逻辑的核心。C^ 使用 `func` 关键字，既消除了 C++ 函数声明解析的歧义（Most Vexing Parse），又保持了定义的优雅。

*   **关键字**：统一使用 `func`。
*   **参数**：`Type name` 格式，与变量声明一致。
*   **返回值**：使用 `-> Type` 后置语法，支持元组多返回值。
*   **简写**：单表达式函数可使用 `=>`。

```cpp
// 标准函数定义
func calculate_area(int width, int height) -> int {
    if (width < 0 || height < 0) {
        return 0;
    }
    return width * height;
}

// 单表达式函数 (Lambda-like syntax)
func add(int a, int b) -> int => a + b;

// 多返回值
func get_status() -> (int, string) {
    return (200, "OK");
}

// 调用
int w = 10;
int h = 20;
int area = calculate_area(w, h);
(int code, string msg) = get_status();
```

---

### 3. 控制流 (Control Flow)

C^ 的控制流旨在消除 C/C++ 中的常见陷阱（如悬挂 else、switch 穿透），提供更理性的分支处理。

*   **强制大括号**：`if`、`for`、`while` 必须使用 `{}`，拒绝单行陷阱。
*   **Match 表达式**：取代 `switch`，支持模式匹配，强制穷举，无隐式 Fallthrough。

```cpp
// 条件语句 (必须带大括号)
if (x > 0) {
    print("Positive");
} else if (x < 0) {
    print("Negative");
} else {
    print("Zero");
}

// Match 表达式 (优雅且安全)
string status_text = match (code) {
    200 => "OK",
    404 => "Not Found",
    500, 502 => "Server Error", // 多个匹配
    _   => "Unknown"            // 默认分支 (必选)
};

// 循环
for (int i = 0; i < 10; i++) {
    // ...
}

while (running) {
    // ...
}
```

---

### 4. 数组与切片 (Arrays & Slices)

C^ 区分**存储**与**视图**，彻底解决 C 语言数组退化为指针的安全性问题。

*   **固定数组**：`Type[N]`，栈上分配，大小固定，零开销。
*   **栈数组推导**：`Type[$]`，栈上分配，大小由初始化器推导 (e.g. `int[$] arr = [1,2]`)。
*   **切片 (Slice)**：`Type[]`，动态视图（指针 + 长度），带边界检查。

```cpp
// 栈上固定数组
int[5] arr1 = [1, 2, 3, 4, 5];

// 栈数组推导 (等价于 int[3])
int[$] arr2 = [1, 2, 3]; 

// 切片 (Slice) - 默认行为
// s 指向 .rodata，不发生拷贝
var s = "hello"; // 类型为 byte![]

// 强制栈分配
// s_stack 在栈上分配 5 字节，并从 .rodata 拷贝 "hello"
// 注意：除非需要修改内容，否则不建议这样写，会有拷贝开销
byte[$] s_stack = "hello"; 
```
func sum_array(int[] arr) -> int {
    int sum = 0;
    // for 循环自动处理切片边界
    for (int x : arr) {
        sum += x;
    }
    return sum;
}

// 传递数组的切片视图
int total = sum_array(numbers[0..3]); // 传递前3个元素
```

---

### 5. 指针与内存安全 (Pointers & Memory)

C^ 不掩盖内存的本质，但提供了强大的工具来管理风险。我们保留了指针，但对其进行了**理性约束**。

*   **裸指针**：`Type^`，明确区分于乘法符号 `*`。
*   **空安全**：`Type?^` 表示可空指针，非空指针 `Type^` 永远不为 null。
*   **取地址与解引用**：`^` 取地址（前缀），`^` 解引用（后缀）。

```cpp
int value = 42;
int^ ptr = ^value; // 前缀 ^ 取地址
ptr^ = 100;        // 后缀 ^ 解引用

// 可空指针
int?^ safe_ptr = null;

// safe_ptr^ = 5; // 编译错误！必须先检查 null

if (safe_ptr != null) {
    safe_ptr^ = 5; // 编译器流分析：此处安全
}

// 堆内存分配
// new 返回 Type^ (或智能指针，视上下文而定)
Player^ player = new Player(); // 自动调用构造 Player()
delete player; // 自动调用析构 ~
```

---

### 6. 类与面向对象

*   **一等公民函数**：摒弃了 Java/C# 的强行类包裹。

```cpp
public class Player {
    private int _health;
    
    // 属性 (Property)
    public get health =>_health;
    public set health(value) {
        self._health = value > 100 ? 100 : value;
    }

    // 成员函数
    public func take_damage(int amount) {
        self._health -= amount;
    }
}
```

---

### 7. 符号与关键字速查表

| 符号/关键字    | 含义                                         |
| -------------- | -------------------------------------------- |
| **`func`**     | 函数声明关键字                               |
| **`^`**        | 裸指针类型后缀/操作符，如 `int^`, `^x`, `p^` |
| **`$`**        | 倒序索引前缀，如 `$1` (倒数第一)             |
| **^**          | 指针（默认非空），如 `int^`                  |
| **`match`**    | 模式匹配，替代 switch                        |
| **`self`**     | 显式实例参数                                 |
| **`where`**    | 泛型约束子句                                 |
| **`requires`** | 泛型结构性约束 (Concept 风格)                |
| **`concept`**  | 约束命名 (编译期)                            |
| **`late`**     | 预留内存但不构造，等待 RVO 或赋值            |
| **`~`**        | 移动语义 (后缀)，如 `obj~`                   |
| **`!`**        | 后缀: 不可变修饰符 (类型/绑定)               |

```
`func`, `class`, `struct`, `enum`, `union`, `namespace`, `import`, `export`, `public`, `private`, `protected`, `static`, `const`, `let`, `var`, `new`, `delete`, `self`, `base`, `where`, `requires`, `concept`, `override`, `final`, `abstract`, `extends`, `using`, `try`, `catch`, `throw`, `defer`, `late`, `extern`, `match`, `await`, `yield`
```

---

### 8. 泛型系统

*   **编译期展开**：对标 C++ Template，为每个类型生成特定机器码，零运行时开销。
*   **约束**：`where Concept<T>`。

```cpp
public class Box<T> {
    T value;
    public func get(self!) -> T => self.value;
}
```

---

### 9. 延迟初始化 (Lazy Initialization)

`late` 是 C^ 的核心优化特性，用于在不确定是否初始化的情况下预留栈空间，解决异常安全和条件初始化难题。

*   **栈上预留**：`late T var;` 在栈帧上分配 `sizeof(T)` 空间，但不调用构造函数。
*   **RVO 配合**：在 `try-catch` 或条件分支中赋值时，触发 RVO（返回值优化），直接在预留空间构造，避免临时对象拷贝。
*   **状态追踪**：编译器会追踪 `late` 变量的初始化状态。

```cpp
public func process_data() {
    late DatabaseConnection db; // 仅分配内存，不连接
    
    try {
        // 在 try 块内初始化
        db = connect_to_db("localhost")~; 
        // 此时 db 已构造，可以直接使用
        db.query("SELECT * FROM users");
    } catch (NetworkError! e) {
        // 若初始化失败，db 仍处于未构造状态，析构函数不会被调用
        print("Connection failed");
        return;
    }
    
    // 出了 try 块，db 依然有效（如果在 try 中成功初始化）
    // 编译器确保此时 db 是已初始化的，或者是不可达的
}
```

---

### 10. 静态反射与元编程 (Static Reflection)

C^ 提供强大的编译期反射能力，完全零运行时开销，特别适合序列化、ORM 和高性能通用代码。

*   **`@typeof(T)`**：获取类型的元数据对象。
*   **`comptime`**：编译期常量和控制流标记（取代 constexpr）。
*   **`[Attribute]`**：元数据注解。

```cpp
struct User {
    [JsonKey("user_id")]
    int id;
    string name;
}

// 通用 JSON 序列化函数
func to_json<T>(T! obj) -> string {
    string json = "{";
    bool first = true;
    
    // 编译期展开循环：对 T 的每个字段生成代码
    comptime for (var f : @typeof(T).fields) {
        if (!first) json += ", ";
        first = false;
        
        json += "\"" + f.name + "\": ";
        
        // 编译期多态：根据字段类型选择合适的转换
        if (f.type == string) {
            json += "\"" + obj.@field(f) + "\"";
        } else {
            json += to_string(obj.@field(f));
        }
    }
    
    json += "}";
    return json;
}

// 使用
User u = {1, "Alice"};
print(to_json(u)); 
```

---

### C^ 的核心哲学：**信任程序员，但提供理性的工具。**

我们保留了 C 的底层控制力（指针、内存布局），引入了现代语言的严谨（空安全、切片、Match），最终构建了一个既能写操作系统，又能写高层业务的**全栈硬核语言**。
