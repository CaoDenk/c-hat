# C^ 变参泛型设计 (Variadic Generics)

C^ 的变参泛型（Variadic Generics）旨在解决 C++ 变参模板的**可读性痛点**（尤其是递归展开的晦涩），同时保留其**零开销**特性。

## 1. 核心理念

*   **拒绝递归**：不推荐使用 C++ 传统的递归模板特化来处理变参。
*   **编译期迭代**：通过 `comptime for` 将参数包视为编译期常量数组进行遍历。
*   **统一语法**：使用 `...`（Ellipsis）作为包（Pack）的唯一标识符。

## 2. 基础语法

### 2.1 声明参数包
使用 `T...` 表示类型包，使用 `args...` 表示值包。

```cpp
// T... 是类型包 (Type Pack)
// args 是值包 (Value Pack)
public func print_all<T...>(T... args) {
    // ...
}
```

### 2.2 参数包展开 (Expansion)

C^ 提供了三种展开方式，按推荐程度排序：

#### 方式一：编译期循环 (Comptime Loop) —— **最推荐**
这是 C^ 处理变参最优雅的方式。编译器会将循环展开为顺序执行的代码序列。

```cpp
public func print_lines<T...>(T... args) {
    // 语法：comptime for (var 元素名 : 包名)
    comptime for (var arg : args) {
        // 在每次迭代中，arg 是具体的强类型
        print(arg); 
    }
}
```

*编译器展开结果（假设调用 `print_lines(1, "a")`）：*
```cpp
{
    var arg_0 = 1;
    print(arg_0);
    var arg_1 = "a";
    print(arg_1);
}
```

#### 方式二：折叠表达式 (Fold Expressions) —— *为了兼容性*
用于简单的二元运算聚合，语法参考 C++17。

```cpp
public func sum<T...>(T... args) -> double {
    // 左折叠：( ... op pack )
    // 右折叠：( pack op ... )
    return (args + ...); 
}
```

*评价：* 折叠表达式虽然简洁，但语法较为隐晦（cryptic），特别是涉及复杂逻辑时（如 C++ 中的逗号运算符 hack `(func(args), ...)`）。C^ 保留此特性仅为了简单数学计算的便利，**不推荐**用于复杂逻辑。

#### 方式三：编译期包方法 (Pack Methods) —— *更优雅的替代方案*
为了解决折叠表达式的可读性问题，C^ 将参数包视为一种编译期集合，支持函数式方法的链式调用。这比 `(args + ...)` 更具自解释性。

```cpp
public func all_true<T...>(T... args) -> bool {
    // 替代 (args && ...)
    return args.reduce((a, b) => a && b);
}

public func join_strings<T...>(T... args) -> string {
    // 编译期展开为链式调用
    return args.map(x => x.to_string())
               .reduce((a, b) => a + ", " + b);
}
```

#### 方式四：扩展操作符 (Spread Operator)
将包展开为参数列表，传递给其他函数。

```cpp
public func log<T...>(string fmt, T... args) {
    // args... 展开为 arg0, arg1, arg2, ...
    printf(fmt, args...); 
}
```

## 3. 高级特性

### 3.1 索引访问
参数包支持编译期常量索引访问。

```cpp
public func first<T...>(T... args) -> T[0] {
    static_assert(args.count > 0, "Empty pack");
    return args[0]; // 编译期确定类型
}
```

### 3.2 包的大小
使用 `.count` 获取包内元素数量（编译期常量）。

```cpp
if (args.count == 0) { return; }
```

### 3.3 类型包迭代
除了值包，类型包 `T...` 也可以直接迭代，用于元编程。

```cpp
public struct Tuple<T...> {
    // 编译期生成字段
    // 这是一个概念演示，实际 Tuple 可能由编译器内置支持
    comptime {
        int i = 0;
        for (type Type : T) {
             // 生成字段 field_0, field_1...
             emit_field(Type, $"field_{i}");
             i++;
        }
    }
}
```

### 3.4 异构变参 (Heterogeneous Variadics)
结合 `comptime for` 和 `any` 或 `interface`，可以处理异构逻辑。

```cpp
public func serialize<T...>(T... args) -> string {
    StringBuilder sb = new StringBuilder();
    comptime for (var arg : args) {
        sb.append(arg.to_string());
        sb.append(", ");
    }
    return sb.to_string();
}
```

## 4. 与 C++ 的对比

| 特性     | C++ (Pre-C++17)                           | C++ (C++17/20)                         | C^ (C-Hat)                    |
| :------- | :---------------------------------------- | :------------------------------------- | :---------------------------- |
| **定义** | `typename... T`                           | `typename... T`                        | `T...`                        |
| **遍历** | 递归模板特化 (Base case + Recursive case) | Fold Expressions / `if constexpr` 递归 | **`comptime for`** (直观循环) |
| **展开** | `func(args...)`                           | `func(args...)`                        | `func(args...)`               |
| **聚合** | 递归                                      | `(args + ...)`                         | `(args + ...)`                |
| **索引** | `std::get<I>(tuple)`                      | `std::get<I>`                          | `args[I]`                     |

## 5. 设计总结

C^ 的变参设计核心是 **"像写普通数组一样处理变参"**。
通过 `comptime for`，开发者不需要大脑“模拟递归栈”，代码阅读顺序就是执行顺序。这是 C^ 认为最优雅的设计方向。
