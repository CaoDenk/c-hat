# C^ 指针设计文档

## 1. 指针基础

C^ 中的指针设计采用了**后缀 `^` 解引用**的对称美学，消除了 C++ 中 `*` 符号的多义性，提供了更清晰、更直观的指针操作方式。

### 1.1 裸指针

* **语法**：使用 `^` 符号表示裸指针
* **声明**：`type^ ptr;`
* **初始化**：可以用 `null` 或地址初始化
* **解引用**：使用后缀 `^` 运算符
* **取地址**：使用前缀 `^` 运算符（例如 `^var`）

```cpp
// 声明裸指针
int^ ptr = null;

// 取地址（前缀 ^）
int x = 42;
ptr = ^x;

// 解引用（后缀 ^）
ptr^ = 100;

// 堆分配
int^ heap_ptr = new int(50);
// 手动释放
delete heap_ptr;
```

### 1.2 指针符号统一

C^ 将指针相关操作全部归一化到 `^` 符号：

* **前缀 `^`**：取地址 (Address-of)，例如 `^x`。
* **后缀 `^`**：解引用 (Dereference)，例如 `p^`。
* **类型后缀 `^`**：声明指针类型，例如 `int^`。

```cpp
func test() {
    int a = 100;
    int^ p = ^a;  // 获取 a 的地址
    
    p^ = 200;     // 解引用赋值，等同于 C++ 的 *p = 200
    
    int b = p^;   // 获取值，等同于 C++ 的 int b = *p
}
```

### 1.3 可空指针 (Nullable Pointers)

C^ 移除了专门的指针可空语法 (`?^`)，统一使用标准库的 `Optional<T>` 来表达可空语义。

* **语法**：`Optional<T^>`
* **语义**：显式表达“可能为空”的指针，强制进行非空检查
* **安全**：非空指针 `T^` 永远不能为 `null`，消除了空指针解引用的风险

```cpp
// 1. 非空指针 (默认)
// int^ ptr = null; // Error: cannot assign null to non-nullable pointer
int^ ptr = new int(42);
ptr^ = 100; // 安全，无需检查

// 2. 可空指针 (使用 Optional)
Optional<int^> opt_ptr = null;

// 必须检查才能使用
if (opt_ptr) {
    // value() 返回 int^，然后解引用
    opt_ptr.value()^ = 42;
}

// 或者使用 match
match (opt_ptr) {
    case Some(p) => p^ = 42,
    case None => print("Pointer is null"),
}
```

## 2. 后缀 `^` 的优势

### 2.1 符合思维流

* **从左到右**：先看到变量名，再决定要进入它的地址
* **直观易懂**：符合大脑从左到右的阅读习惯

```cpp
// C++：需要从右向左理解
int* p = &x;
*p = 100;

// C^：
int^ p = ^x;
p^ = 100;
```

### 2.2 避免歧义

* **消除多义性**：`^` 专门用于指针操作，不与乘号混淆
* **清晰明确**：一眼就能看出是指针操作

### 2.3 链式调用：`->` 回归

为了保持与 C++ 的习惯一致，C^ **保留并推荐**使用 `->` 操作符来访问指针成员。
当然，由于后缀 `^` 的高优先级，`ptr^.field` 也是合法的，且语义完全等价。

```cpp
class User {
public:
    string name;
    int age;
};

func main() {
    User^ user = new User();
    
    // 推荐方式：使用 -> (Arrow Operator)
    user->name = "Alice";
    user->age = 30;
    
    // 正交方式：显式解引用 (底层原理)
    user^.name = "Bob";
}
```

### 2.4 连续解引用

对于多级指针，后缀表达式读起来像流水线一样自然：

```cpp
int^^^ ppp;

// C++: ***ppp = 1; （从右向左看）
// C^: ppp^^^ = 1; （从左到右，逐层钻取）
ppp^^^ = 1;

// 多级指针赋值
int a = 10;
int^ p1 = ^a;
int^^ p2 = ^p1;
int^^^ p3 = ^p2;

// 逐层解引用
int value = p3^^^; // 结果为 10
```

## 3. 智能指针 (Standard Library Smart Pointers)

**注意：智能指针是 C^ 标准库 (`std`) 提供的功能，而非语言内置的核心语法。** 编译器对智能指针没有任何特殊待遇（除了可能的 RVO 优化），它们完全是用 C^ 语言编写的普通模板类。

C^ 标准库提供了三种智能指针，用于自动管理内存生命周期，完全遵循 RAII 原则。

### 3.1 unique_ptr

* **独占所有权**：同一时间只能有一个 unique_ptr 指向对象
* **自动释放**：离开作用域时自动释放内存
* **移动语义**：可以通过 `~` 转移所有权

```cpp
// 创建 unique_ptr
unique_ptr<int> uptr = new int(42);

// 转移所有权
unique_ptr<int> uptr2 = ~uptr;
// 此时 uptr 为 nullptr

// 自动释放，无需手动 delete
```

### 3.2 shared_ptr

* **共享所有权**：多个 shared_ptr 可以指向同一个对象
* **引用计数**：自动跟踪引用次数，当引用计数为 0 时释放内存

```cpp
// 创建 shared_ptr
shared_ptr<int> sptr = new int(42);

// 共享所有权
shared_ptr<int> sptr2 = sptr;
// 此时引用计数为 2

// 自动释放，当最后一个 shared_ptr 离开作用域时
```

### 3.3 weak_ptr

* **弱引用**：不增加引用计数
* **解决循环引用**：用于打破 shared_ptr 之间的循环引用

```cpp
// 创建 weak_ptr
weak_ptr<int> wptr = sptr;

// 检查是否有效
if (!wptr.expired()) {
    shared_ptr<int> sptr3 = wptr.lock();
    // 使用 sptr3
}
```

## 4. 指针算术

C^ 支持与 C/C++ 相同的指针算术操作。

### 4.1 基本算术

* **加法**：`ptr + n` 移动 n 个元素
* **减法**：`ptr - n` 移动 -n 个元素
* **比较**：`ptr1 == ptr2`、`ptr1 != ptr2`、`ptr1 < ptr2` 等

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int^ ptr = ^arr;

// 指针算术
ptr++;
// 此时 ptr 指向 arr[1]

int^ end = ^arr + 5;
// 遍历数组
for (int^ p = ^arr; p < end; p++) {
    printf("%d ", p^);
}
```

### 4.2 数组与指针

* **数组名**：数组名可以隐式转换为指向第一个元素的指针
* **下标操作**：`arr[i]` 等价于 `*(arr + i)`

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int^ ptr = ^arr; // 等价于 &arr[0]

// 下标操作
int x = ptr[2]; // 等价于 *(ptr + 2)
```

## 5. 指针与函数

### 5.1 指针作为参数

* **传递地址**：可以通过指针修改函数外部的变量
* **避免拷贝**：对于大型对象，传递指针可以避免拷贝开销

```cpp
func increment(int^ ptr) {
    ptr^++;
}

func main() {
    int x = 42;
    increment(^x);
    // 此时 x 为 43
}
```

### 5.2 函数指针

* **语法**：`ret_type (^func_ptr)(param_types);`
* **用途**：回调函数、函数表等

```cpp
func add(int a, int b) -> int {
    return a + b;
}

func main() {
    int (^func_ptr)(int, int) = ^add;
    int result = func_ptr(1, 2);
    // 结果为 3
}
```

## 6. 指针与对象

### 6.1 对象指针

* **成员访问**：使用 `->` 访问对象成员（推荐）或 `^.member`
* **多态**：通过基类指针调用派生类方法

```cpp
class Base {
public:
    virtual func print() {
        printf("Base\n");
    }
};

class Derived : public Base {
public:
    override func print() {
        printf("Derived\n");
    }
};

func main() {
    Base^ ptr = new Derived();
    ptr->print(); // 调用 Derived::print()
    delete ptr;
}
```

### 6.2 self 关键字

* **当前实例**：成员函数中可以使用 `self` 访问当前对象
* **取地址**：使用 `^self` 获取当前对象的指针

```cpp
class Person {
private:
    string _name;
public:
    func set_name(self&, string name) -> Person^ {
        self._name = name;
        return ^self;
    }
};
```

## 7. 指针安全

### 7.1 空指针检查

* **编译器警告**：对可能的空指针解引用进行警告
* **运行时检查**：可以选择启用运行时空指针检查

### 7.2 悬垂指针

* **Use-After-Free**：编译器会对可能的悬垂指针使用进行警告
* **内存安全**：建议使用智能指针避免悬垂指针

### 7.3 指针转换

* **静态转换**：`static_cast<type^>(ptr)`，编译期检查
* **动态转换**：`dynamic_cast<type^>(ptr)`，运行时检查，失败返回 nullptr
* **常量转换**：`const_cast<type^>(ptr)`，移除 const 修饰符
* **重新解释转换**：`reinterpret_cast<type^>(ptr)`，底层位转换

```cpp
Base^ base_ptr = new Derived();

// 动态转换
Derived^ derived_ptr = dynamic_cast<Derived^>(base_ptr);
if (derived_ptr != nullptr) {
    // 转换成功
}
```

## 8. 与 C/C++ 的互操作性

### 8.1 C 指针

* **直接兼容**：C^ 的裸指针与 C 指针二进制兼容
* **无缝调用**：可以直接传递指针给 C 函数

### 8.2 智能指针与 C 指针

* **获取裸指针**：使用 `.get()` 方法获取底层裸指针
* **创建智能指针**：可以从 C 指针创建智能指针

```cpp
// 从 C 指针创建智能指针
void* c_ptr = malloc(sizeof(int));
unique_ptr<int> uptr = reinterpret_cast<int^>(c_ptr);

// 获取裸指针传递给 C 函数
free(uptr.get());
```

## 9. 指针操作速查表

| 操作       | C++ 语法      | C^ 语法                             | 说明     |
| ---------- | ------------- | ----------------------------------- | -------- |
| 声明指针   | `int* p;`     | `int^ p;`                           | 后缀声明 |
| 取地址     | `&x`          | `^x`                                | 前缀 ^   |
| 解引用     | `*p`          | `p^`                                | 后缀 ^   |
| 成员访问   | `ptr->field`  | `ptr->field` (推荐) 或 `ptr^.field` | 兼容 C++ |
| 多级指针   | `int*** ppp;` | `int^^^ ppp;`                       | 后缀声明 |
| 连续解引用 | `***ppp`      | `ppp^^^`                            | 逐层钻取 |

## 10. 最佳实践

1. **优先使用智能指针**：避免内存泄漏和悬垂指针
2. **裸指针使用场景**：
   - 与 C 库交互
   - 性能关键路径
   - 明确的内存管理需求
3. **避免指针算术**：优先使用迭代器或范围 for 循环
4. **空指针检查**：始终在解引用前检查指针是否为空
5. **类型安全**：避免不必要的指针类型转换
6. **显式意图**：推荐使用 `->` 访问成员，一眼识别指针操作
7. **利用对称性**：理解 `^` 在不同语境下的对称含义

## 11. 所有权与生命周期 (Ownership & Lifecycle)

在 C^ 中，**裸指针 (`Type^`) 不持有所有权**。这意味着 `delete` 裸指针是一个需要极度谨慎的行为。

### 11.1 为什么裸指针不能区分数组？

正如数组设计文档中所述，裸指针仅仅是一个内存地址。它不包含任何关于“这块内存是如何分配的”元数据。

*   **设计权衡**：如果让裸指针在运行时能区分自己是否指向数组，就需要为每个指针增加 8-16 字节的元数据（或使用全局哈希表），这违反了 C^ 的**零成本抽象**原则。
*   **编译器行为**：`delete ptr` 在编译期会被翻译为：
    1.  调用 `ptr` 指向类型的**单个**析构函数。
    2.  调用底层的 `free(ptr)`。

### 11.2 释放风险对照表

| 分配方式   | 持有类型      | 推荐释放方式   | 备注                               |
| :--------- | :------------ | :------------- | :--------------------------------- |
| `new T`    | `T^`          | `delete ptr`   | 释放单个对象                       |
| `new T[N]` | `T[]` (切片)  | `delete slice` | **推荐**。类型安全。               |
| `new T[N]` | `T^` (裸指针) | `delete[] ptr` | **C++ 模式**。编译器读取头部长度。 |
| `new T[N]` | `T^`          | `delete ptr`   | **错误**。仅析构第一个元素。       |

### 11.3 最佳实践建议

1.  **优先使用切片**：尽量让 `new[]` 返回 `Type[]`，并使用 `delete slice`。
2.  **裸指针必配 delete[]**：如果必须持有数组的裸指针，务必使用 `delete[]`。
3.  **禁止混合**：不要对数组指针使用 `delete`，也不要对对象指针使用 `delete[]`。

C^ 的设计哲学是：**提供安全的默认路径（切片），但也保留底层的逃生舱（裸指针 + delete[]）。**