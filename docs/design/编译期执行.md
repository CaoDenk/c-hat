# C^ 编译期执行设计 (Compile-Time Execution)

C^ 引入 `comptime` 关键字，赋予开发者在编译期间执行任意代码的能力。这一机制统一了宏、模板元编程和预处理器指令，提供了一种类型安全、语法一致的元编程体验。

## 1. 核心概念

*   **编译期 (Compile-Time)**：代码在编译器编译源代码时执行。
*   **运行时 (Run-Time)**：代码在程序编译完成后，被用户执行时运行。
*   **`comptime`**：一个关键字，用于标记代码块、表达式或控制流语句在编译期求值。

## 2. 基础语法

### 2.1 `const`：定义编译期常量
在 C^ 中，`const` 仅代表**值**在编译期已知。

```cpp
// 编译期常量 (Immutable)
public const PI = 3.14159;
public const MAX_USERS = 100;

func foo() {
    // 这是一个命名的字面量，不占用静态存储区
    // 编译器会将其内联到使用处
    const int PORT = 80; 
    
    // 如果需要静态存储期 (单例模式/跨调用持久化)，必须显式加上 static
    // static const int CACHED_PORT = 80;
}
```

### 2.2 `comptime`：编译期执行逻辑

`comptime` 关键字并不定义“常量”，而是定义“编译期执行的作用域”。在 `comptime` 代码块内部，你可以使用**可变的局部变量**来辅助计算，但最终产生的**结果**通常会赋值给一个 `const` 常量。

#### 2.2.1 `comptime` 块与局部变量

`comptime` 块内的变量仅在编译期存在。为了支持循环和复杂逻辑，这些**局部变量**是可变的。

```cpp
// 使用 comptime 块计算常量
public const FACT_5 = comptime {
    var result = 1; // 这是一个编译期局部变量，必须是可变的 (var)
    for (int i = 1; i <= 5; i++) {
        result *= i; // 允许修改编译期局部变量
    }
    return result; // 返回计算结果
};

// FACT_5 在运行时是不可变的常量 (120)
```

#### 2.2.2 `comptime` 修饰变量 (不推荐)

虽然允许 `comptime var x = ...`，但这容易产生混淆。我们**强烈推荐**将 `comptime` 逻辑封装在代码块中，并将结果赋值给 `const`。

```cpp
// 不推荐的写法：容易混淆 x 是常量还是变量
// comptime var x = 10; 

// 推荐写法：明确 x 是一个常量，其值由编译期逻辑生成
const int x = comptime { 
    return 10 * 20; 
};
```

## 3. 编译期控制流

C^ 允许将标准的控制流语句标记为 `comptime`，使其在编译期执行（元编程）。

### 3.1 `comptime if` (Static If)

相当于 C++ 的 `if constexpr` 或预处理器的 `#ifdef`。条件必须是编译期常量。编译器只会编译条件为真的分支，另一个分支的代码甚至不需要是合法的（只要语法正确，类型检查会被跳过）。

```cpp
func foo<T>(T! value) {
    comptime if (sizeof(T) > 8) {
        // 仅当 T 大于 8 字节时编译此分支
        print("Large type");
        // 假设 large_process() 仅对大类型定义
        value.large_process(); 
    } else {
        // 否则编译此分支
        print("Small type");
    }
}
```

### 3.2 `comptime for` (Static For)

用于遍历编译期集合（如泛型参数包、反射字段列表、枚举成员）。编译器会将循环**展开 (Unroll)** 为一系列顺序语句。

```cpp
func print_fields<T>(T! obj) {
    // 遍历类型的字段 (反射)
    // 编译器会将此循环展开为多条 print 语句
    comptime for (var field : @T.fields) {
        print(field.name);
        print(obj.@[field]); // 编译期成员访问
    }
}
```

### 3.3 `comptime match`

在编译期进行模式匹配。通常用于基于类型的分发。

```cpp
func get_type_category<T>() -> string {
    return comptime match (@T) {
        case @int | @long => "Integer",
        case @float | @double => "Float",
        case _ => "Other"
    };
}
```

## 4. `comptime` vs `const`

这是一个关键的区别：

*   **`const` (常量)**：
    *   **不可变** (Immutable)。
    *   等价于 C++ 的 `constexpr` 或 C# 的 `const`。
    *   用于定义最终的、确定的常量值。

*   **`comptime` (编译期执行)**：
    *   **可变** (Mutable) 或 不可变。
    *   用于定义**编译期逻辑**和**中间状态**。
    *   如果你声明 `comptime int x`，它是编译期的一个变量，可以像普通变量一样被赋值修改，用于辅助计算。

```cpp
// 场景：计算阶乘

// 方法 A: 使用 const (递归/表达式)
const int FACT_5 = 120;

// 方法 B: 使用 comptime (命令式逻辑)
comptime int fact_val = 1;
comptime {
    for (int i = 1; i <= 5; i++) {
        fact_val *= i;
    }
}
// fact_val 最终为 120，可以赋值给 const
const int RESULT = fact_val;
```

## 5. 典型应用场景

### 5.1 平台无关代码 (跨平台编译)

替代 `#ifdef _WIN32`。

```cpp
func get_os_name() -> string {
    comptime if (Target.OS == "Windows") {
        return "Windows";
    } else comptime if (Target.OS == "Linux") {
        return "Linux";
    } else {
        return "Unknown";
    }
}
```

### 5.2 查找表生成 (Lookup Table Generation)

可以在编译期计算复杂的数学表（如正弦表、CRC 表），并将其作为 `static const` 数组嵌入二进制中，实现运行时零开销。

```cpp
// 编译期生成 0-359 度的正弦表
const double[360] SIN_TABLE = comptime {
    double[360] table;
    for (int i = 0; i < 360; i++) {
        table[i] = sin(i * 3.14159 / 180.0);
    }
    return table;
};

// 运行时直接查表
func fast_sin(int degree) -> double {
    return SIN_TABLE[degree % 360];
}
```

### 5.3 泛型特化与优化

根据泛型参数的特性，选择最优算法。

```cpp
func copy_data<T>(T[] src, T[] dest) {
    comptime if (@T.is_trivially_copyable) {
        // 如果是 POD 类型，直接 memcpy
        memcpy(dest, src, src.length * sizeof(T));
    } else {
        // 否则逐个拷贝
        for (int i = 0; i < src.length; i++) {
            dest[i] = src[i];
        }
    }
}
```

## 6. 限制与安全

*   **无副作用**：`comptime` 代码块通常不能进行文件 IO、网络请求等（除非编译器提供了特定的沙盒 API）。
*   **确定性**：`comptime` 执行结果必须是确定性的。
*   **死循环检测**：编译器通常会设置 `comptime` 执行的步数上限，防止编译死锁。
