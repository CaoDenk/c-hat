# C^ 模块系统设计文档

C^ 彻底摒弃了 C/C++ 的头文件包含机制 (`#include`)，采用了现代化的模块系统。设计目标是：**物理结构即逻辑结构**，**编译速度极快**，**依赖管理清晰**。

注：本文档仅规范**语言层面的模块机制**。关于包管理、依赖下载和构建配置，属于构建工具（如 CMake, Ninja, 或未来的 c-hat-build）的范畴，不属于语言规范。

## 1. 物理结构与文件扩展名

### 1.1 文件扩展名
推荐使用 **`.ch`** (C-Hat) 作为 C^ 源代码文件的扩展名。

*   **`.ch`**：C^ 源代码文件（包含声明与实现）。
*   **`.hh`**：自动生成的 C++ 兼容头文件（仅用于导出库给 C++ 使用，C^ 内部不使用）。

### 1.2 逻辑映射
C^ 建议采用 **目录即模块 (Directory is Module)** 的约定，但编译器支持灵活的映射配置。

```text
src/
├── main.ch       // 模块: main
├── utils/
│   ├── math.ch   // 模块: utils.math
│   └── string.ch // 模块: utils.string
└── net/
    └── http.ch   // 模块: net.http
```

### 1.3 模块命名与文件映射 (Module Naming & Mapping)

为了解决 `.` 符号在“模块层级”和“文件扩展名”之间的歧义，C^ 制定了严格的映射规则。

*   **规则 1：文件名不得包含 `.`**
    *   源文件名只能包含字母、数字、下划线。
    *   扩展名固定为 `.ch`。
    *   **非法**：`io.util.ch`
    *   **合法**：`io_util.ch` 或 `io/util.ch`

*   **规则 2：目录映射**
    *   模块路径 `std.io.file` 严格映射到目录结构。
    *   查找顺序：
        1.  `std/io/file.ch` (文件模块)
        2.  `std/io/file/mod.ch` (目录模块入口，类似 Rust `mod.rs` 或 Python `__init__.py`)

```cpp
import std.io;      // 加载 std/io.ch 或 std/io/mod.ch
import std.network; // 加载 std/network.ch
```

## 2. 模块声明与导入

### 2.1 模块声明 (Module Declaration)
每个 `.ch` 文件的第一行非注释代码必须是模块声明。

*   **隐式命名空间**：`module A.B;` 声明不仅定义了编译单元，还隐式地将文件内容包裹在命名空间 `A.B` 中。
*   **规则**：模块名是逻辑标识符，通常与目录结构对应。
*   **冲突避免**：C^ **移除**了显式的 `namespace` 关键字。模块声明是定义命名空间的唯一方式。这强制了物理结构与逻辑结构的一致性，从根本上消除了命名冲突和冗余嵌套。

```cpp
// src/utils/math.ch
module utils.math; 

// 此时符号 add 自动位于 utils.math.add
public func add(int a, int b) -> int => a + b;
```

#### 嵌套命名空间
由于移除了 `namespace` 关键字，如果需要进一步的逻辑隔离，推荐使用以下两种方式：
1.  **子模块**：创建子目录和新文件（例如 `utils/math/impl.ch` 对应 `module utils.math.impl`）。
2.  **静态结构体**：使用 `static struct` 作为逻辑容器。

```cpp
module utils.math;

// 使用静态结构体模拟嵌套命名空间
public static struct Complex {
    public struct Data { ... }
    public func create() { ... }
}
// 使用: utils.math.Complex.Data
```

### 2.2 导入 (Import)
使用 `import` 关键字引入其他模块。

*   **全量导入**：`import std.io;`
*   **别名导入**：`import std.network.http as http;`

```cpp
// src/main.hat
module main;

import std.io;       // 标准库
import utils.math;   // 用户模块

func main() {
    io.print("Hello");
    int sum = utils.math.add(1, 2);
}
```

### 2.3 符号查找机制
语言规范不硬编码查找路径。编译器应提供机制（如 `-I` 或 `--module-map`）来解析 `import A.B` 对应的物理文件。

### 2.4 多文件模块 (Multi-file Modules)

C^ 允许将一个逻辑模块拆分到多个物理文件中（Partial Modules）。这对于组织大型库（如标准库）非常关键。

*   **声明**：多个文件可以声明同一个模块名 `module A.B;`。
*   **合并**：编译器会将这些文件视为同一个逻辑单元。
*   **可见性**：
    *   **Internal** 符号：在同一个模块的所有文件中可见（无论是否在同一个目录）。
    *   **Private** 符号：仅在当前物理文件中可见。

```cpp
// 文件 1: src/math/core.ch
module utils.math; // 声明属于 utils.math 模块

public func add(int a, int b) => a + b;

// 文件 2: src/math/geom.ch
module utils.math; // 同属 utils.math 模块

public func distance(Point p1, Point p2) { ... }

// 这样 utils.math 模块就包含了 add 和 distance，且对用户来说是透明的
```

## 3. 设计决策：为什么移除 `namespace` 关键字？

我们认为 **Module-as-Namespace**（模块即命名空间）是比传统显式 `namespace` 更优秀的设计，理由如下：

1.  **消除“右移代码” (Reduce Rightward Drift)**：
    *   传统 C++/C#：`namespace A { namespace B { class C { ... } } }` 导致所有代码默认缩进 1-2 层。
    *   C^：`module A.B;` 声明在文件头，正文代码无额外缩进。

2.  **强制一致性 (Enforce Consistency)**：
    *   在 C++ 中，物理文件路径 (`src/utils/math.cpp`) 可以和逻辑命名空间 (`namespace core::math`) 完全不匹配，导致找代码困难。
    *   C^ 强制逻辑命名空间与物理模块路径映射，看到 `module utils.math` 就知道文件应该在 `utils/math.ch`，降低了认知负荷。

3.  **单一事实来源 (Single Source of Truth)**：
    *   `module` 声明同时定义了编译单元边界和符号作用域，避免了“模块名”和“命名空间名”两套体系的认知冲突。

4.  **现代语言趋势**：
    *   C# 10 引入了文件级命名空间 (`namespace Base;`) 来解决缩进问题。
    *   Go 和 Rust 均采用包/模块即命名空间的设计。
    *   C^ 选择一步到位，直接移除冗余的 `namespace` 关键字。

## 4. 可见性与导出 (Visibility & Export)

C^ 采用基于 **访问修饰符 (`public`)** 的隐式导出机制，而非显式的 `export` 语句。这种设计与 Java/C# 保持一致，减少了语法的冗余。

### 3.1 核心原则

*   **默认 (Internal)**：如果不加修饰符，顶层符号（类、函数、变量）默认为 `internal`，即仅在**当前模块/程序集**内可见。
*   **公开 (Public)**：使用 `public` 修饰的顶层符号，会自动被**导出**，对导入该模块的外部代码可见。
*   **私有 (Private)**：顶层符号可以使用 `private`，表示仅在**当前文件**内可见（文件作用域）。

### 3.2 为什么不用 `export` 关键字？

我们对比了两种设计方案：

1.  **显式导出 (`export func foo()`)**：类似 C++20 Modules 或 JS。优点是明确，缺点是对于库开发来说，几乎每个公开 API 都要写 `export`，导致代码中充斥着 `export` 关键字。
2.  **访问修饰符 (`public func foo()`)**：类似 C# / Java。优点是语义统一——`public` 在类成员中表示对外可见，在模块中也表示对外可见。

C^ 选择了 **方案 2**。因为在模块化编程中，"导出"本质上就是"公开访问权限"。将 Access Control 和 Export Mechanism 合并，概念更加简洁。

```cpp
// src/math.ch
module utils.math;

// 1. 导出符号 (Public)
// 外部代码 import utils.math 后可见
public func add(int a, int b) -> int => a + b;

// 2. 内部符号 (Internal - 默认)
// 仅 utils.math 模块内部可见，外部不可见
func helper() { ... }

// 3. 私有符号 (Private)
// 仅当前文件可见
private const int MAGIC = 42;
```

### 3.3 再导出 (Re-export)

为了支持灵活的库组织结构，C^ 支持通过 `public import` 将导入的符号重新导出。这允许库作者将内部实现拆分为多个小模块，同时提供一个统一的公共入口模块。

```cpp
// src/std/io.ch
module std.io;

// 1. 导入并重新导出
// 用户 import std.io 后，可以直接使用 File 和 Console，
// 而无需关心它们具体是在 impl/file.ch 还是 impl/console.ch 中定义的。
public import std.io.impl.file;
public import std.io.impl.console;

// 2. 带别名的重新导出
public import std.network.http as http;
```

#### 限制
*   **避免循环再导出**：编译器会检查并报告再导出链中的循环引用。
*   **歧义处理**：如果多个 re-export 引入了同名符号，必须在当前模块显式解决冲突（如定义别名或新的包装符号）。

## 5. 循环依赖 (Circular Dependencies)

C^ **允许** 同一个逻辑模块内的文件之间存在循环引用。
但 **禁止** 跨逻辑模块的循环依赖。

## 6. 与 C/C++ 的互操作 (Interop)

### 6.1 导出给 C/C++
使用 `extern "C"` 修饰符可导出 C ABI 符号。

```cpp
extern "C" public func my_api() { ... }
```

### 6.2 头文件生成策略
C^ 编译器 (`chc`) 支持从 `.ch` 源码自动生成头文件，用于分发闭源库或供其他语言调用。

*   **生成模式**：`chc --emit-header my_lib.ch`
*   **输出**：
    *   `my_lib.h`：仅包含 `extern "C"` 的 C 接口。
    *   `my_lib.hh`：包含 C++ 类映射（如果启用了 C++ Interop）。

在 C^ 开发过程中，开发者**不需要**手动编写或维护 `.hh` 文件。

## 7. 总结

C^ 的模块系统专注于定义**可见性边界**和**符号解析逻辑**，保持了构建系统的中立性，易于集成到现有的 C/C++ 工程设施中。
