# 内置类型组织设计

## 1. 设计目标

C^ 内置类型设计的目标是：
1. **清晰明确**：类型名称能够清晰表达其语义
2. **日常便捷**：提供简短类型别名，方便日常编码
3. **完整可访问**：开发者能够方便地访问类型的静态属性
4. **系统一致性**：与标准库和编译器实现保持一致

## 2. 命名体系

### 2.1 真实类型名（Canonical Names）

这些是类型的真实、完整名称，具有明确的语义：

| 真实类型名    | 位宽 | 语义             |
| ------------- | ---- | ---------------- |
| `Int8`        | 8    | 有符号 8 位整数  |
| `UInt8`       | 8    | 无符号 8 位整数  |
| `Int16`       | 16   | 有符号 16 位整数 |
| `UInt16`      | 16   | 无符号 16 位整数 |
| `Int32`       | 32   | 有符号 32 位整数 |
| `UInt32`      | 32   | 无符号 32 位整数 |
| `Int64`       | 64   | 有符号 64 位整数 |
| `UInt64`      | 64   | 无符号 64 位整数 |
| `Float32`     | 32   | 单精度浮点数     |
| `Float64`     | 64   | 双精度浮点数     |
| `Float16`     | 16   | 半精度浮点数     |
| `BFloat16`    | 16   | 脑浮点数         |
| `Boolean`     | 1    | 布尔值           |
| `Char`        | 32   | Unicode 字符     |
| `LiteralView` | 128  | 字面量视图       |

### 2.2 简短类型别名（Short Aliases）

这些是为了日常编码方便而提供的简短类型别名：

| 简短别名 | 真实类型   | 说明         |
| -------- | ---------- | ------------ |
| `sbyte`  | `Int8`     | 有符号字节   |
| `byte`   | `UInt8`    | 无符号字节   |
| `short`  | `Int16`    | 短整数       |
| `ushort` | `UInt16`   | 无符号短整数 |
| `int`    | `Int32`    | 默认整数     |
| `uint`   | `UInt32`   | 无符号整数   |
| `long`   | `Int64`    | 长整数       |
| `ulong`  | `UInt64`   | 无符号长整数 |
| `float`  | `Float32`  | 单精度浮点数 |
| `double` | `Float64`  | 默认浮点数   |
| `fp16`   | `Float16`  | 半精度浮点数 |
| `bf16`   | `BFloat16` | 脑浮点数     |
| `bool`   | `Boolean`  | 布尔值       |
| `char`   | `Char`     | 字符         |

## 3. 实现位置：std.core 核心模块

所有内置类型的声明都在 **`std.core`** 核心模块中，这样：
1. 开发者可以导入该模块查看完整类型信息
2. 编译器可以从这里获取类型的静态属性
3. 标准库可以统一引用这些类型

### 3.1 std.core 模块结构

```
std/
└── core.c^       - 核心模块，包含所有内置类型声明
```

### 3.2 std.core 实现示例

```cpp
// std/core.c^
// C^ 核心标准库模块
// 包含所有内置类型的声明

// ============================================
// 整数类型
// ============================================

/// 8 位有符号整数
public struct Int8 {
    static get max_value -> Int8 => 127;
    static get min_value -> Int8 => -128;
    static get bits -> long => 8;
    static get size -> long => 1;
    static get is_signed -> bool => true;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
}

public using sbyte = Int8;

/// 8 位无符号整数
public struct UInt8 {
    static get max_value -> UInt8 => 255;
    static get min_value -> UInt8 => 0;
    static get bits -> long => 8;
    static get size -> long => 1;
    static get is_signed -> bool => false;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
}

public using byte = UInt8;

/// 16 位有符号整数
public struct Int16 {
    static get max_value -> Int16 => 32767;
    static get min_value -> Int16 => -32768;
    static get bits -> long => 16;
    static get size -> long => 2;
    static get is_signed -> bool => true;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
}

public using short = Int16;

/// 16 位无符号整数
public struct UInt16 {
    static get max_value -> UInt16 => 65535;
    static get min_value -> UInt16 => 0;
    static get bits -> long => 16;
    static get size -> long => 2;
    static get is_signed -> bool => false;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
}

public using ushort = UInt16;

/// 32 位有符号整数（默认整数类型）
public struct Int32 {
    static get max_value -> Int32 => 2147483647;
    static get min_value -> Int32 => -2147483648;
    static get bits -> long => 32;
    static get size -> long => 4;
    static get is_signed -> bool => true;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
}

public using int = Int32;

/// 32 位无符号整数
public struct UInt32 {
    static get max_value -> UInt32 => 4294967295;
    static get min_value -> UInt32 => 0;
    static get bits -> long => 32;
    static get size -> long => 4;
    static get is_signed -> bool => false;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
}

public using uint = UInt32;

/// 64 位有符号整数
public struct Int64 {
    static get max_value -> Int64 => 9223372036854775807;
    static get min_value -> Int64 => -9223372036854775808;
    static get bits -> long => 64;
    static get size -> long => 8;
    static get is_signed -> bool => true;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
}

public using long = Int64;

/// 64 位无符号整数
public struct UInt64 {
    static get max_value -> UInt64 => 18446744073709551615;
    static get min_value -> UInt64 => 0;
    static get bits -> long => 64;
    static get size -> long => 8;
    static get is_signed -> bool => false;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
}

public using ulong = UInt64;

// ============================================
// 浮点类型
// ============================================

/// 16 位半精度浮点数
public struct Float16 {
    static get max_value -> Float16 => 65504.0h;
    static get min_value -> Float16 => 6.103515625e-5h;
    static get epsilon -> Float16 => 9.765625e-4h;
    static get bits -> long => 16;
    static get size -> long => 2;
    static get is_signed -> bool => true;
    static get is_integer -> bool => false;
    static get is_floating -> bool => true;
}

public using fp16 = Float16;

/// 16 位脑浮点数
public struct BFloat16 {
    static get max_value -> BFloat16 => 3.38953139e+38bf;
    static get min_value -> BFloat16 => 1.17549435e-38bf;
    static get epsilon -> BFloat16 => 7.8125e-3bf;
    static get bits -> long => 16;
    static get size -> long => 2;
    static get is_signed -> bool => true;
    static get is_integer -> bool => false;
    static get is_floating -> bool => true;
}

public using bf16 = BFloat16;

/// 32 位单精度浮点数
public struct Float32 {
    static get max_value -> Float32 => 3.40282347e+38f;
    static get min_value -> Float32 => 1.17549435e-38f;
    static get epsilon -> Float32 => 1.192092896e-07f;
    static get bits -> long => 32;
    static get size -> long => 4;
    static get is_signed -> bool => true;
    static get is_integer -> bool => false;
    static get is_floating -> bool => true;
}

public using float = Float32;

/// 64 位双精度浮点数（默认浮点数类型）
public struct Float64 {
    static get max_value -> Float64 => 1.7976931348623157e+308;
    static get min_value -> Float64 => 2.2250738585072014e-308;
    static get epsilon -> Float64 => 2.2204460492503131e-16;
    static get bits -> long => 64;
    static get size -> long => 8;
    static get is_signed -> bool => true;
    static get is_integer -> bool => false;
    static get is_floating -> bool => true;
}

public using double = Float64;

// ============================================
// 其他类型
// ============================================

/// 布尔类型
public struct Boolean {
    static get true_value -> Boolean => true;
    static get false_value -> Boolean => false;
    static get bits -> long => 1;
    static get size -> long => 1;
    static get is_signed -> bool => false;
    static get is_integer -> bool => false;
    static get is_floating -> bool => false;
}

public using bool = Boolean;

/// Unicode 字符类型（32 位码点）
public struct Char {
    static get max_value -> Char => '\U0010FFFF';
    static get min_value -> Char => '\0';
    static get bits -> long => 32;
    static get size -> long => 4;
    static get is_signed -> bool => false;
    static get is_integer -> bool => false;
    static get is_floating -> bool => false;
}

public using char = Char;

/// 字面量视图类型
public struct LiteralView {
    // 字段：编译器内部维护，用户无法直接访问
    byte!^ ptr;  // 指向只读字节数据的指针
    long len;     // 数据长度（字节数）
}
```

## 3.2 void 关键字说明

`void` 是**关键字**，不是类型。它仅用于表示函数不返回任何值。

### 3.2.1 作为函数返回类型
```cpp
// ✅ 正确：表示函数不返回值
func do_something() -> void {
    // 不需要 return 语句
}

// ✅ 或者省略返回类型（默认返回 void）
func do_something() {
    // 同样表示不返回值
}
```

### 3.2.2 不能作为变量类型
```cpp
// ❌ 错误：void 不是类型，不能声明变量
void x;

// ❌ 错误：void 不能作为表达式
var y = void;
```

### 3.2.3 在类型系统中的作用
- `void` 是编译器内部的特殊标记
- 用于函数返回类型，表示"没有返回值"
- 不能在用户代码中作为类型使用

## 4. 类型推导规则

### 4.1 整数字面量

整数字面量默认推导为 `int`（即 `Int32`）：

```cpp
// 整数字面量的默认推导
var x = 42;           // 类型: int
var y = -123;          // 类型: int

// 显式指定类型
long z = 9223372036854775807;  // 类型: long
uint u = 4294967295;             // 类型: uint
```

### 4.2 浮点数字面量

浮点数字面量默认推导为 `double`（即 `Float64`）：

```cpp
// 浮点数字面量的默认推导
var a = 3.14;          // 类型: double
var b = 1.0e10;        // 类型: double

// 显式指定类型
float f = 3.14f;       // 类型: float
fp16 h = 3.14h;        // 类型: fp16
```

### 4.3 字符串字面量

字符串字面量的类型是 `LiteralView`：

```cpp
// 字符串字面量的类型
var s = "hello";        // 类型: LiteralView
var t = "world";        // 类型: LiteralView
```

## 5. 访问静态属性

### 5.1 使用简短类型别名访问

开发者可以使用简短类型别名访问静态属性：

```cpp
// 使用 int（即 Int32）的静态属性
println(int.max_value);    // 2147483647
println(int.min_value);    // -2147483648
println(int.bits);         // 32
println(int.size);         // 4

// 使用 double（即 Float64）的静态属性
println(double.max_value); // 1.7976931348623157e+308
println(double.epsilon);   // 2.2204460492503131e-16
```

### 5.2 使用真实类型名访问

也可以使用真实类型名访问，结果相同：

```cpp
// 使用真实类型名 Int32
println(Int32.max_value);  // 2147483647
println(Int32.bits);       // 32
```

## 6. 设计闭环总结

### 6.1 闭环流程

```
┌─────────────────────────────────────────────────┐
│  1. std.core 模块定义所有内置类型               │
│     - Int32, Int64, Float32, Float64 等       │
│     - 包含完整的静态属性                         │
└───────────────┬─────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────┐
│  2. 简短类型别名定义                            │
│     - using int = Int32                         │
│     - using long = Int64                        │
│     - using double = Float64                    │
└───────────────┬─────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────┐
│  3. 类型推导                                    │
│     - 整数字面量 -> int                         │
│     - 浮点数字面量 -> double                    │
│     - 字符串字面量 -> literal_view              │
└───────────────┬─────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────┐
│  4. 开发者使用                                  │
│     - int x = 42                                │
│     - println(int.max_value)                    │
│     - 简洁、直观、完整                           │
└─────────────────────────────────────────────────┘
```

### 6.2 关键优势

1. **清晰与便捷的平衡**：真实类型名清晰，简短别名便捷
2. **完整的信息可访问**：所有静态属性都在 std.core 中
3. **一致的类型系统**：编译器和开发者看到同一套类型定义
4. **易于扩展**：添加新类型只需在 std.core 中添加声明

## 7. 实现注意事项

### 7.1 编译器实现

编译器需要：
1. 在启动时预加载 `std.core` 模块
2. 将简短类型别名解析为真实类型
3. 在类型检查时使用真实类型名
4. 在错误信息中使用简短类型名（更友好）

### 7.2 标准库实现

标准库可以：
1. 直接引用真实类型名（`Int32`、`Float64`）
2. 或者使用简短别名（`int`、`double`）
3. 两者完全等价，选择取决于代码风格

## 8. 示例代码

### 8.1 基本使用

```cpp
import std.core;

func main() {
    // 使用简短类型
    int x = 42;
    double pi = 3.14159;
    
    // 访问静态属性
    println("int.max_value = ", int.max_value);
    println("double.epsilon = ", double.epsilon);
    
    // 使用真实类型（同样有效）
    Int32 y = 100;
    Float64 e = 2.71828;
}
```

### 8.2 编译期使用

```cpp
import std.core;

// 编译期计算数组大小
const long ARRAY_SIZE = int.max_value / 1000;

// 编译期断言
comptime {
    assert(int.size == 4);
    assert(double.bits == 64);
}
```

## 9. 总结

这个设计实现了：
- ✅ **清晰**：真实类型名明确表达语义
- ✅ **便捷**：简短别名适合日常编码
- ✅ **完整**：所有静态属性可访问
- ✅ **一致**：编译器和开发者使用同一套定义
- ✅ **可扩展**：易于添加新类型

这是一个完整、实用的内置类型组织设计！
