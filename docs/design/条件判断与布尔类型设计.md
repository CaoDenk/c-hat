# C^ 条件判断与布尔类型设计文档

## 1. 核心决策：严格布尔检查 (Strict Boolean)

C^ 决定采用**严格布尔类型 (Strict Boolean)** 策略，拒绝 C/C++ 风格的隐式数值转换。

### 1.1 设计规则

*   **条件表达式必须是 `bool` 类型**：`if`, `while`, `for`, `do-while` 的条件部分必须计算为 `bool` 值。
*   **禁止 `int` 隐式转换为 `bool`**：`if (1)` 或 `if (0)` 将触发**编译错误**。
*   **禁止指针隐式转换为 `bool`**：`if (ptr)` 将触发**编译错误**。
*   **禁止赋值表达式作为条件**：`if (x = 0)` 将触发**编译错误**（除非 `x = 0` 表达式本身的返回值被显式比较，或者该类型实现了 `bool` 转换，但赋值通常返回引用或值，而 `int` 不转 `bool`，所以天然免疫）。

## 2. 设计理由 (Rationale)

### 2.1 杜绝 "赋值即真" 漏洞
C/C++ 中最臭名昭著的 Bug 之一：
```cpp
// C++ Bug
if (status = ERROR_CODE) { // 赋值成功，结果非0，进入分支
    handle_error();
}
```
在 C^ 中，由于 `status = ...` 返回的是 `int` (或 `void`)，且 `int` 不能隐式转换为 `bool`，这段代码会直接报错。
必须写成：
```cpp
// C^ Correct
if ((status = ERROR_CODE) != 0) { ... }
```

### 2.2 消除语义歧义
*   `if (x)` 对于整数 `x`，到底意味着 `x > 0` 还是 `x != -1` 还是 `x != 0`？
*   `if (ptr)` 对于智能指针，是判断指针非空，还是判断对象有效性？
强制使用 `!= 0` 或 `!= null` 让代码意图一目了然。

```cpp
// 模糊
if (count) { ... }

// 清晰
if (count > 0) { ... }
if (count != 0) { ... }
```

### 2.3 现代化语言的共识
Java, C#, Swift, Rust (部分) 等现代语言均采用了严格布尔策略。这已被证明能显著降低逻辑错误。

## 3. 语法对比

### 3.1 整数判断

| 语言   | 代码              | 结果                                                                 |
| :----- | :---------------- | :------------------------------------------------------------------- |
| C/C++  | `if (1) { }`      | ✅ 编译通过                                                           |
| **C^** | `if (1) { }`      | ❌ **编译错误**: Type 'int' cannot be implicitly converted to 'bool'. |
| **C^** | `if (1 != 0) { }` | ✅ 编译通过                                                           |

### 3.2 指针判断

| 语言   | 代码                   | 结果                                                                  |
| :----- | :--------------------- | :-------------------------------------------------------------------- |
| C/C++  | `if (ptr) { }`         | ✅ 编译通过                                                            |
| **C^** | `if (ptr) { }`         | ❌ **编译错误**: Type 'int^' cannot be implicitly converted to 'bool'. |
| **C^** | `if (ptr != null) { }` | ✅ 编译通过                                                            |

## 4. 用户定义类型的布尔转换

虽然内置类型禁止隐式转换，但为了支持类似 `std::cin >> x` 或智能指针的优雅写法，C^ 允许用户定义类型通过 `explicit operator bool` 进行**上下文布尔转换 (Contextual Conversion)**。

### 4.1 显式转换操作符

```cpp
class Handle {
    private int id;
    
    // 显式布尔转换
    public explicit operator bool() {
        return id != 0;
    }
}

func main() {
    Handle h = ...;
    
    // ✅ 允许：在 if/while 等布尔上下文中，explicit bool 被视为合法
    if (h) { 
        print("Valid handle");
    }
    
    // ❌ 错误：在非布尔上下文中，禁止隐式转换
    // bool b = h; 
    
    // ✅ 允许：显式强转
    bool b = (bool)h;
}
```

**注意**：这仅适用于用户自定义类型（User-Defined Types）。对于内置类型（`int`, `float`, `pointer`），语言层面强制屏蔽了这种转换。

## 5. 总结

C^ 的设计哲学是 **"显式优于隐式，安全优于便利"**。
虽然多敲几个字符 (`!= 0`) 会稍微增加输入量，但换来的是**代码可读性的大幅提升**和**逻辑错误的彻底根除**。这是值得的交换。
