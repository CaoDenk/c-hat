# 数组切片与元组字面量的一致化设计讨论

## 日期
2026-02-18

## 问题背景

当前设计存在不一致性：
- **数组切片字面量**：`var s = [1, 2, 3];` → `.rodata` + `Type![]`（只读视图）
- **元组字面量**：`var t = (1, 2, 3);` → 栈 + `(Type, Type, Type)`（值类型）

用户疑问：
1. 为什么数组切片默认在 `.rodata`？
2. 为什么元组默认在栈？
3. 怎么设计更优雅，实现闭环？

---

## 1. 设计方案对比

### 方案 A：保持现状（当前设计）

| 类型 | 语法 | 默认存储 | 类型 |
|------|------|----------|------|
| 数组切片 | `var s = [1, 2, 3];` | `.rodata` | `Type![]` |
| 栈数组 | `Type[$] s = [1, 2, 3];` | 栈 | `Type[N]` |
| 元组 | `var t = (1, 2, 3);` | 栈 | `(Type, Type, Type)` |

**优点：**
- 纯常量切片零成本（.rodata）
- 栈数组显式控制（Type[$]）
- 元组值类型默认在栈

**缺点：**
- 数组切片和元组的默认行为不一致
- 容易让用户困惑：为什么 `[1, 2, 3]` 和 `(1, 2, 3)` 存储位置不同？
- 没有形成完美的闭环

---

### 方案 B：数组切片也默认在栈上（值类型）

| 类型 | 语法 | 默认存储 | 类型 |
|------|------|----------|------|
| 数组 | `var s = [1, 2, 3];` | 栈 | `Type[N]`（值类型） |
| 只读切片 | `Type![] s = [1, 2, 3];` | `.rodata` | `Type![]` |
| 元组 | `var t = (1, 2, 3);` | 栈 | `(Type, Type, Type)` |

**设计思路：**
- 数组字面量 `[1, 2, 3]` 默认推导为值类型 `Type[N]`，在栈上分配
- 与元组保持一致：都是值类型，默认在栈
- 如果需要 `.rodata` 的只读切片，显式声明 `Type![] s = [1, 2, 3];`

**示例：**
```cpp
// 数组字面量 → 默认栈上值类型
var arr = [1, 2, 3];
// 类型: int[3]
// 存储: 栈上
arr[0] = 99; // OK: 可修改

// 显式声明只读切片 → .rodata
int![] slice = [1, 2, 3];
// 类型: int![]
// 存储: .rodata
// slice[0] = 99; // Error

// 元组 → 默认栈上值类型
var tuple = (1, 2, 3);
// 类型: (int, int, int)
// 存储: 栈上
```

**优点：**
- ✅ 数组和元组的默认行为一致！都是值类型，默认在栈
- ✅ 形成完美闭环：值类型默认栈，视图类型显式声明
- ✅ 符合用户直觉：`[1, 2, 3]` 和 `(1, 2, 3)` 都是值
- ✅ 可修改性：默认数组是可修改的
- ✅ 简单：不需要 `Type[$]` 语法，默认就是栈数组

**缺点：**
- 纯常量数组也在栈上，需要运行时初始化（虽然成本很低）
- 失去了 `.rodata` 的零成本优势（但可以显式声明）
- 需要修改之前的切片字面量设计文档

---

### 方案 C：元组也默认在 .rodata（只读视图）

| 类型 | 语法 | 默认存储 | 类型 |
|------|------|----------|------|
| 数组切片 | `var s = [1, 2, 3];` | `.rodata` | `Type![]` |
| 栈数组 | `Type[$] s = [1, 2, 3];` | 栈 | `Type[N]` |
| 元组视图 | `var t = (1, 2, 3);` | `.rodata` | `(Type, Type, Type)!`（只读） |
| 栈元组 | `tuple! t = (1, 2, 3);` | 栈 | `(Type, Type, Type)`（值类型） |

**设计思路：**
- 数组切片和元组都默认在 `.rodata`，只读
- 如果需要栈上的可修改值，显式声明

**优点：**
- 纯常量零成本
- 数组切片和元组默认行为一致

**缺点：**
- ❌ 元组值类型默认只读，不符合直觉
- ❌ 需要引入复杂的元组视图语法
- ❌ 与大多数语言的设计不一致
- ❌ 增加了语言复杂度

---

### 方案 D：区分纯常量 vs 含变量（混合方案）

| 类型 | 纯常量语法 | 含变量语法 | 存储 |
|------|------------|------------|------|
| 数组切片 | `var s = [1, 2, 3];` | `Type[$] s = [x, y, z];` | 纯常量 → .rodata；含变量 → 栈 |
| 元组 | `var t = (1, 2, 3);` | `var t = (x, y, z);` | 无论是否纯常量，都在栈 |

**设计思路：**
- 数组切片：纯常量 → `.rodata`，含变量 → 栈（显式 `Type[$]`）
- 元组：无论是否纯常量，都在栈（值类型）
- 解释：数组可以有视图语义，元组只有值语义

**优点：**
- 数组切片的纯常量零成本
- 元组值类型默认在栈
- 保持了各自的语义特性

**缺点：**
- ❌ 仍然不一致：为什么数组纯常量在 .rodata，元组纯常量在栈？
- ❌ 没有形成完美闭环
- ❌ 还是容易让用户困惑

---

## 2. 我的推荐：方案 B（数组也默认在栈上，值类型）

### 2.1 核心理由

1. **一致性**：数组和元组都是值类型，默认在栈上
2. **直觉**：`[1, 2, 3]` 和 `(1, 2, 3)` 都是值，行为应该一致
3. **简单**：不需要 `Type[$]` 语法，默认就是栈数组
4. **可修改**：默认数组是可修改的，更实用
5. **闭环**：值类型默认栈，视图类型显式声明

### 2.2 完整设计

| 类型 | 语法 | 默认存储 | 类型 | 说明 |
|------|------|----------|------|------|
| **数组（值类型）** | `var arr = [1, 2, 3];` | 栈 | `Type[N]` | 值类型，可修改，拥有数据 |
| **只读切片（视图）** | `Type![] slice = [1, 2, 3];` | `.rodata` | `Type![]` | 只读视图，指向 .rodata |
| **切片（视图）** | `Type[] slice = arr;` | 栈 | `Type[]` | 可写视图，引用已有数据 |
| **元组（值类型）** | `var tuple = (1, 2, 3);` | 栈 | `(Type, Type, Type)` | 值类型，可修改，拥有数据 |

### 2.3 示例代码

```cpp
// ========== 数组字面量（默认栈上，值类型） ==========
var arr = [1, 2, 3];
// 类型: int[3]
// 存储: 栈上（值类型）
arr[0] = 99; // OK: 可修改

// ========== 显式只读切片（.rodata） ==========
int![] const_slice = [1, 2, 3];
// 类型: int![]
// 存储: .rodata（只读视图）
// const_slice[0] = 99; // Error: 只读

// ========== 切片引用（引用已有数组） ==========
int[] slice = arr;
// 类型: int[]
// 存储: 栈上（视图）
slice[0] = 100; // OK: 修改 arr

// ========== 元组（默认栈上，值类型） ==========
var tuple = (1, 3.14, true);
// 类型: (int, float, bool)
// 存储: 栈上（值类型）
var first = tuple[0];  // 1
var second = tuple[1]; // 3.14
var third = tuple[2];  // true
```

### 2.4 设计闭环

```
值类型（Value Types）
├── 数组 Type[N]    → 默认栈上，拥有数据
└── 元组 (T1, T2)   → 默认栈上，拥有数据

视图类型（View Types）
├── 切片 Type[]     → 引用已有数据，可写
└── 只读切片 Type![] → 引用 .rodata，只读
```

**完美闭环：**
- 值类型默认在栈上，拥有数据
- 视图类型显式声明，引用数据
- 数组和元组都是值类型，行为一致
- 切片是视图类型，引用数组

---

## 3. 对比总结

| 方案 | 一致性 | 直觉性 | 简单性 | 零成本 | 推荐度 |
|------|--------|--------|--------|--------|--------|
| 方案 A（当前） | ❌ 低 | ❌ 低 | ⚠️ 中 | ✅ 高 | ⭐⭐ |
| 方案 B（推荐） | ✅ 高 | ✅ 高 | ✅ 高 | ⚠️ 中 | ⭐⭐⭐⭐⭐ |
| 方案 C | ✅ 高 | ❌ 低 | ❌ 低 | ✅ 高 | ⭐ |
| 方案 D | ⚠️ 中 | ⚠️ 中 | ⚠️ 中 | ✅ 高 | ⭐⭐⭐ |

---

## 4. 最终推荐

**我强烈推荐方案 B：数组也默认在栈上，值类型！**

### 理由：
1. ✅ **完美一致性**：数组和元组都是值类型，默认在栈上
2. ✅ **符合直觉**：`[1, 2, 3]` 和 `(1, 2, 3)` 都是值
3. ✅ **简单优雅**：不需要 `Type[$]` 语法，默认就是栈数组
4. ✅ **可修改性**：默认数组是可修改的，更实用
5. ✅ **完美闭环**：值类型默认栈，视图类型显式声明

### 语法调整：
- 移除 `Type[$]` 语法（不再需要）
- `var arr = [1, 2, 3];` → 直接就是栈数组 `Type[N]`
- 如果需要 `.rodata` 的只读切片，显式声明 `Type![] s = [1, 2, 3];`

### 总结：
方案 B 是最优雅、最一致、最符合直觉的设计！形成了完美的闭环！
