# C^ 函数设计文档

## 1. 函数基础

### 1.1 函数声明与定义

* **声明**：函数原型，告诉编译器函数的名称、参数类型和返回类型
* **定义**：函数实现，包含函数体

```cpp
// 函数声明
func add(int a, int b) -> int;

// 函数定义
func add(int a, int b) -> int {
    return a + b;
}
```

### 1.2 函数签名

* **组成**：函数名 + 参数类型列表（不包括返回类型）
* **重载**：支持函数重载，通过不同的参数类型列表区分
* **命名空间**：函数签名在命名空间内唯一

```cpp
// 函数重载
func print(int value) {
    printf("%d\n", value);
}

func print(string value) {
    printf("%s\n", value.c_str());
}
```

### 1.3 返回类型

* **显式返回**：使用 `-> type` 指定返回类型
* **无返回值**：可以省略返回类型或使用 `void`
* **返回表达式**：使用 `return` 语句返回值

```cpp
// 无返回值
func say_hello() {
    printf("Hello\n");
}

// 显式返回类型
func add(int a, int b) -> int {
    return a + b;
}

// 表达式函数体
func subtract(int a, int b) -> int => a - b;

// 1.4 复杂函数声明示例
// 推荐顺序：函数名 -> 参数 -> 返回类型 -> noexcept -> where
func swap<T>(T& a, T& b) -> void 
    noexcept(noexcept(T.move()))  // 运行时行为约束 (不抛异常)
    where Movable<T>              // 编译时类型约束 (必须可移动)
{
    T temp = a;
    a = b;
    b = temp;
}
```

### 1.4 函数声明语法：`func` 关键字 vs C#/C++ 风格

这里的选择核心不是“像不像 C/C++”，而是是否能在 C^ 的类型系统与语义目标下保持一致、可读、易解析。

**选择 `func` 关键字的理由**

- **解析更稳定**：在类型前置、修饰符较多（`!`、`~`、`&`、`^`、数组维度、泛型、where/noexcept）的语法下，用 `func` 作为锚点可以显著降低歧义与回溯。
- **声明与类型构造统一**：函数声明是 `func name(...) -> R`，函数指针类型是 `func(...) -> R`，阅读方向一致，避免 C 风格函数指针的括号噪声。
- **更利于 IDE/格式化/错误恢复**：关键字让解析器与工具更容易定位“这是函数”，尤其在错误恢复与增量解析里差异很大。

**C#/C++ 风格的主要问题**

- **更依赖上下文推断**：当返回类型写在最前面（或省略关键字）时，很多以类型开头的声明在语法层面更容易与变量声明/类型别名/构造表达式产生冲突。
- **函数指针更丑**：如果走 C/C++ 的 `R (*p)(...)` 方向，文档和代码可读性会明显下降，也不利于与 `^`/`&`/`~` 等符号体系保持一致。

**结论**

- 保持 `func` 关键字作为函数声明/定义的固定入口。
- 用 `func(param_types) -> return_type` 作为“函数指针类型”（不捕获、薄指针）的标准写法，与语言整体类型前置风格对齐。

## 2. 函数参数

### 2.1 参数传递方式

* **值传递**：复制参数值，函数内修改不影响外部
* **引用传递**：
    *   **可变引用 (`int&`)**：传递引用，函数内可修改。**调用时必须显式使用 `&`**。
    *   **不可变引用 (`int!&`)**：传递只读引用（类似 C++ `const int&`）。函数内不可修改。**调用时可以直接传递变量**（因为无副作用，无需警示）。
* **右值引用传递 (`string~`)**：传递右值（临时对象或显式 `move` 的对象）。用于实现移动语义和资源接管。
* **指针传递**：传递指针，函数内修改影响外部。**直接传递指针类型** (如果变量本身不是指针，则需用 `^` 取址)。

```cpp
// 1. 值传递 (Copy)
func pass_value(int x) { ... }

// 2. 可变引用 (Mutable Reference)
// 意图：我要修改 x
func pass_ref(int& x) { x++; }

// 3. 不可变引用 (Immutable Reference)
// 意图：我要高效读取 x，但我保证不修改它
// 语法：int! (不可变int) + & (引用)
func pass_const_ref(int!& x) {
    // x++; // Error: cannot assign to immutable variable
    print(x);
}

// 4. 右值引用 (R-value Reference)
// 意图：我要接管资源 (Move)
func pass_rvalue(string~ s) {
    // s 绑定到右值，可以直接接管其资源
}

func main() {
    int val = 10;
    
    pass_value(val);
    
    pass_ref(&val);      // 显式 &：警示副作用
    
    pass_const_ref(val); // 隐式：因为是只读的，没有副作用，所以允许隐式传递
                         // 这对于传递大对象 (如 Struct) 非常方便且安全
                         
    pass_rvalue(string("temp")); // 临时对象自动匹配右值引用
    string s = "hello";
    pass_rvalue(s~);     // 显式 move 传递
}
```

### 2.2 设计哲学与 C++ 对比 (Design Philosophy)

C^ 的引用传递设计经过深思熟虑，旨在解决 C++ 中长期存在的**可见性**和**安全性**问题。

| 特性              | C++ 做法            | C^ 设计     | C^ 的优势                                                                                                                              |
| :---------------- | :------------------ | :---------- | :------------------------------------------------------------------------------------------------------------------------------------- |
| **可变引用调用**  | `foo(x)`            | `foo(&x)`   | **拒绝隐式副作用**。在 C++ 中，仅看 `foo(x)` 无法判断 `x` 是否会被修改。C^ 强制使用 `&`，让代码审查者一眼看出副作用。                  |
| **右值/移动调用** | `foo(std::move(x))` | `foo(x~)`   | **简洁且语义统一**。`~` 在 C^ 中代表"析构/生命周期结束"。`x~` 语义上表示"x 的生命周期在此结束，资源被转移"，比冗长的库函数调用更优雅。 |
| **只读引用调用**  | `foo(x)`            | `foo(x)`    | **安全默认**。对于不会修改参数的 `int!&`，保持调用的简洁性（因为无副作用）。                                                           |
| **引用符号**      | `T&` / `T&&`        | `T&` / `T~` | **符号区分度高**。`&` 代表引用，`~` 代表移动/右值。避免了 C++ 中 `&` 和 `&&` 容易混淆的问题。                                          |

### 2.3 默认参数

* **语法**：`func name(param_type param = default_value)`
* **规则**：默认参数必须在参数列表的末尾
* **使用**：调用时可以省略默认参数

```cpp
func greet(string name, string message = "Hello") {
    printf("%s, %s!\n", message.c_str(), name.c_str());
}

// 调用
func main() {
    greet("Alice"); // 使用默认参数
    greet("Bob", "Hi"); // 提供自定义参数
}
```

### 2.3 可变参数

* **语法**：使用 `...` 表示可变参数
* **使用**：配合 `va_list` 等工具处理可变参数

```cpp
func printf(string format, ...) {
    // 处理可变参数
}

func main() {
    printf("%d, %s\n", 42, "Hello");
}
```

## 3. 函数特性

### 3.1 内联函数

* **语法**：使用 `inline` 关键字
* **作用**：建议编译器将函数调用替换为函数体，减少函数调用开销
* **适用场景**：短小频繁调用的函数

```cpp
inline func max(int a, int b) -> int {
    return a > b ? a : b;
}
```

### 3.2 comptime 函数

* **语法**：使用 `comptime` 关键字
* **作用**：强制在编译期执行函数，返回编译期常量
* **适用场景**：元编程、编译期计算

```cpp
comptime func factorial(int n) -> int {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

// 编译期计算
const int result = factorial(5); // 结果为 120
```

### 3.3 函数指针

* **语法**：`func(param_types) -> return_type`
* **用途**：回调函数、函数表、策略模式等

```cpp
func add(int a, int b) -> int {
    return a + b;
}

func subtract(int a, int b) -> int {
    return a - b;
}

func main() {
    func(int, int) -> int operation;
    
    operation = ^add; // 使用前缀 ^ 获取函数地址
    printf("%d\n", operation(5, 3)); // 输出 8
    
    operation = ^subtract;
    printf("%d\n", operation(5, 3)); // 输出 2
}
```

### 3.4 Lambda 表达式

* **语法**：`[capture](params) -> return_type { body }`
* **用途**：匿名函数，用于简短的函数对象
* **捕获**：可以捕获外部变量

```cpp
func main() {
    int x = 10;
    
    // 捕获外部变量
    var add_x = [x](int y) -> int {
        return x + y;
    };
    
    printf("%d\n", add_x(5)); // 输出 15
    
    // 捕获所有外部变量
    var multiply = [&](int a, int b) -> int {
        return a * b;
    };
    
    printf("%d\n", multiply(3, 4)); // 输出 12
}
```

## 4. 成员函数

### 4.1 基本定义

* **语法**：在类或结构体内部定义函数
* **访问控制**：可以指定 `public`、`private`、`protected` 访问权限

```cpp
class Person {
private:
    string _name;
    int _age;
public:
    func get_name() -> string {
        return _name;
    }
    
    func set_name(string name) {
        _name = name;
    }
    
    func get_age() -> int {
        return _age;
    }
    
    func set_age(int age) {
        _age = age;
    }
};
```

### 4.2 self 关键字

* **显式参数**：成员函数内推荐显式声明 `self` 参数
* **用途**：区分成员变量和局部变量，访问当前对象
* **类型**：`self` 代表对象引用/值，而非指针

```cpp
class Person {
private:
    string _name;
public:
    // 返回对象指针
    func set_name(self, string name) -> Person^ {
        self._name = name;
        return self^; // self^ 取地址
    }
};
```

### 4.3 静态成员函数

* **语法**：使用 `static` 关键字
* **特点**：不依赖于对象实例，没有 `self`
* **调用**：通过类名直接调用

```cpp
class Math {
public:
    static func add(int a, int b) -> int {
        return a + b;
    }
};

// 调用
func main() {
    int result = Math.add(1, 2);
}
```

### 4.4 虚函数与多态

* **语法**：使用 `virtual` 关键字
* **覆盖**：派生类使用 `override` 关键字覆盖基类虚函数
* **多态**：通过基类指针或引用调用派生类方法

```cpp
class Shape {
public:
    virtual func draw() {
        printf("Drawing shape\n");
    }
};

class Circle : public Shape {
public:
    override func draw() {
        printf("Drawing circle\n");
    }
};

// 多态调用
func main() {
    Shape^ shape = new Circle();
    shape.draw(); // 调用 Circle::draw()
}
```

## 5. 函数的高级特性

### 5.1 递归函数

* **定义**：函数调用自身
* **终止条件**：必须有终止条件，避免无限递归
* **栈溢出**：递归深度过大可能导致栈溢出

```cpp
func fibonacci(int n) -> int {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

### 5.2 尾递归

* **定义**：递归调用是函数的最后一个操作
* **优化**：编译器可以优化尾递归，避免栈溢出
* **写法**：确保递归调用是最后一个操作

```cpp
// 尾递归优化
func factorial_tail(int n, int accumulator = 1) -> int {
    if (n <= 1) {
        return accumulator;
    }
    return factorial_tail(n - 1, n * accumulator);
}
```

### 5.3 函数模板

* **语法**：`func name<T>(params) where Constraint`
* **用途**：编写通用函数，支持不同类型
* **实例化**：编译器根据调用时的类型自动实例化

```cpp
func max<T>(T a, T b) -> T where Comparable<T> {
    return a > b ? a : b;
}

// 调用
func main() {
    int int_max = max(1, 2);
    float float_max = max(1.5f, 2.5f);
}
```

## 6. 函数的性能优化

### 6.1 内联展开

* **适用场景**：短小频繁调用的函数
* **优势**：减少函数调用开销
* **劣势**：增加代码大小

### 6.2 参数传递优化

* **大型对象**：使用引用或指针传递，避免复制开销
* **小型对象**：使用值传递，避免间接访问开销

### 6.3 返回值优化

* **RVO (Return Value Optimization)**：编译器优化返回值的复制
* **NRVO (Named Return Value Optimization)**：编译器优化具名返回值的复制
* **移动语义**：使用移动构造函数减少返回开销

```cpp
class BigObject {
public:
    BigObject() {
        printf("Constructor\n");
    }
    
    BigObject(const BigObject& other) {
        printf("Copy constructor\n");
    }
    
    BigObject(BigObject&& other) {
        printf("Move constructor\n");
    }
};

// RVO
func create_object() -> BigObject {
    return BigObject();
}

// 调用
func main() {
    BigObject obj = create_object(); // 可能只调用一次构造函数
}
```

## 7. 最佳实践

1. **函数职责**：每个函数只负责一个明确的任务
2. **函数长度**：保持函数短小，一般不超过 50 行
3. **函数命名**：使用清晰、描述性的函数名
4. **参数数量**：控制参数数量，一般不超过 5 个
5. **返回值**：函数应返回有意义的值，便于错误处理
6. **错误处理**：使用返回值或异常处理错误
7. **注释**：为复杂函数添加注释，说明功能和参数
8. **测试**：为重要函数编写单元测试

```cpp
// 好的函数设计
/**
 * 计算两个数的最大公约数
 * @param a 第一个数
 * @param b 第二个数
 * @return 最大公约数
 */
func gcd(int a, int b) -> int {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

C^ 的函数设计提供了丰富的特性，包括函数重载、默认参数、Lambda 表达式等，同时保持了与 C/C++ 的兼容性。合理使用这些特性可以编写清晰、高效的代码。
