# C^ 基础类型系统设计

## 0. C^ 语言大厦：最小内置类型与类型构造器

为了实现“微内核 + 用户态标准库”，C^ 将类型系统划分为两层：

- **语言内置（物理层）**：少量关键字类型 + 少量类型构造器，负责表达内存与布局事实。
- **标准库（语义层）**：在物理层之上提供算法、协议与可读性别名，不要求编译器开洞。

下面是 C^ 类型系统“最小地基”的推荐划分（可按实现逐步完善，但尽量不扩张内置集合）。

### 0.1 原子类型（关键字类型，构成 C^ 世界的原子）

这些类型由关键字直接给出，用于构建所有更复杂的类型：

- **整数族**：`byte/sbyte/short/ushort/int/uint/long/ulong`
- **浮点族**：`float/double/fp16/bf16`
- **字符/布尔**：`char/bool`

### 0.2 数组类型（栈上存储的“物理容器”）

- `T[N]`：固定大小数组，拥有物理存储（通常在栈上，或作为字段嵌入在结构体内）

### 0.3 视图类型（胖指针：集合的非拥有视图）

- `T[]`：切片/视图类型，物理布局为 `ptr + len`
- 视图不拥有内存，只描述一段连续存储的“窗口”

### 0.4 指针类型（地址访问的扩展媒介）

- `T^`：裸指针，表达“我持有一个地址”
- 地址操作与解引用统一由 `^` 完成（见 [指针设计.md](file:///d:/projects/CppProjs/c-hat/docs/design/%E6%8C%87%E9%92%88%E8%AE%BE%E8%AE%A1.md)）

### 0.5 `literal_view`：语言内置的字面量承载类型

`literal_view` 用于承载字符串字面量等“放在 `.rodata` 的只读数据”。它属于语言内置类型，但表现为一个普通类型名，并有固定 ABI 布局（可类比“内置 struct”）：

- 逻辑字段：`ptr + len`
- 指针目标：只读字节（例如 `byte!^`）
- 生命周期：静态（保证来自只读段）

关键点：`literal_view` 不是“标准库类通过普通代码就能凭空造出来的东西”，因为它需要编译器在遇到字面量时生成值；但它也不是“编译器内置 string”那种特权类型——它只是一个最小的物理载体。

`literal_view` 能被用于 `byte![]` 形参（例如 `func f(byte![] name)` 支持 `f("hello")`）的原因也不是重载 `operator=`，而是**通过隐式转换运算符完成的视图坍缩**：

- `"hello"` 的表达式类型是 `literal_view`
- 调用 `f("hello")` 时，编译器在重载决议/参数匹配阶段，尝试对实参应用 `literal_view` 上可用的 `implicit operator ...`
- `literal_view -> byte![]` 是零拷贝的“视图转换”，只产生只读视图

之所以允许 `literal_view -> byte![]`，是因为这满足三条安全条件：

- **布局一致**：两者都表达 `ptr + len`
- **权限一致**：`literal_view.ptr` 语义上是 `byte!^`，目标 `byte![]` 的元素也是 `byte!`，因此不会产生可写别名
- **生命周期一致**：字面量来自 `.rodata`，生命周期是静态的，视图传递不会悬垂

同理，`byte![] s = "hello"` 里的 `=` 是**初始化语法**，走的是“用 `literal_view` 初始化 `byte![]`”的隐式转换流程；`operator=` 只在变量已经存在时（赋值语句）才可能介入。

最小语法示例：

```cpp
public struct literal_view {
    public byte!^ ptr;
    public usize len;

    public implicit operator byte![]() {
        return { ptr = self.ptr, len = self.len };
    }
}
```

### 0.6 静态反射：元数据对象算不算“类”？算不算内置类型？

静态反射的入口是 `typeof` 与 `@`：

- `typeof(expr)` 产生一个**类型**（Type）
- `@T` 产生一个**编译期元数据对象**（Metaobject）
- `@sizeof(T)` 等是编译期查询

这里的“元数据对象”不是运行时对象，不需要也不应该是某个固定的“基类实例”。推荐设计为：

- `@T` 返回 **编译器生成的匿名结构化对象**（只在 `comptime` 上下文可用）
- 标准库 `std.meta` 只定义“元概念”（duck typing 的协议），约束这些元对象应该暴露哪些字段/能力

因此：元数据对象属于语言反射系统的一部分（编译器提供），但它不是“运行时内置类”，也不应当成为可在运行时传递/存储的普通类型（见 [反射设计.md](file:///d:/projects/CppProjs/c-hat/docs/design/%E5%8F%8D%E5%B0%84%E8%AE%BE%E8%AE%A1.md)）。

## 1. 变量声明与不可变性 (Variable Declaration & Immutability)

C^ 采用了**不可变优先**的设计哲学，严格区分绑定（Binding）的可变性和数据本身（Data）的可变性。

### 1.1 三种声明方式

| 关键字      | 语义                 | C++ 对应     | 说明                                                                                                     |
| :---------- | :------------------- | :----------- | :------------------------------------------------------------------------------------------------------- |
| **`const`** | **编译期常量**       | `constexpr`  | 值必须在编译期确定，永远不可修改。                                                                       |
| **`let`**   | **运行时不可变绑定** | `const auto` | 值在运行时确定，一旦初始化后，**绑定关系**不可变（不能指向别的），且默认**内容**也不可变（Deep Const）。 |
| **`var`**   | **可变绑定**         | `auto`       | 变量可重新赋值，内容可修改。                                                                             |

### 1.2 `let` vs `var` 详解

*   **`let` (Immutable)**: 
    *   `let x = 10;` -> `x` 不能被修改。
    *   `let s = "hello";` -> `s` 是只读视图。
    *   **设计意图**：作为默认的声明方式。绝大多数变量在初始化后都不应该被修改。
*   **`var` (Mutable)**:
    *   `var i = 0; i++;` -> 允许修改。
    *   **设计意图**：仅用于循环计数器、累加器等明确需要状态变更的场景。

```cpp
const PI = 3.14159; // 编译期常量

func process() {
    let name = "Alice"; // 不可变
    // name = "Bob"; // Error: Cannot assign to 'let' variable
    
    var count = 0; // 可变
    count++; // OK
}
```

### 1.4 `!` 绑定修饰符 (Binding Immutability)

为了让不可变绑定的语义在类型系统中更加统一（而不仅仅依赖 `let` 关键字），C^ 支持在变量声明的类型后使用 `!` 后缀来表示**绑定不可变**。

*   **`T! x`**：等价于 `let x`（推荐使用 `let` 自动推导）。
*   **`byte![]! s`**：
    *   第一个 `!` (`byte!`)：**内容不可变** (Read-only Elements)。
    *   第二个 `!` (`[]!`)：**绑定不可变** (Immutable Binding/Slice)。

这使得类型系统具有完全的正交性：

```cpp
// 1. 完全可变 (var)
// 内容可改 (s[0]='a')，绑定可改 (s=other)
byte[] s1 = ...; 

// 2. 内容只读，绑定可变 (var)
// 内容不可改，绑定可改
byte![] s2 = "hello"; 

// 3. 内容可变，绑定只读 (let)
// 内容可改，绑定不可改 (类似 C++ byte* const)
// 等价于 let byte[] s3 = ...
byte[]! s3 = ...;

// 4. 完全不可变 (let)
// 内容不可改，绑定不可改
// 等价于 let s4 = "hello"
// s4 是一个切片结构 (ptr + len)，存储在栈上
// s4.ptr 指向 .rodata 中的常量字符串 "hello" (无数据拷贝)
byte![]! s4 = "hello";

// 5. 栈数组 (Stack Array)
// 显式使用 [$] 语法，强制在栈上分配数组空间并拷贝数据
// s5 是一个数组 (int[3])，存储在栈上
// 初始化时将 .rodata 中的数据拷贝到栈内存
int[$] s5 = [1, 2, 3]; 
byte[$] s6 = "hello"; // 栈上分配 6 字节 (含 \0)
```

虽然 `byte![]!` 语法合法且精确，但在绝大多数场景下，我们推荐使用 `let/var` 关键字来简化书写。

## 1. 字符与字节 (Bytes & Chars)

C^ 彻底纠正了 C/C++ 中 `char` 语义不清（既是字符又是字节）的缺陷，将两者严格分离。

### 1.1 字节类型

*   **`byte`**：无符号 8 位整数 (`uint8_t`)。表示原始二进制数据。
*   **`sbyte`**：有符号 8 位整数 (`int8_t`)。用于数值计算。

```cpp
byte b = 0xFF;       // 255
sbyte sb = -128;     // -128
byte[] buffer = ...; // 二进制缓冲区
```

### 1.3 类型转换规则 (Type Conversions)

#### 1.3.1 `char` 到 `byte` 的隐式缩窄 (Implicit Narrowing)

为了方便处理 ASCII 字符，C^ 允许**编译期常量** `char` 在值处于 0-255 范围内时，隐式转换为 `byte`。

```cpp
// 合法：'A' (65) 在 byte 范围内，且是编译期常量
byte b1 = 'A'; 

// 非法：'中' (20013) 超出 byte 范围
// byte b2 = '中'; // Error: Constant value '20013' cannot be converted to 'byte'

// 非法：运行时变量不能隐式缩窄
char c = 'A';
// byte b3 = c; // Error: Explicit cast required
byte b4 = (byte)c; // OK
```

## 2. 字符串系统 (Strings)

C^ 区分**文本字符串**和**原始字节串**。

### 2.1 字符串字面量与 `string` 类型

*   **字面量本质**：字符串字面量 `"Hello"` 的表达式类型是 **`literal_view`**（只读 `.rodata` 的 `ptr + len` 载体），并且可通过 `literal_view` 的 `implicit operator byte![]()` 坍缩为只读字节切片视图。
    *   它存储在只读数据段 (.rodata)，**不可修改**。
    *   `byte![] str = "hello";` 会触发 `literal_view -> byte![]` 的零拷贝视图转换。
    *   试图修改内容（如 `str[0] = 'a'`）会导致**编译错误**。

```cpp
var raw = "hello"; // raw 类型为 literal_view
// raw[0] = 'H';   // Compile Error: cannot assign to read-only location
```

### 2.1.1 `T[]` 是语言内置的“切片视图类型”

`T[]` 是一种**物理视图类型**（胖指针：`ptr + len`），属于语言内置的类型构造器，和 `T^`、`T[N]` 同一层级。

标准库可以（也推荐）只做命名上的封装，以便文档与 API 更易读：

```cpp
// std.core
using Slice<T> = T[];
using string_view = byte![]; // 或者更严格的 UTF-8 view 类型
```

因此：

- `byte![]` 不是“类”，而是 `T[]` 这种内置视图类型的一个实例化
- `Slice<byte!>` 只是 `byte![]` 的别名展开（做法 A），不需要任何隐式转换

这也意味着：函数参数里写 `Slice<T>` 或 `T[]` 没有本质差异，因为它们是同一个类型。

```cpp
// 这两个声明在类型系统里完全等价
func sum1(Slice<int> xs) -> int { ... }
func sum1(int[] xs) -> int { ... } // 等价重声明：应当报重复定义
```

*   **底层 Const 语法 (`!`)**：C^ 使用 `!` 后缀作为类型修饰符，表示"不可变视图" (Immutable View)。
    *   `T!`：不可变的 T。
    *   `byte!`：不可变的字节 (read-only byte)。
    *   `byte![]`：元素为 `byte!` 的切片 (Slice of Read-Only Bytes)。
    *   `byte!^`：指向 `byte!` 的指针 (Pointer to Read-Only Byte, 类似 C++ `const char*`)。
    *   `byte^!`：不可变的指针 (Immutable Pointer, 类似 C++ `char* const`)。
    *   这与 `let` (变量绑定不可变) 是正交的：
        *   `let s = "..."`：`s` 本身不可重绑定。
        *   `var s = "..."`：`s` 可重绑定，但 `s` 指向的数据 (`byte!`) 仍是只读的。

*   **编译期常量 (`const`)**：`const` 关键字仅用于编译期常量（等价于 C++ 的 `constexpr`），不承担“存储期/静态区”语义。
    *   `const` 不是 `static`，不改变变量的存储位置：局部 `const` 仍是局部变量（编译器通常会内联为立即数或放入只读段）。
    *   `const` 变量必须初始化，且初始化器必须是编译期常量表达式。
    *   如果需要静态存储期，应使用单独的静态机制（例如模块级定义或显式 `static` 成员等），而不是滥用 `const`。

```cpp
func f() {
    const int i = 5;  // 编译期常量，但它并不“必须”分配到静态区
    var x = i + 1;    // i 通常被直接折叠
}
```

*   **标准库类型**：`string` 和 `string_view` 作为标准库提供的核心类型，而非内置的 "魔法" 类型。
    *   **`std.string`**：拥有内存所有权的 UTF-8 字符串类 (类似 C++ `std::string` 但强制 UTF-8)。
*   **`std.string_view`**：非拥有的 UTF-8 字符串切片 (类似 C++ `std::string_view` / Rust `&str`)。

```cpp
import std;

string s = "你好";       // 隐式构造：byte[] -> string (会进行 UTF-8 校验)
string_view sv = "World"; // 隐式构造：byte[] -> string_view (零拷贝)

print(s.length); // 字节长度
print(s.count);  // 字符数量 (UTF-8 解码)
```

### 2.2 字符串与字节数组的转换

由于字面量本身就是 `byte[]`，转换变得非常自然：

*   **`byte[]` -> `string`**：需要显式或隐式转换，通常伴随 UTF-8 校验。
*   **`string` -> `byte[]`**：零拷贝获取内部缓冲区视图。

```cpp
byte[6] raw = [72, 101, 108, 108, 111, 0]; // 直接赋值
string s = string(raw); // 从字节构造字符串
```

### 2.3 C 风格字符串

为了兼容性，保留 C 风格指针，但类型明确。

*   **`cstring`**：**标准库类型别名**（非关键字），等价于 `byte^`，指向以 null 结尾的字节序列。
*   **字面量**：`c"Hello"`。

```cpp
extern func printf(cstring fmt, ...);
printf(c"Value: %d\n", 42);
```

## 3. 数值类型体系

| 类型     | 说明         | 位数 | C++ 对应             |
| :------- | :----------- | :--- | :------------------- |
| `sbyte`  | 有符号字节   | 8    | `int8_t`             |
| `byte`   | 无符号字节   | 8    | `uint8_t`            |
| `short`  | 短整型       | 16   | `int16_t`            |
| `ushort` | 无符号短整型 | 16   | `uint16_t`           |
| `int`    | 整型         | 32   | `int32_t`            |
| `uint`   | 无符号整型   | 32   | `uint32_t`           |
| `long`   | 长整型       | 64   | `int64_t`            |
| `ulong`  | 无符号长整型 | 64   | `uint64_t`           |
| `float`  | 单精度       | 32   | `float`              |
| `double` | 双精度       | 64   | `double`             |
| `fp16`   | 半精度       | 16   | `_Float16` (C23)     |
| `bf16`   | 脑浮点       | 16   | `__bf16` (GCC/Clang) |

### 3.1 AI 与高性能计算类型 (`fp16` / `bf16`)

C^ 将 `fp16` (IEEE 754 Binary16) 和 `bf16` (Brain Floating Point) 提升为**第一类原生类型**，而非库类型。

*   **硬件依赖与软模拟**：
    *   **原生支持**：在支持 AVX-512 (Intel Sapphire Rapids+), ARMv8.2+, NVIDIA GPU 等硬件上，编译器生成原生指令。
    *   **软件模拟**：在不支持的 CPU 上（如老旧 x86），编译器自动生成软件模拟代码（通常隐式提升为 `float` 计算后再截断）。
    *   **性能警告**：当目标平台不支持原生指令且代码中包含大量计算密集型操作时，编译器会发出性能警告 (Performance Warning)。
*   **用途**：
    *   **存储与交换**：主要用于减少显存/内存占用和网络传输带宽。
    *   **计算**：在 AI 推理和图形渲染管线中使用。
*   **字面量后缀**：
    *   `1.5fp` (`fp16`) - **标准库重载后缀** (需 `import std;`)
    *   `1.5bf` (`bf16`) - **标准库重载后缀** (需 `import std;`)
    *   注意：这两个后缀并非语言内置，而是通过标准库的字面量操作符重载实现的。

## 4. 字面量后缀

*   `100` -> `int`
*   `100u` -> `uint`
*   `100L` -> `long`
*   `100UL` -> `ulong`
*   `1.0` -> `double`
*   `1.0f` -> `float`

## 5. 总结

*   **字节与字符分离**：`byte` (8-bit) vs `char` (32-bit Unicode)。
*   **字符串是 UTF-8**：`string` 是 UTF-8 字节序列的视图。
*   **明确的整数类型**：摒弃 `long long` 等含糊类型，采用固定位宽命名。
