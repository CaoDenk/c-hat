# 内置类型与标准库闭环设计

## 概述

本文档详细说明 C^ 语言中**内置原生类型**与**标准库**如何通过 `extension` 机制实现无缝集成，形成完整的生态闭环。

---

## 1. 核心设计原则

### 1.1 分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                   标准库 (Standard Library)                    │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ extension LiteralView { ... }  (隐式转换、方法、运算符)│  │
│  │ extension int { ... }              (静态属性、方法)    │  │
│  │ extension byte![] { ... }          (切片方法)          │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                            ↑
                            │  extension 机制
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  编译器内置 (Compiler Built-in)               │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  LiteralView, int, byte, byte!, byte[], byte^, ...  │  │
│  │  (仅提供最基础的类型定义和物理布局)                    │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 职责划分

| 层级 | 职责 | 内容 |
|------|------|------|
| **编译器内置** | 定义物理 reality | 类型名称、内存布局、基础字段、基本操作符 |
| **标准库 extension** | 赋予语义 | 隐式转换、方法、静态属性、运算符重载 |

---

## 2. 案例分析：LiteralView 完整闭环

### 2.1 编译器内置部分

```cpp
// ==========================================
// 编译器内置：仅定义物理 reality
// ==========================================

// 1. TokenType 中添加 LiteralView
enum class TokenType {
    // ...
    LiteralView,  // 新增
    // ...
};

// 2. AST 中添加 LiteralViewType
namespace ast {
    class LiteralViewType : public Type {
    public:
        NodeType getType() const override { return NodeType::LiteralViewType; }
        std::string toString() const override { return "LiteralView"; }
    };
}

// 3. 语义分析器中，字符串字面量自动推导为 LiteralView
std::shared_ptr<types::Type>
SemanticAnalyzer::analyzeStringLiteral(const std::string& value) {
    // 注册字符串字面量到 .rodata
    auto globalVar = llvm::GlobalVariable(
        *module,
        llvm::ArrayType::get(llvm::Type::getInt8Ty(context), value.size() + 1),
        true,  // isConstant
        llvm::GlobalValue::InternalLinkage,
        llvm::ConstantDataArray::getString(context, value, true)
    );
    
    // 返回 LiteralView 类型
    return types::TypeFactory::getLiteralViewType();
}

// 4. 代码生成器：LiteralView 的物理布局
// LiteralView = { ptr: byte!^, len: long }
llvm::Type* LLVMCodeGenerator::getLiteralViewType() {
    if (!literalViewType) {
        std::vector<llvm::Type*> elements = {
            llvm::PointerType::get(llvm::Type::getInt8Ty(context), 0),  // ptr
            llvm::Type::getInt64Ty(context)                                // len
        };
        literalViewType = llvm::StructType::create(context, elements, "LiteralView");
    }
    return literalViewType;
}

// 5. 成员访问：内置支持 .ptr 和 .len
llvm::Value* LLVMCodeGenerator::generateMemberAccess(
    llvm::Value* object,
    const std::string& memberName
) {
    if (object->getType() == getLiteralViewType()) {
        if (memberName == "ptr") {
            return builder->CreateExtractValue(object, {0}, "literalview_ptr");
        } else if (memberName == "len") {
            return builder->CreateExtractValue(object, {1}, "literalview_len");
        }
    }
    // ...
}
```

### 2.2 标准库 extension 部分

```cpp
// ==========================================
// 标准库：通过 extension 赋予语义
// 文件：std/core/LiteralView.ch
// ==========================================

// 1. 隐式转换
extension LiteralView {
    // 转换为只读切片
    public implicit operator byte![]() {
        return { ptr = self.ptr, len = self.len };
    }
    
    // 转换为只读指针（C 互操作）
    public implicit operator byte!^() {
        return self.ptr;
    }
}

// 2. 便捷方法
extension LiteralView {
    public func isEmpty() -> bool {
        return self.len == 0;
    }
    
    public func toDebugString() -> string {
        return "LiteralView(ptr=" + self.ptr + ", len=" + self.len + ")";
    }
}

// 3. 运算符重载
extension LiteralView {
    // 字符串拼接
    public static func operator+(LiteralView lhs, LiteralView rhs) -> String {
        let result = String.allocate(lhs.len + rhs.len);
        result.append(lhs);
        result.append(rhs);
        return result;
    }
    
    public static func operator+(LiteralView lhs, int rhs) -> String {
        return String(lhs) + std.to_string(rhs);
    }
    
    // 比较运算符
    public static func operator==(LiteralView lhs, LiteralView rhs) -> bool {
        if lhs.len != rhs.len {
            return false;
        }
        return std.memcmp(lhs.ptr, rhs.ptr, lhs.len) == 0;
    }
}

// 4. 索引访问
extension LiteralView {
    public get [index: long] -> byte! {
        if index < 0 || index >= self.len {
            panic("Index out of bounds");
        }
        return self.ptr[index];
    }
}
```

### 2.3 闭环工作流程

```
用户代码:
    puts("Hello");
    
    ↓
    
词法分析:
    识别 "Hello" 为 StringLiteral
    
    ↓
    
语法分析:
    创建 StringLiteralExpr
    
    ↓
    
语义分析 (编译器内置):
    1. 推导类型为 LiteralView
    2. 检查是否有 extension 提供隐式转换到 byte^
    3. 找到了！(来自标准库)
    
    ↓
    
代码生成 (编译器内置):
    1. 在 .rodata 生成 "Hello\0"
    2. 创建 LiteralView 结构体 { ptr = .rodata地址, len = 5 }
    3. 应用隐式转换：提取 .ptr
    4. 调用 puts(ptr)
```

---

## 3. 另一个案例：int 的静态属性

### 3.1 编译器内置

```cpp
// 编译器只需要知道 int 是 64 位整数
// 不需要知道 maxValue、minValue 等
```

### 3.2 标准库 extension

```cpp
// std/core/Int.ch

extension int {
    public static get maxValue -> int => 9223372036854775807;
    public static get minValue -> int => -9223372036854775808;
    public static get size -> int => 8;
    
    public func toString() -> string {
        // ... 实现
    }
    
    public func abs() -> int {
        return self < 0 ? -self : self;
    }
}
```

---

## 4. 只读类型 (!) 的实现

### 4.1 编译器内置支持

```cpp
// 1. TokenType - Not 已经存在，但我们需要在类型解析中特殊处理
// 2. AST 中添加 ReadonlyType
namespace ast {
    class ReadonlyType : public Type {
    public:
        ReadonlyType(std::unique_ptr<Type> baseType)
            : baseType(std::move(baseType)) {}
            
        NodeType getType() const override { return NodeType::ReadonlyType; }
        std::string toString() const override {
            return baseType->toString() + "!";
        }
        
        std::unique_ptr<Type> baseType;
    };
}

// 3. Parser 中修改 parseType()
std::unique_ptr<ast::Type> Parser::parseType() {
    // ... 解析基础类型 ...
    
    // 检查是否是只读类型
    if (match(lexer::TokenType::Not)) {
        type = std::make_unique<ast::ReadonlyType>(std::move(type));
    }
    
    return parseTypeSuffix(std::move(type));
}
```

### 4.2 类型系统中的只读性

```cpp
// 类型兼容性规则
bool Type::isAssignableTo(const Type& target) const {
    // 只读可以赋值给只读
    if (this->isReadonly() && target.isReadonly()) {
        return this->getBaseType()->isAssignableTo(target.getBaseType());
    }
    
    // 只读可以赋值给非只读（但会丢失只读性）
    if (this->isReadonly() && !target.isReadonly()) {
        return this->getBaseType()->isAssignableTo(target);
    }
    
    // 非只读不能赋值给只读（除非显式转换）
    if (!this->isReadonly() && target.isReadonly()) {
        return false;  // 或者需要显式的 .readonly() 方法
    }
    
    // ...
}
```

---

## 5. 完整闭环检查清单

### 5.1 LiteralView 闭环

- [x] **编译器内置**
  - [x] TokenType::LiteralView
  - [x] AST::LiteralViewType
  - [x] 字符串字面量推导为 LiteralView
  - [x] 物理布局 (ptr + len)
  - [x] .ptr 和 .len 成员访问

- [ ] **标准库 extension**
  - [ ] 隐式转换到 byte![]
  - [ ] 隐式转换到 byte!^
  - [ ] 方法 (isEmpty, toDebugString, etc.)
  - [ ] 运算符 (+, ==, etc.)
  - [ ] 索引访问

### 5.2 只读类型 (!) 闭环

- [ ] **编译器内置**
  - [ ] 解析 byte! 语法
  - [ ] AST::ReadonlyType
  - [ ] 类型兼容性检查
  - [ ] 代码生成（与非只读相同的布局，仅类型系统不同）

---

## 6. 总结

这个设计方案的核心优势：

1. **编译器极简**：只负责物理 reality，不涉及语义
2. **标准库灵活**：通过 extension 可以无限扩展
3. **用户自由**：可以选择是否引入标准库
4. **自圆其说**：内置类型提供基础，extension 提供完善，形成完整闭环

这就是 C^ 语言的设计哲学：**简单的核心，无限的可能**。
