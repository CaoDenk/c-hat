# C^ 特性提案：自定义字符串插值 (Custom String Interpolation)

## 1. 背景与需求

目前 C^ 已经支持：
1.  **标准插值**：`$"..."` 生成 `string` 对象。
2.  **自定义前缀**：`prefix"..."` 生成自定义类型，但仅接收原始字节 (`byte[]`)，无法感知插值参数。

**缺失场景**：
如果用户想实现一个 `sql` 字符串类型，能够自动处理参数绑定（防止 SQL 注入），或者实现一个零内存分配的 `log` 格式化器，目前的机制无法满足。因为 `sql"SELECT {id}"` 会被当作普通字符串处理，编译器不会解析 `{id}`。

## 2. 语法提案

建议使用 **`$` + `prefix`** 的组合形式，明确区分“纯文本”和“插值文本”。

### 2.1 行为区分规则

*   **无 `$` 前缀** (`prefix"..."`)：
    *   **语义**：**纯字符串字面量**。
    *   **处理**：调用 `operator "prefix"(byte[])`。
    *   **插值**：**禁用**。`{var}` 被视为普通字符 `{` 和 `var` 和 `}`。
    *   **用途**：用于那些确实包含 `{}` 但不需要插值的场景（如 JSON 模板、正则表达式）。

*   **有 `$` 前缀** (`$prefix"..."`)：
    *   **语义**：**插值字符串**。
    *   **处理**：调用 `operator "$prefix"(usize, usize)` 获取 Handler。
    *   **插值**：**启用**。`{var}` 被解析为表达式。
    *   **用途**：用于需要参数绑定的场景（如 SQL 查询、格式化日志）。

### 2.2 示例

```cpp
// 1. 无 $ 前缀：纯文本
// 调用 operator "sql"(byte[])
// {id} 不会被替换，保持原样
var raw_sql = sql"SELECT * FROM users WHERE id = {id}"; 

// 2. 有 $ 前缀：插值
// 调用 operator "$sql"(...) -> Handler
// {id} 会被求值并传递给 Handler
var id = 100;
var query = $sql"SELECT * FROM users WHERE id = {id}";
```

## 3. 实现机制设计 (Compiler Lowering)

为了保持 C^ "零成本抽象" 的原则，我们不应该将插值参数装箱 (Boxing) 成 `object` 数组（像 C# `string.Format` 旧版那样），而应该采用 **编译期展开 (Lowering)** 模式（类似 C# 10 `InterpolatedStringHandler` 或 C++ 20 `std::format` 的编译期检查）。

### 3.1 编译器展开逻辑

当编译器遇到 `$sql"Part1 {arg1} Part2"` 时，它会寻找一个名为 `operator "$sql"` 的静态函数。这个函数不接收字符串内容，而是接收**元数据**，并返回一个 **Handler 构建器对象**。

**原始代码：**
```cpp
int id = 10;
string table = "users";
var q = $sql"SELECT * FROM {table} WHERE id = {id}";
```

**编译器展开伪代码 (Lowering)：**
```cpp
{
    // 1. 调用 operator "$sql" 获取 Handler
    // 参数：(字面量总长度, 插值参数数量)
    // 目的：让 Handler 有机会预分配内存 (reserve)
    var handler = operator "$sql"(31, 2); 
    
    // 2. 依次追加部分
    // 编译器将字面量拆解，并交替调用 append_literal 和 append_formatted
    handler.append_literal("SELECT * FROM ");
    handler.append_formatted(table); // 泛型调用，保留类型信息
    
    handler.append_literal(" WHERE id = ");
    handler.append_formatted(id);    // 泛型调用，保留类型信息
    
    // 3. 获取最终结果
    // 或者是 handler 本身隐式转换为结果类型
    q = handler.get_result();
}
```

### 3.2 用户实现范例：如何定义 `$sql`

为了支持上述机制，用户需要完成两步：
1.  定义 **Handler 结构体**，实现 `append_literal` 和泛型的 `append_formatted`。
2.  定义 **`operator "$prefix"`**，作为 Handler 的工厂函数。

```cpp
// 1. 定义 Handler (构建器)
struct SqlHandler {
    StringBuilder sql;
    List<Parameter> params;

    // 构造函数：预分配内存
    public SqlHandler(usize literal_len, usize arg_count) {
        sql.reserve(literal_len);
        params.reserve(arg_count);
    }

    // 处理字面量部分
    public func append_literal(string_view s) {
        sql.append(s);
    }

    // 处理插值参数 (泛型方法!)
    // 关键点：这里 T 是编译期推导的，完整保留了 id 的类型 (int)
    public func append_formatted<T>(T value) {
        // SQL 注入防护核心：使用参数化查询占位符
        sql.append("?"); 
        params.add(value); // 将实际值存入参数列表
    }

    // 返回最终结果
    public func get_result() -> SqlQuery {
        return SqlQuery(sql.to_string(), params);
    }
}

// 2. 注册前缀 (Factory Function)
// 语法：operator "$prefix"(usize, usize)
public static func operator "$sql"(usize literal_len, usize arg_count) -> SqlHandler {
    return SqlHandler(literal_len, arg_count);
}
```

### 3.3 类型参数传递详解

用户最关心的问题是：**"对方重载了 $ 前缀，所以类型参数该怎么传递？"**

答案在于 **Handler 的 `append_formatted` 方法是泛型的**。

*   **编译期推导**：当编译器生成 `handler.append_formatted(id)` 时，因为 `id` 是 `int`，编译器会自动实例化 `append_formatted<int>(int)`。
*   **零装箱 (Zero Boxing)**：对于基础类型（如 `int`, `float`），直接传递值，不需要装箱成 `object`。
*   **重载支持**：Handler 也可以通过函数重载（而不是泛型）来为特定类型提供优化实现。例如：
    ```cpp
    struct SqlHandler {
        // 泛型回退
        func append_formatted<T>(T val) { ... }
        
        // 针对 int 的特化优化
        func append_formatted(int val) { ... }
    }
    ```

## 4. 方案评价

### 4.1 优点 (Pros)

1.  **安全性 (Security)**：
    *   **SQL 注入防护**：`$sql` 可以将 `{value}` 转换为参数化查询 (`?`)，而不是直接拼接字符串。这是普通字符串插值无法做到的。
    *   **编译期检查**：可以在编译期检查格式化串的合法性（如果配合 `comptime`）。

2.  **高性能 (Performance)**：
    *   **零分配 (Zero Allocation)**：Handler 可以在栈上运行，或者精确预分配堆内存，避免多次 `string` 拼接产生的临时对象。
    *   **类型特化**：`append_formatted<T>(T val)` 是泛型的，对于 `int` 等基础类型无需装箱，直接调用对应的处理逻辑。

3.  **灵活性 (Flexibility)**：
    *   可以实现结构化日志 (`$log`), XML 构建器 (`$xml`), 甚至 DSL。

### 4.2 缺点 (Cons)

1.  **实现复杂度**：用户实现一个高效的 Handler 比较复杂，需要编写 struct 并处理各种 `append` 逻辑。
2. }
    ```

## 5. 备选方案探讨：为什么不采用“分离重载”？

**用户提问**：
> "能不能把功能分开？比如重载 `sql` 前缀返回一个 `Sql` 类，然后重载 `$` 运算符（或其他机制）来处理插值参数？如果好设计就提供，不好就不提供。"

**设计评估**：
这种“分离设计”在逻辑上看起来很美（组合优于继承），但在高性能系统语言中是一个**陷阱**。我们**不建议**提供这种设计，原因如下：

### 5.1 性能陷阱：隐式装箱与分配

如果我们将 `$` 的处理与 `sql` 的处理分开，编译器必须先将插值部分处理成一个中间对象，然后再传给 `sql` 前缀。

```cpp
// 假设的分离设计
var q = $sql"SELECT {id}";

// 编译器必须将其转换为类似这样的运行时调用：
var args = new object[] { id }; // 堆分配 + 装箱 (int -> object)
var fmt = "SELECT {0}";
var q = operator "sql"(fmt, args);
```

这引入了**堆内存分配 (Heap Allocation)** 和 **装箱 (Boxing)**。对于追求零成本抽象的 C^ 来说，这是不可接受的隐式开销。

### 5.2 类型擦除 (Type Erasure)

在分离模式下，参数通常会被统一转换为 `object` 或 `Variant` 数组。这意味着 `SqlHandler` 丢失了参数的原始类型信息（如 `int`, `float`），只能在运行时通过反射或类型判断来处理，这阻碍了编译期优化和类型检查。

### 5.3 结论

为了坚持 **"Hardcore"** 和 **"Zero-cost"** 的语言定位，我们必须采用 **Handler 模式**（即 `$prefix` 作为一个整体处理）。虽然这增加了库作者实现 `SqlHandler` 的复杂度，但它保证了库使用者的**零运行时开销**和**强类型安全**。

## 6. 结论

**强烈建议采纳 Handler 模式**。

这个功能对于 C^ 这样的高性能系统语言至关重要。它区分了“简单的文本拼接”和“结构化的数据构建”。如果没有这个功能，开发者要么面临 SQL 注入风险（直接用 `$""`），要么需要写繁琐的 `builder.bind(...)` 代码。

提供 `$prefix` 语法是解决此问题的最优雅方案，完美契合 C^ "硬核"、"零成本" 的定位。
