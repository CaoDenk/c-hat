# C^ 字符与字符串设计文档

为了回应"字符大小固定"的限制，并支持多编码环境，C^ 采用了**基于前缀的字面量系统**和**逻辑/存储分离**的类型设计。

## 1. 核心哲学：逻辑与存储分离

我们必须区分"字符的逻辑概念"和"字符的物理存储"。

*   **逻辑字符 (`char`)**：统一为 **32位 Unicode 码点 (Code Point)**。这是处理文本逻辑（如判断大小写、数字、Emoji）的最小完整单元，避免了处理变长编码（如 UTF-8/16）的复杂性。
*   **物理存储 (`string`)**：默认采用 **UTF-8** 变长编码，以节省空间并保持 ASCII 兼容性。

## 2. 字符类型体系 (Character Types)

### 2.1 为什么 `char` 默认是 32 位？

这是一个经过深思熟虑的决定，旨在解决 C#/Java 时代遗留的**代理对 (Surrogate Pairs)** 痛点。

*   **C#/Java 的历史包袱**：它们诞生时，Unicode 字符集尚未超过 65535 个，因此选择了 16 位 `char` (UTF-16)。
    *   **后果**：随着 Emoji 和生僻字的普及，`char c = '😊'` 在 C# 中是非法的（Emoji 需要 2 个 `char`）。这导致 `string.Length` 返回的不是字符数，而是代码单元数，极易引发 Bug。
*   **C^ 的现代选择**：作为一门新语言，C^ 选择了与 Rust/Go/Swift 一致的路线——**`char` 代表一个真实的 Unicode 标量值 (Scalar Value)**。
    *   **优势**：逻辑完备，算法简单，无需处理代理对。
    *   **代价**：单个 `char` 占用 4 字节（但这通常发生在寄存器或栈上，影响微乎其微）。

### 2.2 类型列表

为了满足不同场景（特别是与 Windows API 或底层协议交互）的需求，我们提供特定宽度的字符类型。

| 关键字       | 位宽   | 语义              | 用途                                       |
| :----------- | :----- | :---------------- | :----------------------------------------- |
| **`char`**   | 32-bit | Unicode 码点      | **默认类型**。用于文本处理算法、逻辑判断。 |
| **`byte`**   | 8-bit  | UTF-8 单元 / 字节 | 用于二进制数据、UTF-8 字符串底层存储。     |
| **`char16`** | 16-bit | UTF-16 单元       | 用于 Windows API 交互、Java/C# 互操作。    |
| **`char32`** | 32-bit | UTF-32 单元       | 等同于 `char`，但在强调物理存储时使用。    |

### 2.3 字符字面量与前缀

通过前缀区分不同宽度的字符字面量：

```cpp
char c1 = 'A';       // 默认: char (32-bit), 值: 65
char c2 = '中';      // 默认: char (32-bit), 值: 20013

byte b = u8'A';      // 前缀 u8: byte (8-bit)
char16 c3 = u16'中'; // 前缀 u16: char16 (16-bit)
char32 c4 = u32'😊'; // 前缀 u32: char32 (32-bit)
```

## 3. 字符串字面量与类型推导

字符串字面量本质上是**只读数组**。通过前缀控制其编码格式和元素类型。

### 3.1 类型体系：字面量、视图与切片

在 C^ 中，我们严格区分“字面量类型”、“通用视图”和“切片”。

#### 1. `std.literal_view` (编译器推导类型)
*   **定义**：字符串字面量（如 `"hello"`）的**原生类型**。
*   **结构**：`struct { byte!^ ptr; usize length; }`。
*   **语义**：**“我指向静态常量区 (.rodata)，我是永生的。”**
*   **用途**：主要用于重载决议。例如 `string` 的构造函数重载 `string(literal_view)` 可以触发 Static Mode 优化，而 `string(string_view)` 则必须拷贝。
*   **推荐命名**：使用 `literal_view`。这个名字清楚地表明它是一个指向 Literal 的 View，且暗示了静态生命周期。

#### 2. `string_view` (通用参数类型)
*   **定义**：它是 `byte![]` (不可变字节切片) 的**类型别名**。
*   **结构**：`struct { byte!^ ptr; usize length; }` (与 `literal_view` 内存布局完全一致)。
*   **语义**：**“我指向某块内存，我是只读的，但我不保证生命周期。”**
*   **用途**：函数参数的标准类型。`func process(string_view s)` 可以接受字面量、`string` 对象、`byte[]` 数组等任何形式的字符串。
*   **转换**：`literal_view` -> 隐式转换 -> `string_view` (安全，因为静态生命周期 > 任意生命周期)。

#### 3. `byte[]` vs `string_view`
*   **本质上**：它们在 C^ 中是**同一个东西**。`string_view` 只是 `byte![]` 的别名。
*   **误区澄清**：`byte[]` / `string_view` 只是简单的胖指针 (Fat Pointer)，它们**不负责**管理生命周期，也不维护“是否只读/是否静态”的状态位。状态位由 `std.string` (所有者) 维护。

```cpp
// 类型关系图
"hello" (Type: literal_view) 
   |
   +--> 隐式转换 --> string_view (Type: byte![]) 
   |                  ^
   |                  | 隐式转换 (借用)
   +--> 构造 --> string (Owner)
```

### 3.2 栈上字符数组 (Stack Character Array)

为了明确区分**切片 (View)** 和**数组 (Copy)**，C^ 引入了 **`[$]`** 语法来显式表示"自动推导长度的栈数组"。

```cpp
// 1. 切片 (Slice) - 推荐
// s 指向 .rodata 中的常量，零拷贝
// 类型：byte![] (即 string_view)
byte![] s1 = "hello"; 
// s1[0] = 'H'; // Error: 指向只读内存

// 2. 栈数组 (Stack Array) - 显式拷贝
// 编译器自动推导长度为 5
// 类型：byte[5]
// 行为：栈上分配 5 字节，执行 memcpy("hello", s2, 5)
byte[$] s2 = "hello"; 
s2[0] = 'H'; // OK: 修改的是栈上的副本

// 3. 显式指定长度 (传统 C 风格)
byte[10] s3 = "hello"; // 剩余部分填 0
```

### 3.3 切片安全性与生命周期

C^ 的 `byte[]` 和 `string_view` 是非拥有视图。为了防止 Use-After-Free，编译器对**临时对象**到视图的转换有严格限制。

```cpp
func get_name() -> string { return "Alice"; }

// Error: 临时对象销毁，视图悬空
// byte[] view = get_name(); 

// Correct: 绑定到变量延长生命周期
var s = get_name();
byte[] view2 = s; // OK
```

## 4. 字符串内部实现与内存模型 (Implementation Model)

针对用户关于 "const string 优化" 和 "C++20 COW" 的疑问，C^ 采用了 **混合存储模型 (Hybrid Storage Model)**。

### 4.1 三种存储模式

`string` 对象内部通过 `capacity` 字段的高位标记支持三种模式：

1.  **SSO (Small String Optimization)**：
    *   **场景**：短字符串（<= 23 字节）。
    *   **行为**：数据直接存储在栈上对象内部。
    *   **代价**：极快的栈拷贝。

2.  **Heap (Normal)**：
    *   **场景**：动态生成的长字符串。
    *   **行为**：堆分配，标准的所有权模型。

3.  **Static (Zero-Copy) - C^ 的独特优势**：
    *   **场景**：由字面量初始化的长字符串，或显式的 `const string`。
    *   **行为**：`ptr` 指向 `.rodata` 段的字面量地址。标记为 "Borrowed/Static"。

### 4.2 写时复制 (COW) 与 Unshare 机制详解

C^ 的 `string` 实现了高效的**惰性拷贝 (Lazy Copy)** 策略，其核心机制被称为 **Unshare + Write**。这保证了在不修改数据时永远零拷贝，仅在必要时升级为独占堆内存。

#### 1. 状态位设计 (State Flags)
`string` 利用 `capacity` 字段的最高位（或低位，取决于具体实现）作为 **`STATIC_FLAG`**。

*   **Static Mode (借用/只读)**：`capacity` 带有标记。
    *   `ptr` 指向 `.rodata` 或外部不可变缓冲区。
    *   **析构行为**：无操作 (No-op)。
*   **Heap Mode (独占/可变)**：`capacity` 无标记。
    *   `ptr` 指向堆上分配的内存。
    *   **析构行为**：调用 `free(ptr)`。

#### 2. Unshare 动作 (解除共享)
所有可变方法（`operator[]=`, `append`, `clear` 等）在修改数据前，**必须**先调用 `unshare()`。这是从“共享”到“独占”的唯一通道。

```cpp
// 标准库内部伪代码
private void unshare(usize required_cap = 0) {
    // 1. 快速路径：如果是独占模式且容量足够，直接返回
    if (!is_static() && this.capacity >= required_cap) {
        return;
    }

    // 2. 慢速路径：需要迁移数据
    // 计算新容量 (通常有 1.5x 增长策略)
    usize new_cap = calculate_growth(max(this.length, required_cap));
    
    // 3. 申请堆内存 (Heap Allocation)
    byte^ new_ptr = heap_alloc(new_cap);

    // 4. 数据拷贝 (Data Copy)
    // 将数据从只读区 (.rodata) 或旧堆区拷贝到新堆区
    if (this.length > 0) {
        memcpy(new_ptr, this.ptr, this.length);
    }

    // 5. 资源清理 (Cleanup)
    // 如果原先也是 Heap Mode (只是扩容)，则释放旧内存
    // 如果原先是 Static Mode，则无需释放
    if (!is_static()) {
        heap_free(this.ptr);
    }

    // 6. 状态切换 (State Switch)
    this.ptr = new_ptr;
    this.capacity = new_cap; // 清除了 STATIC_FLAG，正式进入 Heap Mode
}
```

#### 3. 读写分岔 (Read/Write Fork)
这种机制导致了 `const` 和 `mutable` 字符串在运行时的巨大行为差异：

*   **Scenario A: `const string s = "..."` (常量)**
    *   **编译期**：只能调用 `const` 方法（如 `length()`, `operator[]` 读）。这些方法**绝不会**调用 `unshare()`。
    *   **运行时**：`s` 永远锁定在 **Static Mode**。
    *   **性能**：**0 堆分配，0 原子操作，0 拷贝**。这是全局常量的终极形态。

*   **Scenario B: `mutable string s = "..."` (变量)**
    *   **初始化**：`s` 处于 **Static Mode** (ptr 指向 .rodata)。
    *   **读取**：直接读取 ptr，**0 开销**。
    *   **首次写入** (`s[0] = 'A'`): 
        1. 调用 `operator[]` (non-const)。
        2. 触发 `unshare()` -> 检测到 Static Mode。
        3. `malloc` + `memcpy` -> 切换到 **Heap Mode**。
        4. 执行写入 `'A'`。
    *   **后续写入** (`s[1] = 'B'`):
        1. 调用 `unshare()`。
        2. **快速检查**：发现已是 Heap Mode 且容量充足。
        3. 立即返回，执行写入。
        *   **代价**：仅需一次位运算 (`&`) 和一次整数比较 (`>=`)。由于分支预测器（Branch Predictor）会记住“通常是堆模式”，这部分开销在现代 CPU 上几乎可以忽略不计。

#### 4. 优势：为什么比 C++ COW 好？
传统的 C++98 COW (Copy-On-Write) 依赖**引用计数 (Ref-Count)**，导致多线程下必须使用昂贵的原子操作 (Atomic Inc/Dec)。

C^ 的 COW 是基于 **Static/Literal** 的：
1.  **无引用计数**：我们不跟踪有多少个 `string` 指向 `.rodata`，因为 `.rodata` 永远存在。
2.  **线程安全**：Static Mode 下的读取天然线程安全；Unshare 总是发生在从 Static 到 Heap 的私有化过程中，不涉及跨线程状态同步。
3.  **零原子开销**：状态检查仅是简单的位运算 (`cap & FLAG`)。

### 4.3 性能闭环：C^ vs C++20

| 场景 (长字符串)        | C++20 `std::string` | C^ `std.string`      | 胜出            |
| :--------------------- | :------------------ | :------------------- | :-------------- |
| **`string s = "..."`** | Heap Alloc + Memcpy | **Static Zero-Copy** | **C^ (优势)**   |
| **`const s = "..."`**  | Heap Alloc + Memcpy | **Static Zero-Copy** | **C^ (大优势)** |
| **读取**               | 指针间接寻址        | 指针间接寻址         | 平手            |
| **首次写入**           | 直接写              | Unshare + Write      | C++ (微弱优势)  |

**结论**：C^ 在最常见的 "只读字面量" 场景下实现了 O(1) 性能，而 C++ 是 O(N)。这使得 C^ 非常适合处理大量文本常量的应用。

## 5. 增强字面量与插值

### 5.1 标准前缀

| 前缀      | 示例        | 类型         | 编码       | 说明                             |
| :-------- | :---------- | :----------- | :--------- | :------------------------------- |
| **(无)**  | `"你好"`    | `byte![]`    | **UTF-8**  | **默认推荐**。原始字节数组切片。 |
| **`$`**   | `$"你好"`   | `std.string` | **UTF-8**  | **标准库字符串对象**。支持插值。 |
| **`u16`** | `u16"你好"` | `char16[]`   | **UTF-16** | 对应 Windows `L"..."`。          |
| **`u32`** | `u32"你好"` | `char[]`     | **UTF-32** | 固定宽度。                       |
| **`b`**   | `b"\xFF"`   | `byte![]`    | **Binary** | 原始字节，不校验编码。           |

### 5.2 字符串插值 (`$`)与自定义格式化

C^ 使用 `$` 前缀提供类型安全且高性能的字符串插值。编译器将其转换为 **Handler 模式** (类似 C# `InterpolatedStringHandler` 或 C++20 `std::format`)，以实现零分配和编译期类型检查。

```cpp
string name = "Alice";
// 编译为: string::format("User {} is {:02X} years old.", name, 30);
string msg = $"User {name} is {30:X2} years old.";
```

#### 扩展：自定义插值 Handler
用户可以通过定义 `operator "$prefix"` 来创建自定义的插值逻辑（如 SQL 构建器、结构化日志），支持**格式说明符**与**零装箱**参数传递。

```cpp
// 1. 定义 Handler
struct SqlHandler {
    func append_literal(string_view s) { ... }
    
    // 支持格式说明符：{value:format}
    func append_formatted<T>(T val, string_view fmt = "") { 
        if (fmt == "raw") sql.append_raw(val); // 危险：直接拼接
        else params.add(val);                  // 安全：参数化
    }
}

// 2. 使用
// 调用 append_literal("SELECT * FROM table WHERE id=")
// 调用 append_formatted(id)
var q = $sql"SELECT * FROM table WHERE id={id}";
```

### 5.3 原始字符串与多行文本

*   **原始字符串 (`#`)**：`#"C:\Windows"#`，无需转义。
*   **多行字符串 (`"""`)**：自动处理缩进。
*   **组合使用**：`$#"""..."""` (插值 + 原始 + 多行)。

### 5.4 自定义前缀 (User-defined Prefix)

用户可以通过重载操作符定义自己的前缀：

```cpp
// 定义
public static func operator "mystring"(byte[] raw) -> MyString { ... }
public static func operator "$sql"(usize len, usize count) -> SqlHandler { ... }

// 使用
var s = mystring"Hello";
var q = $sql"SELECT * FROM table";
```

## 6. 标准库字符串类型 (`std`)

### 6.1 `string` (UTF-8)
核心字符串类型。
*   **底层**：`byte[]` + `capacity` + `length`
*   **编码**：强制 UTF-8 有效性。
*   **构造**：`string s = "Hello";` (隐式转换 `literal_view` -> `string`)

### 6.2 `wstring` / `u16string` (UTF-16)
用于平台互操作。
*   **底层**：`char16[]`

## 7. 遍历与操作 (Iteration)

同一个字符串可以有不同的"视图"。

### 7.1 切片操作 (Slicing)
C^ 支持使用区间语法对字符串进行**零拷贝切片**。切片结果总是 `string_view` (即 `byte![]`)，绝不产生堆分配。

```cpp
string s = "Hello World";

// 1. 基础切片 (返回 string_view)
var sub1 = s[0..5];    // "Hello"
var sub2 = s[6..$0];   // "World" (从索引6到末尾)

// 2. 相对索引 ($)
// $N 表示倒数第 N 个字节
var sub3 = s[1..$1];   // "ello Worl" (去掉首尾各1字节)

// 注意：切片操作基于字节 (O(1))，不检查 UTF-8 边界。
// 若需按字符切片，请先获取 chars 视图：s.chars[0..5]
```

### 7.2 视图遍历

```cpp
string s = "A中😊"; 

// 1. 字节视图 (Bytes) - O(1)
for (byte b : s.bytes) { print(b); }

// 2. 字符视图 (Chars/CodePoints) - O(N) 解码
for (char c : s.chars) { print(c); }

// 3. 索引操作
// s[0] -> byte
// s.chars[1] -> char (需扫描)
```

## 8. 高级模式匹配与编译期优化 (Advanced Features)

### 8.1 字符串模式匹配
C^ 支持在 `match` 语句中对字符串进行高效匹配，包括字面量匹配和守卫子句 (Guard Clauses)。

```cpp
match (filename) {
    // 1. 精确匹配 (O(1) via Hashing)
    case "README.md" => open_readme(),
    
    // 2. 多项匹配
    case "LICENSE" | "COPYING" => show_license(),
    
    // 3. 守卫子句 (灵活匹配)
    case s if s.starts_with("config_") => load_config(s),
    case s if s.ends_with(".json")     => parse_json(s),
    
    case _ => error("Unknown file type")
}
```

### 8.2 编译期哈希 (Compile-time Hashing)
为了保证性能，编译器对字符串字面量的 `match/switch` 进行了特殊优化：

1.  **哈希计算**：编译器在编译期计算所有 case 字符串字面量的哈希值（默认使用 FNV-1a 或 CityHash）。
2.  **代码生成**：将字符串匹配转换为整数 `switch` 指令。
3.  **冲突处理**：如果发生哈希冲突，编译器会自动回退到二分查找或线性扫描，或生成二级检查代码。

这意味着在 C^ 中使用字符串 `switch` 几乎与整数 `switch` 一样快。

## 9. 实现揭秘：无黑魔法设计

C^ 编译器对字符串字面量的处理遵循以下协议：

1.  **语法分析**：`"..."` -> `StringLiteral` 节点。
2.  **类型检查**：`StringLiteral` -> `std.literal_view` (标记类型)。
3.  **重载决议**：
    *   `string s = "..."` -> 匹配 `string(literal_view)` -> 触发 Static Mode。
    *   `byte[] b = "..."` -> 匹配隐式转换 `literal_view` -> `byte[]`。

这不需要新的关键字，利用重载决议实现了高效的字面量处理。
