# C^ 数组设计文档

## 1. 数组基础

C^ 的数组设计核心在于**类型安全**与**显式内存控制**。我们严格区分“固定大小的栈数组”与“动态的堆切片”，并通过一致的语法消除 C/C++ 数组指针退化的混乱。

### 1.1 固定大小数组 (Fixed-Size Array)

*   **定义**：`Type[N] var`。这是**值类型**，在栈上分配，大小在编译期固定。
*   **特性**：拥有数据所有权，可修改。
*   **声明方式**：必须显式指定类型或使用 `[$]` 占位符。

```cpp
// 1. 显式类型与大小
int[5] arr1 = [1, 2, 3, 4, 5];

// 2. 使用 [$] 自动推导栈数组大小 (推荐)
// 只有使用 [$] 时，才会在栈上分配固定大小数组并拷贝数据
// $ 作为占位符，表示"长度由初始化列表决定"
int[$] arr2 = [1, 2, 3]; // 类型推导为 int[3] (栈数组)
``` 
```

### 1.2 切片 (Slice) - 动态视图

*   **定义**：`Type[] var`。这是一个**胖指针 (Fat Pointer)**。
*   **字面量推导**：**`[]` (无占位符) 字面量默认推导为切片**。
    *   `[1, 2, 3]` (全常量) -> 指向 `.rodata` 的 `int![]` (只读切片)。
    *   `[x, y]` (含变量) -> 指向栈上临时数组的 `int[]` (可读写切片)。

```cpp
// 1. 纯常量字面量 -> 只读切片
// s1 指向 .rodata，零拷贝，不可修改
var s1 = [1, 2, 3]; 
// s1[0] = 9; // Error: Immutable view

// 2. 含变量字面量 -> 临时切片
// 编译器在栈上生成匿名数组，s2 指向它
var x = 10;
var s2 = [x, 20]; 
s2[0] = 99; // OK: 修改的是栈上的临时数组
```

### 1.3 设计哲学：为什么默认是切片？

C^ 坚持 **"Zero-Cost Abstractions" (零成本抽象)** 和 **"Explicit Allocation" (显式分配)**。

1.  **一致性**：`var s = "hello"` 是切片，`var a = [1, 2]` 也应该是切片。保持语言行为的高度一致。
2.  **性能默认**：切片是视图，拷贝开销极低。如果默认推导为数组（拷贝），在处理大数据时会隐式引入性能陷阱。
3.  **显式拷贝**：如果你需要一份独立的数据副本（数组），请显式使用 `Type[$]`。这告诉阅读代码的人："这里发生了内存分配和拷贝"。

```cpp
// 默认：高效视图 (切片)
var view = [1, 2, 3]; 

// 显式：数据副本 (栈数组)
// 使用 [$] 占位符强制栈分配
int[$] copy = [1, 2, 3];
```

```cpp
// 切片变量（不分配内存，只引用）
int[] slice = arr; // 隐式转换：固定数组 -> 切片 (包含 arr^ 和 长度 5)

// 传递切片：仅复制 ptr 和 length，开销极小
func process(int[] data) { 
    data[0] = 99; // 修改原始数据
}
process(slice); 
// 此时 arr[0] 也变成了 99
```

## 2. 数组与指针的关系：优雅平衡

在 C^ 中，`int[N]`（数组）和 `int^`（指针）是截然不同的类型，但可以通过显式操作进行转换。

### 2.1 拒绝隐式退化

C 语言中 `int arr[5]` 在很多时候会自动变成 `int*`，导致 `sizeof` 失效和长度丢失。C^ **禁止**这种隐式退化，除非转换为保留长度信息的 `int[]` 切片。

```cpp
func process_ptr(int^ p) { ... }
func process_slice(int[] s) { ... }

int[5] arr;

// process_ptr(arr); // Error: 类型不匹配。int[5] 不是 int^
process_slice(arr);  // OK: int[5] 可以安全隐式转换为 int[] 切片
```

### 2.2 显式取指针

如果你确实需要裸指针（例如为了高性能或 C 互操作），必须显式使用后缀 `^` 取地址。

```cpp
// 显式获取数组首地址
int^ ptr = ^arr[0]; 

// 或者取特定元素地址
int^ p3 = ^arr[3];

process_ptr(^arr[0]); // OK: 显式传入首地址
```

### 2.3 动态数组（堆分配）

C^ 允许两种动态数组分配方式，以平衡安全性和底层控制。

1.  **返回切片 (推荐)**：`Type[] s = new Type[N];`
    *   保留长度信息，安全，支持 `delete s`。
2.  **返回裸指针 (C++ 兼容)**：`Type^ p = new Type[N];`
    *   **警告**：丢失长度信息！
    *   必须使用 `delete[] p` 释放。
    *   编译器会在内存头部隐含存储长度 (Cookie)。

```cpp
// 方式 A: 切片 (推荐)
int[] s = new int[5];
delete s; // 安全释放

// 方式 B: 裸指针 (C++ 模式)
// 只有当你需要模拟 C++ 行为时才使用
int^ p = new int[5]; 
delete[] p; // 必须使用 delete[]，否则 UB
```

## 3. 语法优势总结

| 特性         | C++ (`int*`, `int[N]`)   | C^ (`int^`, `int[N]`, `int[]`) |
| :----------- | :----------------------- | :----------------------------- |
| **声明**     | `int a[5]` (类型后置)    | `int[5] a` (类型前置，清晰)    |
| **参数传递** | 数组退化为指针，丢失长度 | 推荐传 `int[]` 切片，保留长度  |
| **指针获取** | 隐式退化 `p = arr`       | 显式取址 `p = ^arr[0]`         |
| **堆数组**   | `int* p = new int[5]`    | `int[] s` 或 `int^ p`          |
| **释放**     | `delete[] p`             | `delete s` 或 `delete[] p`     |

### 3.1 示例：安全的数组处理

```cpp
// 接收切片，安全且通用
func sum(int[] data) -> int {
    int s = 0;
    // foreach 自动利用切片的 length
    foreach (int x in data) {
        s += x;
    }
    return s;
}

func main() {
    int[10] stack_arr;       // 栈数组
    int[] heap_arr = new int[5]; // 堆数组

    // 统一调用，无缝衔接
    sum(stack_arr);          // 隐式转切片
    sum(heap_arr);           // 本身就是切片
    sum(stack_arr[2..5]);    // 子切片
    
    // 如果非要用指针操作（不安全模式）
    int^ p = ^stack_arr[0];
    // p[100] = 1; // 危险！越界且无检查
}
```

### 3.2 倒序索引与范围语法

C^ 采用 **`$`** 运算符表示“倒序索引”，以及 **`..` (Range)** 运算符表示范围。
（注：选择 `$` 而非 `^` 是为了避免与 C^ 特有的 **前缀 `^` 取地址** 操作符产生歧义）。

*   **`$N`**：倒数第 N 个元素。
    *   `$1` 是最后一个元素（`length - 1`）。
    *   `$0` 是数组长度（`length`）。**注意：** `$0` 作为索引访问会越界，但作为 Range 的右边界是合法的（表示“直到末尾”）。
*   **`..`**：范围操作符，生成切片。左闭右开 `[start, end)`。
    *   **省略 Start**：`arr[..end]` 默认从 0 开始。
    *   **省略 End**：`arr[start..]` 默认到 `$0` (即数组长度)。
    *   **全省略**：`arr[..]` 表示整个切片。

```cpp
int[] arr = [0, 1, 2, 3, 4, 5];

// 1. 倒序访问 (Index from end)
int last = arr[$1];      // arr[length-1] -> 5
int second_last = arr[$2]; // arr[length-2] -> 4

// 2. 范围切片 (Range)
// 语法：start..end
int[] sub1 = arr[1..4];    // [1, 2, 3] (索引 1, 2, 3)

// 3. 组合使用
int[] sub2 = arr[2..];     // [2, 3, 4, 5] (推荐：省略末尾，隐式使用 $0)
int[] sub3 = arr[..$1];    // [0, 1, 2, 3, 4] (从头开始，去掉最后一个)
int[] all  = arr[..];      // 全部 (0..$0)

// 4. 关于 $0 的设计说明
// arr[$0]    -> Error: IndexOutOfRange (试图访问 length 处的元素)
// arr[0..$0] -> OK: 等价于 arr[0..length] (包含所有元素)
// 
// 推荐写法：始终使用省略号 `..` 来表示“直到末尾”
// arr[1..]   -> 也就是 arr[1..$0] 的语法糖，最简洁且无歧义
int len = arr.length;
```

> **注意**：`$` 符号作为前缀操作符时表示倒序索引。为了避免语法歧义，C^ 规定变量名**不能以 `$` 开头**。

## 4. 多维数组 (Multidimensional Arrays)

C^ 区分**矩形数组 (Rectangular Arrays)** 和 **交错数组 (Jagged Arrays)**。

### 4.1 矩形数组 (Rectangular Arrays) - 推荐

矩形数组在内存中是**连续存储**的单一对象。这提供了最佳的缓存局部性 (Cache Locality) 和性能。

*   **语法**：`Type[d1, d2] var`。
*   **特性**：所有行长度相同。
*   **参数传递**：
    *   **作为切片传递 (`Type[,]`)**：这是一个包含运行时维度信息的胖指针（ptr + dims[0] + dims[1]）。适用于处理未知大小的子矩阵。
    *   **作为固定数组传递 (`Type[2, 3]`)**：**零开销**。因为维度在编译期已知，它退化为简单的指针传递（`ptr`），无需在运行时传递 `dims`。

```cpp
// 1. 声明与初始化 (栈上分配)
// 注意：使用嵌套的 [] 进行初始化
int[2, 3] matrix = [
    [1, 2, 3],
    [4, 5, 6]
];

// 自动推导栈数组大小
// int[$] 不够，必须用 int[$, $] 明确秩(Rank)
int[$, $] auto_matrix = [
    [1, 2],
    [3, 4]
]; // 推导为 int[2, 2]

// 2. 访问元素
// 语法：matrix[row, col]
int val = matrix[1, 2]; // 6

// 3. 作为参数传递

// 场景 A: 接受任意大小切片 (Fat Pointer)
// 内存布局: [ptr, dim0, dim1]
func print_slice(int[,] m) {
    // 运行时获取维度
    for (var i = 0; i < m.dim(0); i++) { ... }
}

// 场景 B: 接受固定大小数组 (Thin Pointer)
// 内存布局: [ptr]
// 维度信息 (2, 3) 编码在类型系统中，编译期已知
func print_fixed(int[2, 3] m) {
    // 编译期已知循环边界，可完全展开
    comptime for (var i = 0; i < 2; i++) { ... }
}

print_slice(matrix); // 隐式转换为切片 (构造胖指针)
print_fixed(matrix); // 直接传递指针 (零开销)
```

### 4.2 交错数组 (Jagged Arrays) - 数组的数组

交错数组是“元素为数组的数组”。每一行可以有不同的长度，内存不连续。

*   **语法**：`Type[][] var`。
*   **特性**：二次寻址 (Double Indirection)，灵活性高但性能稍逊。
*   **歧义消除**：
    *   `int[,]` 明确表示 **二维矩形切片** (Rank-2 Slice)。
    *   `int[][]` 明确表示 **切片的切片** (Slice of Slice)。
    *   这解决了 C# 中 `int[][]` 语义不明的问题。

```cpp
// 1. 声明与初始化
int[][] jagged = [
    [1, 2, 3],
    [4, 5]     // 长度不同
];

// 2. 访问元素
// 语法：jagged[row][col]
int val = jagged[1][0]; // 4

// 3. 参数传递
// 传递的是一个“切片的切片” (Slice of Slices)
// 包含：ptr, length (外层) -> 指向一组 inner_slice
// 每个 inner_slice 也包含自己的 ptr 和 length
// 优点：每行长度可以不同 (Jagged)
// 缺点：内存不连续，对缓存不友好
func process_jagged(int[][] data) { 
    print(data.length);    // 外层行数
    print(data[0].length); // 第一行的长度
}
```

### 4.3 设计对比

| 特性         | 矩形数组 `int[,]`             | 交错数组 `int[][]`            |
| :----------- | :---------------------------- | :---------------------------- |
| **内存布局** | 连续单块内存                  | 多个独立内存块 (数组指针数组) |
| **访问语法** | `m[i, j]`                     | `m[i][j]`                     |
| **性能**     | **极高** (缓存友好，一次寻址) | 较低 (二次寻址，缓存分散)     |
| **灵活性**   | 必须是矩形                    | 行长度可变                    |
| **典型用途** | 矩阵、图像、游戏地图          | 稀疏结构、字典桶              |

### 4.4 性能与传递建议

#### 1. 参数对象大小 (Parameter Size)

在 64 位系统下，作为参数传递时的“胖指针”大小对比：

*   **交错数组 (`int[][]`)**：**16 字节** (标准切片)。
    *   本质就是 `Slice<Slice<int>>`。
    *   结构：`ptr` (8B) + `length` (8B)。
    *   **注意**：虽然参数传递拷贝的数据量最小，但访问元素时需要**二次寻址**（解引用两次），且内存不连续，缓存命中率低。

*   **矩形数组 (`int[,]`)**：**~24 字节** (多维切片)。
    *   结构：`ptr` (8B) + `dims` (8B) + `strides` (8B)。
    *   **优势**：虽然参数稍大（多传 1 个寄存器），但数据访问是**一次寻址**，且支持高效的子矩阵切片（无需拷贝数据）。

#### 2. 传递建议

两者都极其轻量，**强烈建议按值传递 (Pass by Value)**。

*   **默认**：`func foo(int[,] m)` 或 `func foo(int[][] m)`。
*   **引用**：仅当你需要修改调用者的视图变量本身时，才使用 `&`。

```cpp
// 推荐：按值传递视图
func process(int[,] m) {
    // 拷贝的只是视图结构，数据本身还是指向同一块内存
    m[0, 0] = 99; // 修改有效
}
```

## 5. 容器与初始化 (Containers & Initialization)

C^ 鼓励**数据**与**对象**的初始化语法分离，以实现更高的语义清晰度。

*   **`[]`**：用于初始化**序列数据** (Arrays, Slices, Lists, Vectors)。
*   **`{}`**：用于初始化**对象/聚合** (Structs, Classes, Maps)。

### 5.2 初始化机制详解 (Initialization Mechanics)

关于用户关心的 `List<int> l = [1, 2, 3]` 和 `List<int> l { capacity= 100 }` 的底层逻辑，C^ 制定了明确的规则：

#### A. 为什么支持 `[]` 初始化？
这是基于**构造函数重载**。
`[1, 2, 3]` 本质上是一个 `int[]` 切片字面量。只要 `List<T>` 提供了一个接受 `T[]` 的构造函数，就能实现无缝对接。

```cpp
// 标准库 List 实现示意
class List<T> {
    // 构造函数重载：接受切片
    public List(T[] items) {
        // 分配内存并拷贝 items 内容
    }
}

List<int> list = [1, 2, 3]; // 调用 List(int[])
```

#### B. 为什么支持 `{}` 初始化？
这是基于**对象初始化器 (Object Initializer)** 语法糖。
`{ key: value }` 语法并不调用带参构造函数，而是**先调用默认构造函数，再调用属性 Setter**。

```cpp
// 标准库 List 实现示意
class List<T> {
    public List() { ... } // 默认构造
    
    // capacity 属性 setter
    public set  capacity(int size)->size=>self.capacity=size;
        
}

// 语法糖展开：
// var temp = List<int>(); // 1. 默认构造
// temp.capacity = 100;    // 2. 属性赋值
// List<int> list = temp;
List<int> list { capacity= 100 };
```

**设计总结**：
*   **`[]`** 映射到 **构造函数参数**（通常是切片）。
*   **`{}`** 映射到 **默认构造 + 属性赋值**。
*   两者逻辑清晰，互不干扰。

### 5.3 栈数组初始化与语法决策 (Stack Array & Syntax Decision)

针对开发者常问的 **"为什么不使用 C++ 风格的花括号 `{}` 初始化数组？"**，我们有明确的设计考量：

#### 1. 拒绝 `{}` 用于数组
在 C^ 中，`{}` 被严格保留用于 **对象/结构体** 的属性初始化（见上文）。如果允许 `int[] a = {1, 2}`，会导致语法歧义和心智负担。我们坚持 **"序列用 `[]`，对象用 `{}`"** 的原则。

#### 2. 栈内存 `byte[]` 初始化
对于栈上的固定大小数组，直接使用 `[]` 字面量即可。

```cpp
// 1. 显式指定类型和大小 (推荐用于 byte)
// 编译器自动检查字面量是否适配 byte 范围
byte[3] b1 = [0x01, 0x02, 0x03]; 

// 2. 自动推导 (推导为 int[3])
var i1 = [1, 2, 3]; 

// 3. 混合使用 (错误示范)
// byte[3] b2 = {1, 2, 3}; // Error: Expected object initializer, found sequence
```

#### 3. 特殊语法：字符串转栈数组
如前所述，`byte` 数组配合字符串字面量有特殊规则：

```cpp
// 1. 切片 (Slice) - 推荐
// byte[] 本身就是切片类型，s 指向 .rodata，零拷贝
byte[] s = "hello"; 

// 2. 栈数组 (Stack Array) - 使用 [$] 占位符
// [$] 表示 "请帮我推导数组长度"
// 行为：栈上分配 6 个字节 (含\0)，拷贝 "hello"
byte[$] buf = "hello"; 
```

这明确区分了 **"引用/视图"** (`[]`) 和 **"拥有/拷贝"** (`[$]`) 的语义。


### 4.1 动态数组声明

* **语法**：`type[] array_name;`
* **分配**：使用 `new` 关键字分配动态数组
* **释放**：使用 `delete` 释放动态数组 (废除 `delete[]`)

```cpp
// 动态数组声明
int[] dynamic_arr;

// 分配动态数组
dynamic_arr = new int[5];

// 初始化
for (int i = 0; i < 5; i++) {
    dynamic_arr[i] = i + 1;
}

// 释放动态数组
delete dynamic_arr; // 编译器自动识别切片长度，执行析构
```

### 4.2 动态数组与智能指针

* **unique_ptr**：使用 `unique_ptr<int[]>` 管理动态数组
* **自动释放**：智能指针离开作用域时自动释放

```cpp
// 使用 unique_ptr 管理动态数组
unique_ptr<int[]> arr = new int[5];

// 初始化
for (int i = 0; i < 5; i++) {
    arr[i] = i + 1;
}

// 自动释放，无需手动 delete
```

## 5. 内存释放规则 (Critical)

**核心原则：禁止通过裸指针释放数组。**

在 C^ 中，由于 `new Type[N]` 返回的是携带长度的切片 (`Type[]`)，因此 `delete slice` 能够正确工作。

然而，如果你将切片显式转换为裸指针 (`Type^`)，你就**丢弃了长度信息**。此时，编译器无法知道需要调用多少次析构函数，也无法通知分配器释放正确大小的内存。

*   **合法**：`delete slice;` (切片包含长度，安全)
*   **合法**：`delete ptr;` (释放单个对象，安全)
*   **非法**：`delete ptr_to_array;` (通过裸指针释放数组 -> **未定义行为 / 编译报错**)
*   **合法 (C++ 模式)**：`delete[] ptr_to_array;` (编译器读取头部 Cookie 长度)

```cpp
int[] slice = new int[10];
int^ ptr = slice^; // 显式获取裸指针（丢弃长度）

delete slice; // OK: 正确释放数组
// delete ptr; // Error/UB
delete[] ptr; // OK: 编译器生成代码读取头部长度信息
```

### 5.1 单元素对象的特例

如果你的裸指针指向的是使用 `new Type` 分配的**单个对象**（而非数组），那么 `delete ptr` 是完全合法的。

```cpp
// 场景 A：单个对象
int^ p1 = new int(42);
delete p1; // OK: 释放单个对象

// 场景 B：单元素数组
int[] arr = new int[1]; // 返回切片
int^ p2 = arr^;         // 获取裸指针
// delete p2;           // Error: p2 指向的是数组内存（即使只有一个元素），不能按单个对象释放
delete arr;             // OK: 通过切片释放
```

## 6. 总结

C^ 的数组设计通过引入 **切片 (`Type[]`)** 作为一等公民，完美平衡了：
1.  **栈数组 (`Type[N]`)** 的零开销。
2.  **指针 (`Type^`)** 的底层控制力。
3.  **安全性**：默认使用带长度的切片，拒绝数组隐式退化为裸指针。
