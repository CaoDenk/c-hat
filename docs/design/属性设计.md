# C^ 属性设计文档 (Property Design)

## 1. 设计核心：分离式访问器 (Separated Accessors)

根据 C^ 的设计哲学（类似函数，显式参数），我们采用 **分离式访问器** 语法。这种设计将 `get` 和 `set` 视为独立的方法声明，具有以下优势：

1.  **无需 `value` 关键字**：Setter 的参数名由用户显式定义（如 `id`、`val`），语义更清晰，避免了隐式 `value` 的“魔法”。
2.  **函数式一致性**：语法结构与普通函数 `func` 高度一致，解析规则统一。
3.  **灵活的访问控制**：可以轻松为 get 和 set 设置不同的修饰符，甚至定义在文件的不同位置（虽然不推荐）。

## 2. 语法规范

### 2.1 语法定义

属性不再是一个块状结构，而是由两个特殊的方法组成：

```ebnf
// Getter 声明
get_declaration ::= access_modifier? 'get' identifier return_type? (function_body | '=>' expression ';')

// Setter 声明
set_declaration ::= access_modifier? 'set' identifier '(' parameter ')' (function_body | '=>' expression ';')
```

### 2.2 示例代码

```cpp
public class Person {
    // 1. 显式后备字段 (Backing Field)
    private int _id;

    // 2. Getter 定义
    // 语法：get 属性名 -> 返回类型 { ... }
    public get Id -> int {
        return _id;
    }
    // 简写形式 (Expression-bodied)
    // 类型推导：如果省略 -> int，编译器尝试从表达式推导
    public get Id => _id; 

    // 3. Setter 定义
    // 语法：set 属性名(参数类型 参数名) { ... }
    // 优势：参数名 'newId' 是显式的，不需要 value 关键字
    public set Id(int newId) {
        if (newId >= 0) {
            _id = newId;
        }
    }
    // 简写形式
    public set Id(int v) => _id = v;
}
```

## 3. 设计决策问答

*   **分离式风格**：强调“显式控制”。你声明了 `_id`，然后在 `get/set` 中使用它。逻辑非常直观。
*   **块状风格 (C#)**：因为属性被包裹在一个块里，为了偷懒不写字段声明，才发明了 `field` 关键字。

既然我们选择了分离式，显式声明 Backing Field (`private int _id`) 是更自然的做法，也符合 C++ 开发者习惯。

### Q2: 既然是分离的，如何表示这是一个“属性”？

通过 **命名约定** 和 **编译器元数据**。

*   当编译器看到 `get Id` 和 `set Id` 时，会将它们识别为属性 `Id` 的组成部分。
*   在使用端（Call Site），语法保持属性风格：
    ```cpp
    Person p;
    p.Id = 100; // 编译器自动重写为 p.set_Id(100)
    print(p.Id); // 编译器自动重写为 p.get_Id()
    ```

### Q3: 自动属性 (Auto Properties) 怎么办？

**结论：不支持。**

C^ 坚持 **"显式优于隐式" (Explicit is better than Implicit)** 的原则。

*   **透明性**：程序员应该清楚地知道对象占用了多少内存，字段布局是怎样的。编译器自动生成隐藏字段（Backing Field）违背了这一原则。
*   **替代方案**：
    *   如果只是简单的读写，直接使用 `public` 字段即可（POD 风格）。
    *   如果需要封装，请显式声明私有字段和 get/set 访问器。

```cpp
// 推荐写法：显式且透明
public class Person {
    private int _id;
    public get Id => _id;
    public set Id(int v) => _id = v;
}
```

## 4. 完整场景演示

```cpp
public class Window {
    // 私有字段
    private int _width;
    private int _height;

    // 构造函数
    public Window(int w, int h) {
        _width = w;
        _height = h;
    }

    // 宽度属性
    public get Width -> int => _width;
    public set Width(int w) => _width = w;

    // 高度属性
    public get Height -> int => _height;
    public set Height(int h) => _height = h;

    // 计算属性：面积 (只有 Getter)
    public get Area -> int => _width * _height;
    
    // 静态属性
    private static int _globalCount;
    public static get GlobalCount => _globalCount;
}
```

## 5. 总结

采用分离式设计 (`get Name` / `set Name`) 是 C^ 向“清晰性”和“一致性”迈出的一步。

*   **摒弃了**：`value` 隐式关键字、嵌套的 `{ get; set; }` 块结构、复杂的 `field` 作用域规则。
*   **拥抱了**：类似 `func` 的自然语法、显式的参数命名、清晰的字段控制。

这使得 C^ 的类定义更加扁平，阅读体验更接近 C++，但在使用体验上保持了 C# 属性的便捷性。
