# C^ 错误处理设计文档

C^ 的错误处理哲学是：**区分"可恢复的逻辑结果"与"不可恢复的运行时异常"**。我们不希望像 Java 那样滥用异常作为控制流，也不希望像 C 那样只检查错误码。

## 1. 异常处理 (Exceptions)

C^ 保留了经典的 `try-catch` 机制，移除了 `finally` 块（由 `defer` 和 RAII 替代）。采用了 **零开销 (Zero-cost)** 的实现策略，并对其进行了现代化约束。

### 1.1 性能设计：基于表的异常处理 (Table-based)

C^ 采用与现代 C++ (Itanium ABI) 类似的**基于表的异常处理机制**。

*   **Happy Path 零开销**：只要不抛出异常，进入 `try` 块**没有任何运行时指令开销**。不需要像 `setjmp/longjmp` 那样保存寄存器。
*   **抛出代价**：只有在 `throw` 发生时，运行时才会去查找异常表（Exception Table）来展开栈（Stack Unwinding）。
*   **适用场景**：因此，异常应当用于**真正的异常情况**（如 IO 错误、网络中断），而不是用于常规的控制流（如查找失败）。

### 1.2 异常类型体系：继承 vs 契约

在 C^ 中，**异常采用强制继承体系**，而非协程那样的 Duck Typing 契约。

*   **为什么不用契约 (Duck Typing)？**
    *   **运行时分发**：异常匹配 (`catch`) 发生在运行时栈展开阶段。运行时系统 (Unwinder) 需要统一的 ABI 和 RTTI (运行时类型信息) 来判断类型兼容性。
    *   **效率**：如果允许抛出任意满足契约的类型，编译器需要生成巨大的元数据表，严重拖累二进制大小和抛出性能。
    *   **通用捕获**：我们需要 `catch (Exception^ e)` 这种通用写法，这要求所有异常有共同的基类。

*   **规则**：所有可抛出的对象**必须**继承自 `std::Exception` 类。

```cpp
// 基础异常类 (标准库提供)
class Exception {
public:
    virtual string message { get; }
    virtual string stack_trace { get; }
    virtual ~ { }
}

// 用户自定义异常
class NetworkError : public Exception {
public:
    NetworkError(string msg) : base(msg) {}
}
```

### 1.2 语法结构

```cpp
try {
    risky_operation();
} catch (NetworkError^ e) {
    // 捕获特定异常 (引用类型)
    log(e->message);
} catch (Exception^ e) {
    // 捕获所有异常
    // 在 C^ 中，catch 捕获的通常是指针或引用，避免切片问题
}
// 注意：C^ 移除了 finally 块。
// 资源清理请使用 defer 或 RAII (析构函数)。
```

### 1.3 异常说明 (Exception Specification)

C^ **不采用** Java 的 Checked Exceptions（强制 `throws` 声明），因为实践证明它会导致 API 演进困难和空的 catch 块。

但是，为了极致的性能优化，C^ **引入了 `noexcept` 关键字**。

#### 1.3.2 设计决策：为什么是关键字而不是属性 (Attribute)？

在设计 C^ 时，我们对比了使用关键字 `noexcept` 和属性 `[NoExcept]` 两种方案：

1.  **条件性支持 (Conditional Support)**：
    *   泛型编程中经常需要根据模板参数决定是否抛出异常（例如：`std::vector<T>` 的移动操作）。
    *   关键字方案 `noexcept(expr)` 能优雅地嵌入布尔表达式。
    *   属性方案 `[NoExcept(expr)]` 虽然可行，但对于复杂的编译期逻辑表达显得笨重且不自然。

2.  **类型系统集成 (Type System)**：
    *   在 C^ 中，异常规范是函数类型的一部分（类似于 C++17）。
    *   `func() -> void` 和 `func() -> void noexcept` 是不同的函数类型。前者可以赋值给后者（协变），但反之不行。
    *   关键字作为类型修饰符，比依附于声明的“元数据属性”更能体现这一语义。

3.  **操作符复用**：
    *   `noexcept` 同时也是一个编译期操作符：`bool safe = noexcept(expr);`。使用关键字保持了“修饰符”与“操作符”的同源性。

#### 1.3.3 放置位置

为了保持函数签名的清晰性，并与 `where` 子句逻辑一致，`noexcept` 放置在**返回类型之后**。

```cpp
// 推荐位置：后缀风格
func swap(int& a, int& b) -> void noexcept { ... }

// 读取顺序：
// 1. 函数名为 swap
// 2. 接受两个引用参数
// 3. 返回 void
// 4. 且保证不抛出异常
```

---

## 2. 结果类型 (Result Pattern)

对于**预期的、频繁发生的**逻辑分支（如查找字典失败、解析字符串失败），C^ 推荐使用标准库提供的 `Result<T, E>` 或 `Option<T>`，而不是抛出异常。

### 2.1 `Optional<T>` (可空值)

用于表示“可能没有值”的情况。C^ 统一使用 `Optional<T>` 处理值类型和指针的可空性。

```cpp
func find_user(int id) -> Optional<User> {
    if (exists(id)) return User(id);
    return Optional<User>::None;
}

// 使用 match 处理
match (find_user(100)) {
    case Some(u) => print(u.name),
    case None    => print("Not found")
}
```

### 2.2 `Result<T, E>` (操作结果)

用于明确可能失败的操作，且调用者**必须**处理这个失败。

```cpp
func parse_int(string s) -> Result<int, ParseError> {
    if (is_digit(s)) return 123;
    return ParseError("Invalid digit");
}

// 链式调用 (Monadic operations)
// 如果成功则 +1，否则传递错误
var res = parse_int("123").map(x => x + 1);

// 2.3 错误传播操作符 (?)
// C^ 引入了后缀 `?` 操作符，用于简化 Result 的传播（类似 Rust）
func process_data(string s) -> Result<int, ParseError> {
    // 如果 parse_int 失败，直接返回错误
    // 如果成功，unwrapped_val 为 int
    int val = parse_int(s)?; 
    return val * 2;
}
```

### 2.3 语法糖：后缀 `?` 运算符 (Result Propagation)

为了让 `Result` 的使用体验达到 Rust/Kotlin 的流畅度，C^ 引入后缀 `?` 运算符（替代了早期的前缀 `try` 设计）。

*   **语义**：如果表达式结果是 `Error`，则立即从当前函数返回该 `Error`；如果是 `Ok(val)`，则解包出 `val` 继续执行。
*   **链式调用**：后缀设计使得链式调用非常自然，无需嵌套括号。

```cpp
func read_config() -> Result<Config, Error> {
    // 1. 打开文件，失败则直接 return Error
    var file = File::open("config.ini")?;
    
    // 2. 链式调用：读取 -> 解析 -> 获取结果
    // 任何一步失败都会立即返回错误
    return file.read_all()?.parse_json()?.to_config();
}
```

对比前缀 `try` 写法（已废弃）：
```cpp
// ❌ 废弃：前缀 try 在链式调用时需要括号
return (try (try file.read_all()).parse_json()).to_config();
```

---

## 3. 资源管理 (RAII vs defer)

C^ 是一门系统语言，核心资源管理机制是 **RAII (Resource Acquisition Is Initialization)**。

### 3.1 析构函数 (Destructors)
绝大多数资源（文件句柄、锁、内存）应封装在类中，通过析构函数 `~ { ... }` 自动释放。

```cpp
{
    FileHandle f("test.txt");
    // 离开作用域，f.~() 自动调用，文件关闭
}
```

### 3.2 `defer` 语句 (Go-style)

虽然 RAII 是正道，但在处理复杂的 C 风格资源（如多个裸指针句柄）时，`defer` 非常方便。C^ 将 `defer` 提升为**一等公民关键字**。

```cpp
func process_raw_handles() {
    FILE^ f = fopen(...);
    if (f == null) return;
    defer fclose(f); // 退出作用域时执行 (无论正常返回还是抛出异常)
    
    void^ mem = malloc(1024);
    defer free(mem);
    
    if (error) return; // 自动调用 free, fclose
}
```

### 3.3 RAII 与 Defer 的执行顺序

C^ 将 `defer` 视为**匿名的 RAII 对象**。因此，资源释放严格遵循**后进先出 (LIFO)** 的栈解退规则，无论是显式对象还是 `defer` 语句。

```cpp
{
    File f1("a.txt"); // 1. 构造 f1
    defer print("1"); // 2. 注册 defer 1
    
    File f2("b.txt"); // 3. 构造 f2
    defer print("2"); // 4. 注册 defer 2
}
// 退出作用域时的执行顺序：
// 1. 执行 defer "2"
// 2. 析构 f2
// 3. 执行 defer "1"
// 4. 析构 f1
```

这种统一的顺序模型消除了由混合使用带来的不确定性。

---

## 4. 断言 (Assertions)

### 4.1 `assert`
仅在 Debug 模式下生效。用于检查不变量。

### 4.2 `ensure` / `require` (契约编程)
C^ 支持基本的契约编程语法，用于文档化和运行时检查函数的前置/后置条件。

```cpp
func divide(int a, int b) -> int 
    require(b != 0) // 前置条件：调用者负责
    ensure(result * b == a) // 后置条件：实现者负责
{
    return a / b;
}
```

---

## 5. 总结：如何选择？

C^ 将选择权交给开发者，但提供明确的最佳实践建议：

| 场景                     | 推荐机制              | 理由                                                       |
| :----------------------- | :-------------------- | :--------------------------------------------------------- |
| **文件不存在、网络超时** | `Exception`           | 外部环境导致，不可控，且后续流程无法继续。                 |
| **字典 Key 不存在**      | `Option<T>`           | 这是一个预期的逻辑分支，不是错误。                         |
| **JSON 解析失败**        | `Result<T, E>`        | 调用者通常需要处理解析错误（如提示用户），且发生频率较高。 |
| **数组越界、空指针解引** | `Panic` / `Exception` | 这是代码 Bug，属于不可恢复的错误。                         |
| **C 语言接口调用**       | `defer`               | 配合裸指针资源管理。                                       |

*   **系统级/库内部**：倾向于使用 `Exception` 处理致命错误。
*   **业务逻辑/API**：倾向于使用 `Result/Option` 显式表达成功/失败。
