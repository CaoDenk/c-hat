
# 字符串设计文档

## 概述

本文档解释 C^ 语言中字符串的设计理念、实现方式以及与 C 库互操作的机制。

## 核心设计

### 1. LiteralView 结构体

字符串字面量在 C^ 中被表示为 `LiteralView` 结构体：

```c
struct LiteralView {
    byte!^ ptr;  // 指向字符串数据的指针
    int64 len;   // 字符串长度（不包含 null 终止符）
}
```

### 2. 字符串字面量生成

当代码中出现字符串字面量时，编译器会：
1. 在全局内存中创建 null 终止的字符串数据
2. 创建一个 `LiteralView` 结构体，包含指向该数据的指针和长度

## 与 C 库互操作

### 当前实现方案

**编译器默认转换（已实现）**：
- 在 `generateCallExpr` 函数中，当检测到参数是 `LiteralView` 类型时，自动提取 `ptr` 字段传递给 C 函数
- 优点：简单直接，用户可以直接传递字符串字面量给 C 函数
- 缺点：这是一个特殊处理，不够通用

### 标准库设计方案

**利用隐式转换运算符**：
- 标准库 `std.core.LiteralView` 提供了两个隐式转换：
  1. `implicit operator byte![]()` - 转换为只读切片
  2. `implicit operator byte!^()` - 转换为只读指针

```c
extension LiteralView {
    public implicit operator byte![]() {
        return { ptr = self.ptr, len = self.len };
    }
    
    public implicit operator byte!^() {
        return self.ptr;
    }
}
```

## 两种方案的比较

### 方案一：编译器默认转换（当前）

**优点**：
- 简单直接，用户体验好
- 不需要实现复杂的隐式转换逻辑
- 性能好，没有额外的函数调用开销

**缺点**：
- 特殊处理，违反语言的一致性
- 只适用于 LiteralView，其他类型无法享受类似机制
- 不够灵活，用户无法自定义转换行为

### 方案二：标准库隐式转换（理想）

**优点**：
- 符合语言设计原则，通过扩展和隐式转换实现
- 通用机制，其他类型也可以使用
- 灵活，用户可以自定义转换行为

**缺点**：
- 需要实现隐式转换的代码生成逻辑
- 可能有轻微的性能开销（函数调用）
- 实现复杂度较高

## 推荐方案

**短期（已实现）**：使用编译器默认转换方案
- 快速实现，满足基本需求
- 确保与 C 库的互操作正常工作

**长期（目标）**：实现标准库隐式转换方案
- 完善语言的类型系统
- 提供更通用、更灵活的机制
- 保持语言的一致性和优雅性

## 当前实现细节

### 代码生成器中的处理

在 `src/llvm/LLVMCodeGenerator.cpp` 的 `generateCallExpr` 函数中：

```cpp
for (auto &arg : callExpr->args) {
    llvm::Value *argVal = generateExpression(std::move(arg));
    
    // 检查是否是 LiteralView 类型
    if (argVal->getType()-&gt;isStructTy()) {
        auto *structType = llvm::dyn_cast&lt;llvm::StructType&gt;(argVal-&gt;getType());
        if (structType &amp;&amp; structType-&gt;getName() == "LiteralView") {
            // 提取 ptr 字段
            argVal = builder()-&gt;CreateExtractValue(argVal, 0, "literalview_ptr");
        }
    }
    
    args.push_back(argVal);
}
```

## 示例代码

### 调用 C 函数

```c
extern "C" {
    func puts(byte!^ s) -> int32;
}

func main() -> int32 {
    puts("Hello from c-hat!");  // 自动转换为指针
    return 0;
}
```

## 总结

当前实现通过编译器的特殊处理，使得字符串字面量可以直接传递给 C 函数。长期目标是实现完整的隐式转换机制，让标准库来处理这些转换，从而保持语言的一致性和优雅性。

