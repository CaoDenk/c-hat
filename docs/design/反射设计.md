# C^ 静态反射设计文档

## 1. 设计哲学

C^ 的反射机制是**纯静态（Compile-time）**的。与 Java/C# 的运行时反射不同，C^ 的反射在编译期完成所有元信息的解析和代码生成。

## 2. 核心语法：`@` 操作符与 `typeof` 关键字

我们将 **类型获取** 与 **元数据获取** 分离，实现更优雅的正交设计。

### 2.1 类型操作符：`typeof(expr)`

`typeof` 是一个 **关键字**，用于在编译期获取表达式的类型。它返回的是一个 **类型 (Type)**，可以用于变量声明、泛型参数等。

```cpp
int a = 10;
typeof(a) b = 20; // 等价于 int b = 20;
List<typeof(a)> list; // 等价于 List<int>
```

### 2.2 反射操作符：`@`

`@` 是一个 **前缀运算符**，用于获取类型或实体的 **元数据 (Metadata)**。它返回一个编译期常量对象（如 `std::meta::Type`）。

*   语法：`@Type`
*   组合：`@typeof(expr)` —— 先获取类型，再获取该类型的元数据。
*   优先级：`@` 的优先级 **高于** 成员访问符 `.` (Level 0)，因此 `@T.name` 会被解析为 `(@T).name`。

```cpp
struct User { int id; }
int a = 10;

// 1. 获取命名类型的元数据
comptime TypeInfo info1 = @User;

// 2. 获取表达式类型的元数据 (组合使用)
comptime TypeInfo info2 = @typeof(a); 

// 3. 错误示例
// comptime TypeInfo info3 = @a; // 错误！@ 操作符作用于类型，而非值
```

这种设计的优势在于：
1.  **正交性**：`typeof` 负责类型系统，`@` 负责反射系统。
2.  **清晰性**：`@typeof(a)` 明确表达了“获取 a 的类型的元数据”这一语义。
3.  **扩展性**：`@` 未来可以扩展用于获取函数、模块的元数据（如 `@func_name`）。

### 2.3 元对象协议 (MOP) 与 鸭子类型 (Duck Typing)

C^ 的反射系统采用**编译期鸭子类型 (Compile-time Duck Typing)** 设计。

*   **匿名元类型**：`@T` 返回的不是一个固定的 `std.meta.Type` 类实例，而是一个**编译器生成的匿名类型**（如 `__meta_User`）。
*   **结构化接口**：这些匿名类型隐式满足标准库定义的**元概念 (Meta Concepts)**。

这意味着元数据对象是**多态**的，但这种多态发生在编译期。

```cpp
// 概念定义 (伪代码)
concept MetaType {
    comptime string name;
    comptime bool is_struct;
    // ...
}

concept MetaStruct : MetaType {
    comptime auto fields; // 返回满足 MetaField 概念的集合
}

// 鸭子类型的使用
func print_meta_name(comptime auto meta) {
    // 只要 meta 有 name 字段即可，无需继承自特定基类
    comptime print(meta.name); 
}
```

### 2.4 `@` 操作符不可重载

`@` 是编译器内置的反射操作符，**不允许用户重载**。这保证了反射入口的统一性。

但用户可以通过以下方式扩展“协议”：
1.  **扩展方法 (Extension Methods)**：为元类型定义扩展方法。
2.  **属性 (Attributes)**：注入自定义元数据。

## 3. 编译期控制流

### 3.1 编译期遍历：`comptime for`

摒弃奇怪的 `@foreach`，直接复用 `for` 循环，加上 `comptime` 标记，表示这是**编译期展开**。

```cpp
func print_fields<T>(T! obj) {
    // 编译期遍历 T 的所有字段
    // 编译器会将此循环展开为一系列顺序执行的语句
    comptime for (var field : @T.fields) {
        // 生成代码：print("id: " + obj.id);
        // 生成代码：print("name: " + obj.name);
        print(field.name + ": " + obj.@[field]); 
    }
}
```

## 4. 标准元数据定义 (Standard Metadata)

标准库 `std.meta` 模块定义了反射对象必须满足的**元概念 (Meta Concepts)**。编译器生成的元数据对象必须遵循这些协议。

### 4.1 基础元类型 (`MetaType`)

所有类型的元数据（`@T`）都满足 `MetaType` 概念。

```cpp
namespace std.meta;

concept MetaType {
    // 类型名称 (如 "int", "List<string>")
    comptime string name;
    
    // 类型分类断言 (互斥或组合)
    comptime bool is_struct;
    comptime bool is_class;
    comptime bool is_enum;
    comptime bool is_union;
    comptime bool is_function;
    
    // 引用与指针属性
    comptime bool is_reference; // 是否为引用类型 (T&, T!&)
    comptime bool is_pointer;   // 是否为指针类型 (T^, T!^)
    
    // 属性列表 (异构元组，存储所有附加的 Attribute 对象)
    // 采用鸭子类型设计，不强制继承特定基类
    comptime auto attributes;
}

### 4.2 引用类型的特殊属性

对于引用类型（如 `int&`），元数据提供对底层类型的访问。

```cpp
concept MetaReference : MetaType {
    // 只有当 is_reference 为 true 时有效
    comptime bool is_mutable; // true: T&, false: T!&
    comptime type target_type; // 引用的目标类型 (如 int)
}
```
