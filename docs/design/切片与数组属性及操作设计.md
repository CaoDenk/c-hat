# C^ 切片与数组属性及操作设计文档

## 1. 概述

本文档完善 C^ 中切片和数组的基本属性、操作符及内存管理设计，统一数组与切片的使用体验。

### 1.1 设计原则

1. **统一访问**：数组和切片在访问方式上保持一致（都是下标访问）
2. **简洁实用**：去除不必要的属性和复杂性
3. **显式控制**：重要操作需要显式表达（如深拷贝）
4. **灵活扩展**：操作符重载由标准库实现，编译器只提供基础设施

---

## 2. 基本属性

### 2.1 统一属性：`len`

**数组和切片都有 `len` 属性，表示元素个数**：

```cpp
// ========== 数组的 len 属性 ==========
int[3] arr = [1, 2, 3];
println(arr.len); // 3

// ========== 切片的 len 属性 ==========
int[] slice = arr;
println(slice.len); // 3

// ========== 只读切片的 len 属性 ==========
var const_slice = [1, 2, 3];
println(const_slice.len); // 3
```

**设计说明：**
- `len` 是只读属性（get-only），不能修改
- 数组和切片的 `len` 属性在访问方式上完全一致
- `len` 的类型是 `usize` 或 `int`（取决于具体设计）

### 2.2 指针属性：`ptr`

**数组和切片都有 `ptr` 属性，指向数据的指针**：

```cpp
// ========== 数组的 ptr 属性 ==========
int[3] arr = [1, 2, 3];
println(arr.ptr); // 指向 arr[0] 的指针

// ========== 切片的 ptr 属性 ==========
int[] slice = arr;
println(slice.ptr); // 指向 arr[0] 的指针，与 arr.ptr 相同

// ========== 只读数组/切片的 ptr 属性 ==========
readonly int[3] const_arr = [1, 2, 3];
println(const_arr.ptr); // 指向 const_arr[0] 的 const 指针
readonly int[] const_slice = const_arr;
println(const_slice.ptr); // 指向 const_arr[0] 的 const 指针
```

**设计说明：**
- `ptr` 是只读属性（get-only），不能修改
- 数组的 `ptr` 属性直接指向数组的首地址
- 切片的 `ptr` 属性指向切片引用的数据首地址
- 当数组/切片是 `readonly` 时，`ptr` 也是 `const` 指针

### 2.2 不需要 `cap` 属性

**不设计 `cap`（容量）属性**：

| 属性  | 是否需要 | 理由                              |
| ----- | -------- | --------------------------------- |
| `len` | ✅ 需要   | 表示元素个数，是基本属性          |
| `cap` | ❌ 不需要 | 可以通过 `sizeof(T) * t.len` 计算 |

**计算示例：**

```cpp
int[] slice = [1, 2, 3];

// 如果需要知道总字节数
var total_bytes = sizeof(int) * slice.len; // 3 * 4 = 12 bytes

// 如果需要内存大小
var memory_size = slice.len * sizeof(typeof(slice[0])); // 通用写法
```

**设计理由：**
- 避免不必要的复杂性
- 用户可以通过简单计算获得相同信息
- 保持语言核心简洁

---

## 3. 切片与数组的关系

### 3.1 设计哲学：统一访问

**核心设计思想**：
- **访问方式统一**：数组和切片都用下标访问 `arr[i]`
- **属性统一**：数组和切片都有 `len` 属性
- **区别只在内存布局和所有权**：
  - 数组：值类型，拥有数据，栈上分配
  - 切片：视图类型，不拥有数据，只是引用

### 3.2 数组转切片时的属性

当数组隐式转换为切片时，切片具有 `ptr` 属性：

```cpp
int[3] arr = [1, 2, 3];

// 数组隐式转换为切片
int[] slice = arr;

// 切片有 ptr 属性（只读）
println(slice.ptr); // 指向 arr[0] 的指针

// slice.ptr = xxx; // Error: ptr 是只读属性，不能修改

// 数组没有 ptr 属性（这是设计选择）
// println(arr.ptr); // Error: 数组没有 ptr 属性

// 如果需要数组的指针，显式取地址
int^ p = ^arr[0]; // 显式取第一个元素的地址
```

**设计说明：**
- 只有切片有 `ptr` 属性
- `ptr` 是只读属性（get-only），不能修改
- 数组没有 `ptr` 属性，保持值类型的纯粹性
- 需要数组指针时，用 `^arr[0]` 显式获取

**为什么保留 `ptr` 属性？**
1. **C 互操作方便**：经常需要把切片传递给 C 函数
2. **清晰表达意图**：`slice.ptr` 明确表示"我要切片的指针"
3. **对称完整**：和 `len` 属性配对，逻辑上完整

---

## 4. 切片比较：操作符重载

### 4.1 比较操作符由标准库实现

**切片的 `==` 和 `!=` 比较操作符不是编译器内置的**，而是由标准库通过操作符重载实现：

```cpp
// ========== 标准库中的实现示意 ==========
extension<T> T[] {
    // 重载 == 操作符
    public static func operator==(T[] lhs, T[] rhs) -> bool {
        if (lhs.len != rhs.len) {
            return false;
        }
        for (var i = 0; i < lhs.len; i++) {
            if (lhs[i] != rhs[i]) {
                return false;
            }
        }
        return true;
    }
    
    // 重载 != 操作符
    public static func operator!=(T[] lhs, T[] rhs) -> bool {
        return !(lhs == rhs);
    }
}
```

### 4.2 使用示例

```cpp
int[] a = [1, 2, 3];
int[] b = [1, 2, 3];
int[] c = [1, 2, 4];

// 使用重载的 == 操作符
println(a == b); // true
println(a == c); // false

// 使用重载的 != 操作符
println(a != b); // false
println(a != c); // true
```

### 4.3 指针比较 vs 内容比较

**如果需要比较指针（是否引用同一块内存）**，显式比较 `ptr`：

```cpp
int[3] arr = [1, 2, 3];
int[] slice1 = arr;
int[] slice2 = arr;

// 比较内容
println(slice1 == slice2); // true（内容相同）

// 比较指针（是否引用同一块内存）
println(slice1.ptr == slice2.ptr); // true（指针相同）
```

---

## 5. 切片拷贝

### 5.1 默认是浅拷贝

**切片赋值默认是浅拷贝**，只拷贝 `ptr` 和 `len`：

```cpp
int[3] arr = [1, 2, 3];
int[] slice1 = arr;

// 浅拷贝：只拷贝 ptr 和 len
int[] slice2 = slice1;

// slice1 和 slice2 引用同一块内存
slice2[0] = 99;
println(slice1[0]); // 99（slice1 也被修改了）
```

**内存布局图解：**
```
栈内存
┌─────────────────────────┐
│  [1, 99, 3]           │ ← arr（原始数组）
└─────────────────────────┘
         ↑
         │
    ┌───────────────┐    ┌───────────────┐
    │ slice1:       │    │ slice2:       │
    │ ptr: ----------→    │ ptr: ----------→
    │ len: 3        │    │ len: 3        │
    └───────────────┘    └───────────────┘
      slice1 和 slice2 都指向同一个 arr
```

### 5.2 深拷贝：显式使用 memcpy

**如果需要深拷贝（复制内容）**，显式使用 `memcpy`（或标准库提供的函数）：

```cpp
import std; // 假设标准库提供 memcpy

int[3] arr = [1, 2, 3];
int[] slice1 = arr;

// 1. 分配新内存
int[3] new_arr; // 或者用 new 分配堆内存
int[] slice2 = new_arr;

// 2. 显式深拷贝
memcpy(slice2.ptr, slice1.ptr, sizeof(int) * slice1.len);

// 现在 slice1 和 slice2 是独立的
slice2[0] = 99;
println(slice1[0]); // 1（slice1 没有被修改）
println(slice2[0]); // 99
```

### 5.3 标准库可以提供便利函数

为了方便使用，标准库可以提供 `copy` 函数：

```cpp
// ========== 标准库中的 copy 函数示意 ==========
func copy<T>(T[] dst, T[] src) -> usize {
    var count = min(dst.len, src.len);
    memcpy(dst.ptr, src.ptr, sizeof(T) * count);
    return count;
}

// 使用示例
int[3] src = [1, 2, 3];
int[3] dst;
copy(dst, src); // 标准库提供的便利函数
```

---

## 6. 堆数组：`new Type[N]` 返回切片

### 6.1 `new Type[N]` 的返回类型

**`new Type[N]` 返回切片，而不是数组**：

```cpp
// ========== 堆数组分配 ==========
int[] heap_slice = new int[3];
// 类型: int[]（切片）
// 内存: 堆上分配，heap_slice 引用它

// 初始化
heap_slice[0] = 1;
heap_slice[1] = 2;
heap_slice[2] = 3;

// 使用
println(heap_slice.len); // 3
println(heap_slice[0]);  // 1
```

### 6.2 堆数组的释放

**堆数组的释放规则**：

| 释放对象 | 语法            | 说明                       |
| -------- | --------------- | -------------------------- |
| **切片** | `delete slice;` | 切片包含长度信息，安全释放 |
| **指针** | `delete[] ptr;` | C++ 风格，通过指针释放     |

#### 方式 1：通过切片释放（推荐）

```cpp
int[] heap_slice = new int[3];

// 使用完后释放
delete heap_slice;
// OK: 切片包含长度信息，编译器知道如何释放
// 实际上释放的是切片指向的堆数组
```

#### 方式 2：通过指针释放（C++ 风格）

```cpp
int[] heap_slice = new int[3];
int^ ptr = heap_slice.ptr;

// 通过指针释放
delete[] ptr;
// OK: C++ 风格，需要使用 delete[]
```

**设计理由：**
- **推荐 `delete slice`**：切片包含长度信息，最安全
- **支持 `delete[] ptr`**：兼容 C++ 风格，方便移植
- **统一接口**：`new` 返回切片，推荐用 `delete` 接受切片
- **避免 C++ 复杂性**：默认用切片方式，避免混淆 `delete` 和 `delete[]`

---

## 7. 完整的属性总结

### 7.1 数组的属性

| 属性  | 数组 `Type[N]` | 说明             |
| ----- | -------------- | ---------------- |
| `len` | ✅ 有           | 元素个数，只读   |
| `ptr` | ❌ 无           | 数组没有指针属性 |

### 7.2 切片的属性

| 属性  | 切片 `Type[]` 或 `Type![]` | 说明                 |
| ----- | -------------------------- | -------------------- |
| `len` | ✅ 有                       | 元素个数，只读       |
| `ptr` | ✅ 有                       | 指向数据的指针，只读 |

### 7.3 访问方式统一

| 操作         | 数组 `Type[N]`       | 切片 `Type[]`          |
| ------------ | -------------------- | ---------------------- |
| 下标访问     | `arr[i]`             | `slice[i]`             |
| 获取长度     | `arr.len`            | `slice.len`            |
| foreach 遍历 | `foreach (x in arr)` | `foreach (x in slice)` |

---

## 8. 完整示例

```cpp
import std;

func main() {
    // ========== 数组 ==========
    int[3] stack_arr = [1, 2, 3];
    println(stack_arr.len); // 3
    stack_arr[0] = 100;
    println(stack_arr[0]); // 100

    // ========== 切片 ==========
    int[] slice = stack_arr;
    println(slice.len); // 3
    println(slice.ptr); // 指向 stack_arr[0]
    slice[1] = 200;
    println(stack_arr[1]); // 200（stack_arr 也被修改）

    // ========== 堆数组 ==========
    int[] heap_slice = new int[3];
    heap_slice[0] = 1;
    heap_slice[1] = 2;
    heap_slice[2] = 3;
    println(heap_slice.len); // 3
    
    // 方式 1：通过切片删除（推荐）
    delete heap_slice; // 释放堆内存
    
    // 方式 2：通过指针删除（C++ 风格）
    int[] heap_slice2 = new int[3];
    int^ ptr = heap_slice2.ptr;
    delete[] ptr; // C++ 风格

    // ========== 切片比较 ==========
    int[] a = [1, 2, 3];
    int[] b = [1, 2, 3];
    println(a == b); // true（使用标准库重载的 ==）

    // ========== 切片浅拷贝 ==========
    int[] slice1 = stack_arr;
    int[] slice2 = slice1;
    slice2[0] = 999;
    println(slice1[0]); // 999（slice1 也被修改）

    // ========== 切片深拷贝 ==========
    int[3] new_arr;
    int[] slice3 = new_arr;
    memcpy(slice3.ptr, slice1.ptr, sizeof(int) * slice1.len);
    slice3[0] = 1000;
    println(slice1[0]); // 999（slice1 没有被修改）
}
```

---

## 9. 设计决策总结

### Q1: 为什么不设计 `cap` 属性？

**A:**
- 可以通过 `sizeof(T) * t.len` 简单计算
- 避免不必要的复杂性
- 保持语言核心简洁

### Q2: 为什么 `new Type[N]` 返回切片？

**A:**
- 切片包含长度信息，`delete` 可以正确释放
- 统一接口：`new` 返回切片，`delete` 接受切片
- 避免 C++ 中 `new[]` 和 `delete[]` 的复杂性

### Q3: 为什么切片的 `==` 和 `!=` 由标准库实现？

**A:**
- 编译器只提供基础设施，高级功能由标准库实现
- 用户可以根据需要自定义比较逻辑
- 保持编译器简洁，灵活性留给用户

### Q4: 为什么数组也有 `ptr` 属性？

**A:**
- 数组的 `ptr` 属性指向数据的内存区域，简单

### Q5: 为什么切片默认是浅拷贝？

**A:**
- 浅拷贝是零开销的（只拷贝 ptr 和 len）
- 深拷贝有性能开销，应该显式表达
- 用户需要深拷贝时，显式使用 `memcpy` 或标准库的 `copy` 函数

### Q6: 为什么保留 `ptr` 属性？

**A:**
- **C 互操作方便**：经常需要把切片传递给 C 函数，`slice.ptr` 很方便
- **清晰表达意图**：`slice.ptr` 明确表示"我要切片的指针"
- **对称完整**：和 `len` 属性配对，逻辑上完整
- **只读属性**：`ptr` 是只读的，不能修改，保证安全

### Q7: 堆数组的释放规则是什么？

**A:**
- **推荐方式**：`delete slice;` - 切片包含长度信息，最安全
- **C++ 风格**：`delete[] ptr;` - 通过指针释放，兼容 C++
- **禁止**：`delete ptr;` - 通过指针释放数组用 delete 会有问题
- **设计理由**：推荐用切片方式，避免 C++ 中 `delete` 和 `delete[]` 的混淆

### Q8: 为什么叫 `len` 而不是 `count`？

**A:**
- **简洁**：`len` 只有 3 个字母，输入快
- **传统**：C、C++、Rust、Go 等语言都用 `len` 或 `length`
- **清晰**：在 C^ 的上下文中，`len` 就是"元素个数"，不会混淆
- **区分**：和 `sizeof` 明确区分（`sizeof` 是字节数，`len` 是元素个数）
- **统一**：数组和切片都用 `len`，保持一致

### Q9: 为什么数组也有 `len` 属性？

**A:**
- **统一访问**：数组和切片都用 `arr.len`，写代码更方便
- **自然**：`foreach (x in arr)` 也需要知道长度，有 `len` 很自然
- **实用**：虽然数组大小在类型中（`int[3]`），但运行时访问 `arr.len` 还是很实用
- **一致**：和切片保持一致的属性访问方式

---

## 10. 总结

C^ 的切片与数组设计通过以下方式达到了完美的平衡：

1. **统一访问**：数组和切片都用下标访问 `arr[i]`
2. **统一属性**：数组和切片都有 `len` 属性
3. **简洁实用**：不设计 `cap` 属性，用 `sizeof(T) * t.len` 计算
4. **显式控制**：深拷贝需要显式使用 `memcpy`
5. **灵活扩展**：操作符重载由标准库实现
6. **统一接口**：`new Type[N]` 返回切片，`delete` 接受切片

**设计特点：**
- ✅ 统一访问方式：数组和切片的使用方式一致
- ✅ 简洁实用：去除不必要的属性
- ✅ 显式控制：重要操作需要显式表达
- ✅ 灵活扩展：标准库可以提供丰富的功能
- ✅ 内存安全：切片包含长度信息

这种设计既保持了 C^ 语言的简洁性，又提供了足够的灵活性和控制权给开发者！
