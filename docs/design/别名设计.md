# C^ 类型别名设计

## 1. 概述

C^ 语言提供 `using` 关键字来创建类型别名，旨在简化复杂类型的书写、提高代码可读性，并为代码重构和平台兼容性提供支持。

## 2. 语法

### 2.1 基本语法

```cpp
// 创建类型别名
using AliasName = OriginalType;
```

### 2.2 使用位置

`using` 别名可以在以下位置使用：

1. **模块/命名空间级别**（最常见）：
   ```cpp
   module std.core;
   
   using int8 = sbyte;
   using int16 = short;
   using string_view = byte![];
   ```

2. **类/结构体内部**：
   ```cpp
   class Container {
       using value_type = T;
       using iterator = Iterator<T>;
       // ...
   };
   ```

3. **函数内部**（局部类型别名）：
   ```cpp
   func process() -> Result<int, Error> {
       using MyResult = Result<int, Error>;
       MyResult r = MyResult.ok(42);
       return r;
   }
   ```

### 2.3 别名的范围

- **模块级别名**：在整个模块内可见，可以被其他模块导入使用
- **类内部别名**：通过 `ClassName::AliasName` 访问
- **局部别名**：仅在声明的作用域内可见

## 3. 功能特性

### 3.1 支持的类型

`using` 可以创建以下类型的别名：

1. **基础类型**：
   ```cpp
   using IntPtr = int^;
   using ConstRef = const string&;
   ```

2. **泛型类型**：
   ```cpp
   using IntList = List<int>;
   using StringMap = Map<string, string>;
   using ComplexType = Map<string, List<Result<int, Error>>>;
   ```

3. **函数类型**：
   ```cpp
   using Callback = func(int) -> void;
   using Comparator = func(T, T) -> bool;
   ```

4. **元组类型**：
   ```cpp
   using Point = (int, int);
   using PersonInfo = (string, int, bool);
   ```

5. **数组/切片类型**：
   ```cpp
   using Buffer = byte[1024];
   using StringSlice = byte![];
   ```

### 3.2 模板别名（Template Aliases）

C^ 支持模板别名，可以为带参数的泛型类型创建别名：

```cpp
// 模板别名
using Vec<T> = std.vector<T>;
using Map<K, V> = std.hash_map<K, V>;

// 部分特化的模板别名
using StringMap<V> = Map<string, V>;
using IntMap<V> = Map<int, V>;

// 使用
Vec<int> numbers;
StringMap<int> config;
```

### 3.3 别名与类型等价性

别名在类型系统中与其原始类型**完全等价**：

```cpp
using Int = int;
using Integer = int;

func test() {
    Int a = 10;
    Integer b = 20;
    int c = a + b; // 正确：所有类型都是 int
    assert(typeid(Int) == typeid(int)); // true
    assert(typeid(Int) == typeid(Integer)); // true
}
```

## 4. 设计原则

### 4.1 语法一致性

C# 使用 `using Alias = Type;`，C++ 使用 `using Alias = Type;`（C++11），C^ 遵循这一现代语法，避免使用 `typedef` 关键字。

### 4.2 编译期处理

所有别名在编译期被完全展开，不产生运行时开销：

```cpp
using ComplexType = Map<string, List<Result<int, Error>>>;

// 编译后等价于直接使用原始类型
// 在错误信息中，编译器应显示原始类型（或提供选项显示别名）
```

### 4.3 错误信息优化

编译器应在错误信息中优先显示**用户定义的别名**，以提高可读性：

```cpp
using ResultType = Result<int, DatabaseError>;

func query() -> ResultType {
    // ...
    if (error) return ResultType.err(DatabaseError("Connection failed"));
    // ...
}

// 错误信息应显示：ResultType，而不是 Result<int, DatabaseError>
// （但编译器可以同时提供展开信息）
```

## 5. 与相关特性的交互

### 5.1 与 `type` 关键字的关系

标准库规范中使用了 `type` 关键字定义别名，这是 `using` 的**语法糖**：

```cpp
// 标准库中的写法（语法糖）
type int8 = sbyte;

// 等价于
using int8 = sbyte;
```

`type` 关键字仅用于**向后兼容性**和**标准库规范的特殊需求**，新代码应使用 `using`。

### 5.2 与泛型约束的交互

别名可以出现在 `where` 子句中：

```cpp
using Numeric = int | long | float | double;

func sum<T>(T[] values) -> T where T : Numeric {
    // T 必须是 int, long, float, double 之一
    // ...
}
```

### 5.3 与反射的交互

反射系统可以获取别名的元信息：

```cpp
using MyType = List<int>;

comptime {
    var info = @MyType; // 获取类型信息
    print(info.name); // 可能显示 "MyType" 或 "List<int>"
    print(info.original_type.name); // 显示 "List<int>"
}
```

## 6. 使用场景与示例

### 6.1 简化复杂类型

```cpp
// 复杂的嵌套类型
using DatabaseResult = Result<Optional<Map<string, Variant>>, DatabaseError>;

// 使用
func query_user(string id) -> DatabaseResult {
    // ...
}

// 错误处理更清晰
match (result) {
    case Ok(data) => ...,
    case Err(err) => print($"Database error: {err.message}")
}
```

### 6.2 平台兼容性

```cpp
// 平台特定的类型别名
#if TARGET_WINDOWS
    using socket_t = SOCKET;
    using socklen_t = int;
#elif TARGET_LINUX
    using socket_t = int;
    using socklen_t = socklen_t;
#endif

// 统一的代码
func connect(socket_t sock, Address addr) -> Result<void, SocketError> {
    // ...
}
```

### 6.3 库接口演进

```cpp
// v1.0 库
using Handler = func(Request) -> Response;

// v2.0 库（保持向后兼容）
class RequestContext { /* ... */ };
using Handler = func(RequestContext) -> Response;

// 现有代码无需修改，但可以使用新特性
```

### 6.4 领域特定语言（DSL）

```cpp
// 图形库
using Vec2 = (float, float);
using Vec3 = (float, float, float);
using Color = (byte, byte, byte, byte); // RGBA
using Transform = Mat4;

// 物理引擎
using Mass = float; // 千克
using Velocity = Vec3; // 米/秒
using Force = Vec3; // 牛顿
```

### 6.5 元编程模板

```cpp
// 类型 trait 别名
using is_integral<T> = bool_constant<is_same<T, byte> || is_same<T, short> || ...>;

// 类型转换别名
using remove_const<T> = ...;
using add_pointer<T> = T^;
using add_reference<T> = T&;
```

## 7. 编译器实现要求

### 7.1 别名解析规则

1. **词法作用域**：别名遵循标准的作用域规则
2. **查找顺序**：局部作用域 → 类作用域 → 模块作用域 → 导入模块
3. **遮蔽规则**：内层别名可以遮蔽外层别名
4. **循环别名检测**：编译器必须检测并报告循环别名定义

### 7.2 错误检测

```cpp
// 错误：循环别名
using A = B;
using B = A; // 编译错误：循环类型别名

// 错误：未定义的类型
using X = UndefinedType; // 编译错误：UndefinedType 未定义

// 警告：遮蔽标准库类型
using string = MyString; // 警告：遮蔽标准库类型 'string'
```

### 7.3 调试信息

编译器应在调试信息中保留别名信息，以支持更好的调试体验。

## 8. 总结

C^ 的 `using` 别名系统提供了：

1. **简洁的语法**：`using Alias = Type;`
2. **完全的类型等价**：不引入新类型，仅创建名称
3. **强大的表达能力**：支持泛型、函数类型、模板别名等
4. **编译期零开销**：所有处理在编译期完成
5. **良好的工具链支持**：在错误信息、调试信息中保留别名

标准库应优先使用 `using` 定义类型别名，`type` 关键字作为兼容性语法糖存在。