# C^ 协程设计文档 (Coroutines)

## 1. 设计哲学

C^ 的协程设计灵感来源于 C++20 的无栈协程（Stackless Coroutines），但旨在提供更清晰、更优雅的**契约式（Duck Typing）**编程模型。

*   **无栈 (Stackless)**：协程状态保存在堆（或自定义分配器）上的状态机中，而非占用线程栈。
*   **零开销抽象**：如果编译器能推导生命周期，甚至可以优化为状态机内联。
*   **契约驱动**：协程的行为（是 Generator 还是 Task？是 Lazy 还是 Eager？）完全由**返回类型**的契约决定，而非硬编码在编译器中。

## 2. 关键字

我们引入两个核心关键字来驱动协程状态机：

*   **`await`**：一元操作符。挂起当前协程，等待操作对象（Awaitable）完成，然后恢复。
*   **`yield`**：语句。挂起当前协程，向调用者产出一个值（用于生成器）。

> **注意**：C^ 不需要显式的 `async` 关键字标记函数。如果一个函数体内包含 `await` 或 `yield`，且其返回类型满足协程契约，它自动成为协程。

## 3. 协程契约 (Coroutine Contract)

C^ 编译器并不认识具体的 `Task` 或 `Generator` 类，它只认识**模式**。任何满足以下契约的类型都可以作为协程的返回类型。

### 3.1 承诺对象 (Promise Type)

这是协程的“大脑”。对于返回类型 `RetType`，编译器会查找名为 `RetType::Promise` 的内部类型（或通过 traits 关联）。

```cpp
// 协程返回类型
struct Task {
    // 必须定义 Promise 类型
    struct Promise {
        // 1. 创建协程对象：在协程开始时调用
        func get_return_object() -> Task;
        
        // 2. 初始挂起点：协程创建后是立即执行还是挂起？
        // 返回 Awaitable
        func initial_suspend() -> SuspendAlways; 
        
        // 3. 最终挂起点：协程结束后是否挂起以保留状态？
        func final_suspend() -> SuspendAlways;
        
        // 4. 处理返回值：对应 `return value;`
        func return_value(int value); 
        // 或者 func return_void();
        
        // 5. 处理异常：协程体内抛出未捕获异常时调用
        func unhandled_exception();
        
        // 6. (可选) 处理 Yield：对应 `yield value;`
        // func yield_value(int value) -> SuspendAlways;
    }
}
```

### 3.2 等待体契约 (Awaitable Concept)

任何可以被 `await` 的对象必须满足 Awaitable 契约。这允许用户定义如何挂起和恢复。

```cpp
struct Awaitable {
    // 1. 是否准备好了？
    // 如果返回 true，则不挂起，直接调用 resume
    func is_ready() -> bool;
    
    // 2. 挂起逻辑
    // handle 是当前协程的句柄 (CoroutineHandle)
    // 可以在这里将 handle 注册到 Reactor/线程池
    func on_suspend(CoroutineHandle handle);
    
    // 3. 恢复逻辑
    // await 表达式的结果
    func on_resume() -> int;
}
```

## 4. 示例实现

### 4.1 简单的生成器 (Generator)

```cpp
// 定义生成器类型
struct Generator {
    struct Promise {
        int current_value;
        
        func get_return_object() -> Generator { 
            return Generator(CoroutineHandle::from_promise(self^)); 
        }
        
        // 创建后立即挂起 (Cold Start)
        func initial_suspend() -> SuspendAlways => {};
        
        // 结束后挂起，保证 handle 有效
        func final_suspend() -> SuspendAlways => {};
        
        func return_void() {}
        
        func unhandled_exception() { terminate(); }
        
        // 关键：处理 yield
        func yield_value(int v) -> SuspendAlways {
            self.current_value = v;
            return {}; // 挂起，切回调用者
        }
    }
    
    CoroutineHandle handle;
    
    // 迭代器接口 (适配 Option<T> 风格)
    func next() -> Option<int> {
        handle.resume();
        if (handle.done()) return Option<int>::None;
        return handle.promise().current_value;
    }
}

// 使用
func range(int start, int end) -> Generator {
    for (int i = start; i < end; i++) {
        yield i; // 调用 Promise.yield_value(i)
    }
}

func main() {
    var gen = range(0, 5);
    // 使用 match 处理 Option
    while (true) {
        match (gen.next()) {
            Some(val) => print(val),
            None      => break
        }
    }
}
```

### 4.2 异步任务 (Async Task)

```cpp
// 使用
func fetch_data(string url) -> Task<string> {
    // 自动挂起，等待网络 IO
    // await 调用 TcpStream.read().is_ready() / on_suspend()
    var data = await TcpStream.connect(url).read_all();
    
    return "Response: " + data;
}

func main() {
    // 启动协程
    var task = fetch_data("http://example.com");
    
    // 阻塞等待结果 (仅作演示)
    print(task.sync_wait()); 
}
```

## 5. 优雅设计总结

C^ 的协程设计优雅在：

1.  **统一性**：`Generator` 和 `Task` 只是 `Promise` 实现不同，语法完全一致。
2.  **控制权下放**：通过 `initial_suspend`，库作者可以决定协程是**冷启动**（Lazy，像 Python/Rust）还是**热启动**（Eager，像 C#/Go）。
3.  **类型安全**：所有状态机生成都在编译期完成，强类型检查。
4.  **无魔法**：没有内置的 `Task` 类型，标准库提供的 `std::Task` 只是一个符合契约的普通类，用户完全可以手写 `MyTask`。
