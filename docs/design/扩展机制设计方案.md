# C^ 扩展机制设计方案

## 1. 设计理念

C^ 的扩展机制允许为现有类型（包括内置类型和用户定义类型）添加新的属性和方法，而无需修改原有类型的定义。这种设计将编译器核心功能与标准库功能解耦，提供了极高的灵活性。

### 设计原则：
1. **零开销抽象**：扩展方法在编译期内联，无运行时成本
2. **统一性**：内置类型和用户定义类型使用相同的扩展语法
3. **开放性**：用户可以为任何类型添加扩展
4. **优先级**：类型原有的成员优先于扩展成员

---

## 2. 语法设计

### 2.1 基本语法

使用 `extension` 关键字定义扩展：

```cpp
// 为 int 类型添加扩展
extension int {
    // 静态属性（使用 static get）
    static get max_value -> int => 2147483647;
    static get min_value -> int => -2147483648;
    static get bits -> long => 32;
    static get size -> long => 4;
    static get is_signed -> bool => true;
    
    // 实例方法
    func to_string() -> string {
        // 实现
    }
    
    // 实例属性（只读）
    get is_even -> bool => this % 2 == 0;
}
```

### 2.2 访问语法

```cpp
// 访问静态属性
long max = int.max_value;

// 调用实例方法
int x = 42;
string s = x.to_string();

// 访问实例属性
bool even = x.is_even;
```

### 2.3 泛型扩展

```cpp
// 为所有数组类型添加扩展
extension <T> T[] {
    func map<U>(func transform(T) -> U) -> U[] {
        // 实现
    }
    
    func filter(func predicate(T) -> bool) -> T[] {
        // 实现
    }
}

// 使用
int[] numbers = [1, 2, 3, 4, 5];
int[] doubled = numbers.map(x => x * 2);
int[] evens = numbers.filter(x => x % 2 == 0);
```

### 2.4 约束扩展

```cpp
// 只为实现了 Comparable 的类型添加扩展
extension <T: Comparable> T {
    func clamp(min: T, max: T) -> T {
        if this < min return min;
        if this > max return max;
        return this;
    }
}
```

---

## 3. 完整标准库示例

### 3.1 int 类型扩展（标准库实现）

```cpp
// std/core/int.ch
extension int {
    static get max_value -> int => 2147483647;
    static get min_value -> int => -2147483648;
    static get bits -> long => 32;
    static get size -> long => 4;
    static get is_signed -> bool => true;
    static get is_integer -> bool => true;
    static get is_floating -> bool => false;
    
    func abs(self!) -> int {
        return self < 0 ? -self : self;
    }
    
    func to_long(self!) -> long => self;
}
```

### 3.2 double 类型扩展

```cpp
// std/core/double.ch
extension double {
    static get max_value -> double => 1.7976931348623157e+308;
    static get min_value -> double => 2.2250738585072014e-308;
    static get epsilon -> double => 2.2204460492503131e-16;
    static get bits -> long => 64;
    static get size -> long => 8;
    static get is_signed -> bool => true;
    static get is_integer -> bool => false;
    static get is_floating -> bool => true;
    
    func floor() -> double { /* 实现 */ }
    func ceil() -> double { /* 实现 */ }
    func round() -> double { /* 实现 */ }
}
```

### 3.3 string 类型扩展

```cpp
// std/core/string.ch
extension string {
    get length -> long => /* 实现 */;
    get is_empty -> bool => length == 0;
    
    func substring(start: long, end: long) -> string { /* 实现 */ }
    func contains(sub: string) -> bool { /* 实现 */ }
    func starts_with(prefix: string) -> bool { /* 实现 */ }
    func ends_with(suffix: string) -> bool { /* 实现 */ }
}
```

---

## 4. 编译器实现要点

### 4.1 AST 节点设计

```cpp
// ExtensionDecl.h
namespace c_hat {
namespace ast {

class ExtensionDecl : public Declaration {
public:
    ExtensionDecl(
        std::unique_ptr<Type> extendedType,
        std::vector<std::unique_ptr<GenericParam>> genericParams,
        std::vector<std::unique_ptr<Declaration>> members
    ) : extendedType(std::move(extendedType)),
        genericParams(std::move(genericParams)),
        members(std::move(members)) {}

    NodeType getType() const override { return NodeType::ExtensionDecl; }
    std::string toString() const override;

    std::unique_ptr<Type> extendedType;
    std::vector<std::unique_ptr<GenericParam>> genericParams;
    std::vector<std::unique_ptr<Declaration>> members;
};

} // namespace ast
} // namespace c_hat
```

### 4.2 解析器实现

```cpp
// Parser::parseExtensionDecl()
std::unique_ptr<ast::Declaration> Parser::parseExtensionDecl() {
    consume(lexer::TokenType::Extension, "Expected 'extension'");
    
    // 解析泛型参数（可选）
    std::vector<std::unique_ptr<ast::GenericParam>> genericParams;
    if (match(lexer::TokenType::Less)) {
        genericParams = parseGenericParams();
        consume(lexer::TokenType::Greater, "Expected '>' after generic parameters");
    }
    
    // 解析被扩展的类型
    auto extendedType = parseType();
    
    // 解析成员
    consume(lexer::TokenType::LeftBrace, "Expected '{' after extended type");
    
    std::vector<std::unique_ptr<ast::Declaration>> members;
    while (!match(lexer::TokenType::RightBrace)) {
        members.push_back(parseDeclaration());
    }
    
    return std::make_unique<ast::ExtensionDecl>(
        std::move(extendedType),
        std::move(genericParams),
        std::move(members)
    );
}
```

### 4.3 语义分析实现

```cpp
// 扩展注册表
class ExtensionRegistry {
public:
    void addExtension(std::shared_ptr<types::Type> extendedType, 
                     std::unique_ptr<ast::ExtensionDecl> extension);
    
    // 查找类型的所有扩展
    std::vector<ast::ExtensionDecl *> getExtensionsForType(
        std::shared_ptr<types::Type> type);
    
    // 查找静态成员
    std::optional<ast::Declaration *> findStaticMember(
        std::shared_ptr<types::Type> type,
        const std::string &name);
    
    // 查找实例成员
    std::optional<ast::Declaration *> findInstanceMember(
        std::shared_ptr<types::Type> type,
        const std::string &name);
};
```

### 4.4 成员访问解析流程

当解析 `type.member` 或 `expr.member` 时：

1. **检查类型是否有原生成员**：优先查找类型本身定义的成员
2. **检查扩展**：如果没有原生成员，查找所有该类型的扩展
3. **返回第一个匹配**：返回找到的第一个成员声明

```cpp
// SemanticAnalyzer::analyzeMemberExpr()
std::shared_ptr<types::Type> SemanticAnalyzer::analyzeMemberExpr(
    std::unique_ptr<ast::MemberExpr> memberExpr) {
    
    // 先检查是否是静态成员访问（如 int.max_value）
    if (memberExpr->object->getType() == ast::NodeType::Identifier) {
        auto *identifier = static_cast<ast::Identifier *>(memberExpr->object.get());
        
        // 1. 检查是否是类型名
        auto type = tryResolveType(identifier->name);
        if (type) {
            // 2. 查找类型的原生静态成员
            auto nativeMember = findNativeStaticMember(type, memberExpr->member);
            if (nativeMember) {
                return analyzeDeclaration(nativeMember);
            }
            
            // 3. 查找扩展的静态成员
            auto extensionMember = extensionRegistry.findStaticMember(type, memberExpr->member);
            if (extensionMember) {
                return analyzeDeclaration(*extensionMember);
            }
        }
    }
    
    // 实例成员访问的处理...
}
```

### 4.5 代码生成实现

扩展方法在编译期内联到调用点，无额外运行时开销：

```cpp
// LLVMCodeGenerator::generateMemberExpr()
llvm::Value *LLVMCodeGenerator::generateMemberExpr(
    ast::MemberExpr *memberExpr) {
    
    // 检查是否是静态属性（编译期常量）
    if (isStaticProperty(memberExpr)) {
        auto propValue = evaluateStaticProperty(memberExpr);
        return generateConstant(propValue);
    }
    
    // 检查是否是扩展方法
    if (isExtensionMethod(memberExpr)) {
        auto method = getExtensionMethod(memberExpr);
        return generateExtensionMethodCall(method, memberExpr);
    }
    
    // 普通成员访问...
}
```

---

## 5. 完整实现闭环

### 5.1 用户代码

```cpp
// main.ch
import std.core;

func main() {
    // 使用标准库扩展的静态属性
    long max = int.max_value;
    long bits = int.bits;
    double pi = 3.14159;
    double floorPi = pi.floor();
    
    // 使用实例方法
    int x = -42;
    int absX = x.abs();
    
    print("int max: " + max.to_string());
    print("int bits: " + bits.to_string());
    print("floor(pi): " + floorPi.to_string());
    print("abs(-42): " + absX.to_string());
}
```

### 5.2 标准库代码

```cpp
// std/core/int.ch
extension int {
    static get max_value -> int => 2147483647;
    static get bits -> long => 32;
    
    func abs() -> int {
        return this < 0 ? -this : this;
    }
    
    func to_string() -> string {
        // 实现
    }
}
```

### 5.3 编译器处理流程

1. **解析阶段**：解析 `extension` 声明，注册到扩展注册表
2. **语义分析阶段**：解析成员访问时，先查原生成员，再查扩展
3. **代码生成阶段**：扩展方法内联，静态属性直接生成常量
4. **链接阶段**：无额外开销，完全零成本抽象

---

## 6. 设计优势总结

### 相比编译器内置方案：

1. **灵活性**：标准库可以自由添加属性和方法，无需修改编译器
2. **解耦**：编译器只负责核心功能，标准库负责功能扩展
3. **可演进**：标准库可以独立更新和演进
4. **用户可扩展**：用户也可以为第三方库类型添加扩展
5. **现代化**：Swift/Kotlin/C# 等现代语言都采用这种设计

### 相比完全标准库方案：

1. **性能**：编译器优化，零运行时开销
2. **一致性**：内置类型和用户类型使用相同机制
3. **可控性**：编译器可以对关键扩展进行特殊优化

---

## 7. 实现优先级

### Phase 1: 基础框架
- [ ] 添加 `extension` 关键字到词法分析器
- [ ] 创建 `ExtensionDecl` AST 节点
- [ ] 实现解析器对 `extension` 的解析
- [ ] 创建扩展注册表

### Phase 2: 静态属性支持
- [ ] 支持 `static get` 语法
- [ ] 实现静态属性的语义分析
- [ ] 实现静态属性的编译期求值
- [ ] 添加 `int.max_value` 等标准库扩展

### Phase 3: 实例方法支持
- [ ] 支持扩展中的实例方法
- [ ] 实现 `this` 关键字在扩展中的绑定
- [ ] 实现扩展方法的代码生成

### Phase 4: 实例属性支持
- [ ] 支持 `get` 语法（只读属性）
- [ ] 支持 `set` 语法（可写属性）

### Phase 5: 泛型扩展
- [ ] 支持泛型扩展声明
- [ ] 支持约束扩展
- [ ] 实现泛型扩展的类型推断
