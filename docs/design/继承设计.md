# C^ 继承与接口设计文档

## 1. 核心设计原则

C^ 采用了**单继承、多接口**的现代面向对象设计模式。

*   **单继承 (Single Inheritance)**：一个类只能继承自一个基类 (Class)。这避免了 C++ 多重继承带来的"菱形继承"数据冗余和复杂的虚基类问题。
*   **多接口 (Multiple Interfaces)**：一个类可以实现任意数量的接口 (Interface)。接口不仅定义契约，还可以提供**默认实现**。

---

## 2. 类继承 (Class Inheritance)

### 2.1 基本语法

使用 `:` 指定基类。C^ 仅支持 `public` 继承，且**无需显式书写 `public` 关键字**。

*   **默认即 Public**：继承声明中省略访问修饰符即表示 `public` 继承。
*   **禁止私有继承**：C^ 移除了 C++ 中的 `private`/`protected` 继承，因为这些通常可以用组合（Composition）更好地实现。

```cpp
class Animal {
public:
    virtual func make_sound() {
        print("Animal sound");
    }
}

// 单继承 (隐式 public)
class Dog : Animal {
public:
    override func make_sound() {
        print("Woof!");
    }
}
```

### 2.2 构造与析构

*   **构造**：使用类名 `ClassName(...)`。
*   **析构**：使用 `~ { ... }`。
*   **基类调用**：使用 `: base(...)`。

```cpp
class Derived : Base {
public:
    // 构造函数
    Derived(int x) : base(x) {
        // ...
    }
    
    // 析构函数
    ~ {
        // ...
    }
}
```

---

## 3. 接口系统 (Interface System)

接口是 C^ 类型系统的核心。接口中不能包含数据成员（Field），但可以包含：
1.  抽象方法声明。
2.  **默认实现方法** (Default Implementation)。
3.  静态方法。

### 3.1 定义与实现

```cpp
interface ILogger {
    // 抽象方法
    func log(string msg);

    // 默认实现
    func log_error(string msg) {
        self.log("[ERROR] " + msg);
    }
}

interface ISerializable {
    func to_json() -> string;
}

// 实现多个接口
class FileLogger : ILogger, ISerializable {
public:
    // 必须实现抽象方法
    override func log(string msg) {
        // write to file...
    }

    override func to_json() -> string {
        return "{}";
    }

    // log_error 直接使用接口的默认实现，无需重写
}
```

---

## 4. 接口冲突与仲裁 (Conflict Resolution)

当一个类实现多个接口，且这些接口包含**同名且参数列表相同**的方法（无论是默认实现还是抽象声明）时，编译器会报错，要求开发者显式解决冲突。

C^ 提供两种解决方案：**仲裁 (Arbitration)** 和 **重写 (Override)**。

### 场景假设

```cpp
interface IWifi {
    func connect() {
        print("Connecting via WiFi...");
    }
}

interface IBluetooth {
    func connect() {
        print("Connecting via Bluetooth...");
    }
}
```

### 方案 A：仲裁 (Arbitration)

如果开发者希望直接复用其中某一个接口的逻辑，可以使用 `using` 关键字指定。

```cpp
class SmartDevice : IWifi, IBluetooth {
public:
    // 仲裁：明确指定 connect() 使用 IWifi 的实现
    using IWifi::connect; 
}

// 使用
SmartDevice dev;
dev.connect(); // 输出: Connecting via WiFi...
```

### 方案 B：显式重写 (Explicit Override)

如果两个接口的逻辑都不适用，或者需要组合它们的逻辑，开发者必须在类中显式重写该方法。

```cpp
class DualModeDevice :  IWifi,  IBluetooth {
public:
    // 显式重写：覆盖所有接口的默认实现
    override func connect() {
        print("Checking signal strength...");
        
        // 可以选择性调用特定接口的实现
        if (wifi_strong) {
            IWifi::connect();
        } else {
            IBluetooth::connect();
        }
    }
}
```

### 方案 C：使用组合 (Composition) - **推荐**

如果 `IWifi` 和 `IBluetooth` 的 `connect` 逻辑完全不同，且需要在同一个对象中并存，我们建议使用**组合**而非继承。这符合 "Composition over Inheritance" 的原则，也能提供更清晰的 API。

```cpp
class HybridDevice {
    private WifiModule _wifi;
    private BluetoothModule _bt;

    public func connect_wifi() {
        _wifi.connect();
    }

    public func connect_bluetooth() {
        _bt.connect();
    }
}
```

> **设计决策**：C^ 移除了 C# 风格的 "显式接口实现" (Explicit Interface Implementation)。我们认为，一个对象在被转换为不同接口时表现出完全不同的行为（且方法名相同），是一种容易导致混淆的 "Magic" 行为。如果行为不同，应当体现为不同的方法名或不同的组件对象。

---

## 5. 继承 vs 组合

虽然 C^ 提供了强大的接口继承能力，但我们依然坚持 **"组合优于继承" (Composition over Inheritance)** 的原则。

*   **继承**：适用于严格的 `is-a` 关系，且主要为了复用接口契约。
*   **组合**：适用于 `has-a` 关系，主要为了复用实现逻辑。

```cpp
// 推荐：使用组合复用逻辑
class Browser {
    Downloader _downloader; // 组合
    Renderer _renderer;     // 组合
}
```
