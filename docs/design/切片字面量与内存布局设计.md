# C^ 切片字面量与内存布局设计文档（方案B）

## 1. 概述

C^ 的切片字面量设计核心在于 **"值类型优先"** 和 **"视图类型显式"**。
根据方案B，我们将数组和元组统一为值类型，默认在栈上分配，形成完美闭环！

### 1.1 核心设计目标
1. **一致性优先**：数组和元组都是值类型，默认在栈上
2. **显式控制**：视图类型需要显式声明，语义清晰
3. **类型一致**：切片/数组要求所有元素类型相同，不同类型请使用元组
4. **语义分离**：切片 = 视图，数组 = 拥有数据
5. **简单优雅**：不需要 `Type[$]` 语法，默认就是栈数组

---

## 2. 核心设计原则

### 2.1 核心场景

根据方案B，我们简化为 **两个核心场景**：

| 场景                             | 语法                            | 推导类型                   | 内存位置  | 可变性     |
| -------------------------------- | ------------------------------- | -------------------------- | --------- | ---------- |
| **场景 A：数组字面量（值类型）** | `var arr = [1, 2, 3];`          | `Type[N]`（值类型）        | 栈        | ✅ 可修改   |
| **场景 A1：LiteralView 数组**    | `var arr = ["hello", "world"];` | `LiteralView[N]`（值类型） | 栈        | ✅ 可修改   |
| **场景 B：显式只读切片**         | `Type![] slice = [1, 2, 3];`    | `Type![]`（只读切片）      | `.rodata` | ❌ 不可修改 |

**注意：不再有 `Type[$]` 语法！默认 `var arr = [1, 2, 3];` 就是栈数组！**

### 2.2 设计理念
1. **一致性优先**：数组和元组都是值类型，默认在栈上
2. **值类型优先**：数组字面量默认推导为值类型 `Type[N]`
3. **视图类型显式**：如果需要切片（视图），需要显式声明
4. **简单优雅**：不需要 `Type[$]` 语法，默认就是栈数组
5. **完美闭环**：值类型默认栈，视图类型显式声明

### 2.3 完美闭环设计

```
值类型（Value Types）
├── 数组 Type[N]    → 默认栈上，拥有数据，可修改
└── 元组 (T1, T2)   → 默认栈上，拥有数据，可修改

视图类型（View Types）
├── 切片 Type[]     → 引用已有数据，可写
└── 只读切片 Type![] → 引用 .rodata，只读
```

---

## 3. 场景详解

### 3.0 场景 A：数组字面量（值类型，栈上）

当使用 `var arr = [1, 2, 3];` 时，默认推导为值类型 `Type[N]`，在栈上分配：

```cpp
// 1. 纯整数常量数组
var arr1 = [1, 2, 3];
// 推导类型：int[3]（值类型）
// 内存位置：栈上
// arr1[0] = 99; // OK: 可修改

// 2. 含变量的数组
var x = 10;
var y = 20;
var arr2 = [x, y, 30];
// 推导类型：int[3]（值类型）
// 内存位置：栈上
// arr2[0] = 99; // OK: 可修改

// 3. 字符串字面量数组
var arr3 = ["hello", "world"];
// 推导类型：LiteralView[2]（值类型）
// 内存位置：栈上
// arr3[0] = LiteralView("new"); // OK: 可修改

// 4. ❌ 混合类型：不支持！
// var arr4 = [1, 3.14, true];
// Error: 切片/数组要求所有元素类型相同
// 如果需要不同类型的元素，请使用元组：
var tuple4 = (1, 3.14, true); // ✅ OK：元组支持不同类型
```

**设计理由：**
- 数组和元组都是值类型，默认在栈上，保持一致性
- 默认可修改，更实用
- 不需要 `Type[$]` 语法，简单优雅
- 形成完美闭环：值类型默认栈，视图类型显式声明

**内存布局图解（场景 A）：**
```
栈
┌─────────────────────────┐
│  int[3] arr1            │
│    [0]: 1               │
│    [1]: 2               │
│    [2]: 3               │
└─────────────────────────┘
```

### 3.1 场景 B：显式只读切片（.rodata）

如果需要 `.rodata` 的零成本只读切片，需要显式声明 `Type![]`：

```cpp
// 1. 显式声明只读切片
int![] slice1 = [1, 2, 3];
// 推导类型：int![]（只读切片）
// 内存位置：.rodata
// slice1[0] = 99; // Error: 不可修改

// 2. 显式声明字符串只读切片
LiteralView![] slice2 = ["hello", "world"];
// 推导类型：LiteralView![]（只读切片）
// 内存位置：.rodata
```

**设计理由：**
- 视图类型需要显式声明
- 纯常量数据放在 `.rodata` 段是零成本的
- 标记为只读（`![]`）可以防止意外修改

**内存布局图解（场景 B）：**
```
.rodata 段（只读）
┌─────────────────────────┐
│  [1, 2, 3]             │ ← 常量数据
└─────────────────────────┘
         ↑
         │
    int![] slice1 (只读切片)
    ┌───────────────┐
    │ ptr: ----------→ .rodata
    │ length: 3     │
    └───────────────┘
```

### 3.2 场景 C：切片引用（引用已有数组）

切片可以引用已有数组（在栈上或堆上）：

```cpp
// 栈数组
var arr = [1, 2, 3];
// 类型：int[3]（值类型，栈上）

// 切片引用
int[] slice = arr;
// 类型：int[]（切片）
// 内存位置：栈上（引用 arr）
slice[0] = 99; // OK: 修改 arr
```

**设计理由：**
- 切片是视图类型，引用已有数据
- 栈数组可以自动隐式转换为切片（传参时）

---

## 4. 显式类型标注

### 4.1 数组（值类型，默认）
```cpp
// 默认栈数组（值类型）
var arr = [1, 2, 3];
// 类型：int[3]（值类型）
// 内存位置：栈上
// arr[0] = 99; // OK: 可修改
```

### 4.2 显式只读切片（视图）
```cpp
// 显式声明只读切片
int![] const_slice = [1, 2, 3];
// 类型：int![]（只读切片）
// 内存位置：.rodata
// const_slice[0] = 99; // Error: 只读
```

### 4.3 切片引用（视图）
```cpp
var arr = [1, 2, 3];

// 显式声明切片引用栈数组
int[] slice = arr;
// 类型：int[]（切片）
// 内存位置：栈上（引用 arr）
slice[0] = 99; // OK: 修改 arr
```

---

## 5. 与元组的关系

### 5.1 数组、切片、元组的对比（方案B）

| 特性         | 数组 `Type[N]`         | 只读切片 `Type![]`       | 切片 `Type[]`     | 元组 `(T1, T2, ...)`       |
| ------------ | ---------------------- | ------------------------ | ----------------- | -------------------------- |
| **语法**     | `var arr = [1, 2, 3];` | `Type![] s = [1, 2, 3];` | `Type[] s = arr;` | `var t = (1, 3.14, true);` |
| **类型**     | `Type[N]`（值类型）    | `Type![]`（视图）        | `Type[]`（视图）  | `(T1, T2, ...)`（值类型）  |
| **内存**     | 栈                     | `.rodata`                | 栈/堆（引用）     | 栈                         |
| **可变性**   | ✅ 可写                 | ❌ 只读                   | ✅ 可写            | ✅ 可写                     |
| **所有权**   | 拥有                   | 视图                     | 视图              | 拥有                       |
| **元素类型** | 必须相同               | 必须相同                 | 必须相同          | 可以不同                   |

**完美闭环！** 数组和元组都是值类型，默认在栈上！

---

## 6. 编译器实现策略

### 6.1 字面量分析

编译器在语义分析阶段检查数组字面量：

```cpp
// 伪代码：判断是否是纯常量字面量
bool isPureConstantLiteral(ArrayLiteralExpr expr) {
    for (auto element : expr.elements) {
        if (!element.isCompileTimeConstant()) {
            return false;
        }
    }
    return true;
}
```

### 6.2 类型推导

```cpp
// 伪代码：推导数组字面量类型
Type deduceArrayLiteralType(ArrayLiteralExpr expr, Type explicitType) {
    if (explicitType && explicitType.isReadonlySlice()) {
        // 显式声明为只读切片：Type![]
        return ReadonlyType(SliceType(elementType));
    } else if (explicitType && explicitType.isSlice()) {
        // 显式声明为切片：Type[]
        return SliceType(elementType);
    } else {
        // 默认：值类型数组 Type[N]
        return FixedSizeArrayType(elementType, expr.elements.size());
    }
}
```

### 6.3 代码生成

**数组（值类型，栈上）：**
1. 在栈上分配固定大小数组
2. 将字面量元素拷贝到栈数组
3. 数组是值类型，拥有数据所有权

**只读切片（.rodata）：**
1. 在 `.rodata` 段生成常量数组
2. 生成指向该数组的只读切片

---

## 7. 设计决策总结

### Q1: 为什么数组字面量默认是值类型 `Type[N]`？
**A:**
- 与元组保持一致：都是值类型，默认在栈上
- 符合用户直觉：`[1, 2, 3]` 和 `(1, 2, 3)` 都是值
- 默认可修改，更实用
- 不需要 `Type[$]` 语法，简单优雅
- 形成完美闭环：值类型默认栈，视图类型显式声明

### Q2: 如果需要 `.rodata` 的只读切片怎么办？
**A:**
显式声明即可：
```cpp
int![] slice = [1, 2, 3];
```

### Q3: 为什么不支持混合类型的数组字面量？
**A:**
- 语义分离：数组专门用于同类型元素的序列
- 元组已存在：不同类型元素的组合应该使用元组 `(1, 3.14, true)`
- 避免混淆：如果两种语法都支持，会引起开发者的混淆
- 类型安全：强制类型一致性，避免隐式类型转换带来的问题

### Q4: 栈数组和切片的关系是什么？
**A:**
- 栈数组 `Type[N]` 是值类型，拥有数据，在栈上分配
- 切片 `Type[]` 是视图类型，不拥有数据，只是引用
- 栈数组可以自动隐式转换为切片（传参时）
- 切片不能自动转换为栈数组（需要显式拷贝）

---

## 8. 完整示例

```cpp
// ========== 场景 A：数组字面量（值类型，栈上） ==========
var arr = [1, 2, 3];
// 类型: int[3]（值类型）
// 内存: 栈上
arr[0] = 99; // OK: 可修改

// 含变量的数组
var x = 10;
var arr2 = [x, 20, 30];
// 类型: int[3]（值类型）
// 内存: 栈上
arr2[0] = 99; // OK: 可修改

// ========== 场景 B：显式只读切片（.rodata） ==========
int![] const_slice = [1, 2, 3];
// 类型: int![]（只读切片）
// 内存: .rodata
// const_slice[0] = 99; // Error: 只读

// ========== 场景 C：切片引用 ==========
int[] slice = arr;
// 类型: int[]（切片）
// 内存: 栈上（引用 arr）
slice[0] = 100; // OK: 修改 arr

// ========== 栈数组隐式转换为切片 ==========
func process(int[] data) {
    data[0] = 999;
}
process(arr); // OK: 自动隐式转换

// ========== 元组（值类型，栈上） ==========
var tuple = (1, 3.14, true);
// 类型: (int, float, bool)（值类型）
// 内存: 栈上
var first = tuple[0];  // 1
var second = tuple[1]; // 3.14
var third = tuple[2];  // true
```

---

## 9. 总结

根据方案B，C^ 的数组字面量设计通过 **"值类型优先"** 和 **"视图类型显式"**，形成了完美闭环：

1. **数组字面量** → 栈上 + `Type[N]`（值类型，可修改）
2. **显式只读切片** → `.rodata` + `Type![]`（只读，零成本）
3. **切片引用** → 引用已有数据（可写，视图）
4. **元组** → 栈上 + `(T1, T2)`（值类型，可修改）

**设计特点：**
- ✅ 完美一致性：数组和元组都是值类型，默认在栈上
- ✅ 符合直觉：`[1, 2, 3]` 和 `(1, 2, 3)` 都是值
- ✅ 简单优雅：不需要 `Type[$]` 语法，默认就是栈数组
- ✅ 可修改性：默认数组是可修改的，更实用
- ✅ 完美闭环：值类型默认栈，视图类型显式声明

这种设计既保持了 C^ 语言的简洁性，又实现了完美的一致性和闭环！
