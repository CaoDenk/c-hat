# 可执行程序生成方案

## 日期
2026-02-16

## 概述

本文档详细说明了 c-hat 编译器如何利用现有的 LLVM 工具链（llc.exe）在 Windows 平台上生成可执行程序（.exe），包括两种方案：
1. **方案 A**：链接 C 运行时库（MSVCRT/UCRT）
2. **方案 B**：直接调用 Windows 系统 API（无 C 库依赖）

---

## 方案概述

### 编译流程

```
c-hat 源代码 (.ch)
    ↓
[c-hat 编译器]
    ↓
LLVM IR (.ll)
    ↓
[llc.exe] → 目标文件 (.obj)
    ↓
[链接器] → 可执行文件 (.exe)
```

### 方案对比

| 特性 | 方案 A（链接 C 库） | 方案 B（直接 Win32 API） |
|------|---------------------|-------------------------|
| 依赖 | MSVCRT/UCRT | kernel32.dll, user32.dll 等 |
| 可执行文件大小 | 较大（包含 C 运行时） | 较小 |
| 易用性 | 高（可使用 printf 等） | 中（需直接调用 API） |
| 标准库 | 可使用 C 标准库 | 需自己实现 I/O |
| 推荐场景 | 一般应用 | 嵌入式/极简场景 |

---

## 方案 A：链接 C 运行时库

### 工具链需求

1. **llc.exe** - LLVM 静态编译器（已安装在 `D:\Library\clang+llvm-x86_64-pc-windows-...`）
2. **link.exe** - MSVC 链接器（来自 Visual Studio 或 Build Tools）
   - 或使用 **lld-link.exe**（LLVM 链接器，与 llc 在同一目录）

### 编译步骤

#### 步骤 1：c-hat 编译器生成 LLVM IR

```powershell
# 编译 c-hat 源代码，生成 LLVM IR
.\c-hat.exe .\examples\hello.ch --emit-llvm -o hello.ll
```

#### 步骤 2：llc 编译为目标文件

```powershell
# 使用 llc 将 LLVM IR 编译为 COFF 目标文件
llc.exe -filetype=obj -O2 hello.ll -o hello.obj
```

#### 步骤 3：链接生成可执行文件

使用 **lld-link**（推荐，与 llc 配套）：

```powershell
lld-link.exe hello.obj ^
  /LIBPATH:"C:\Program Files (x86)\Windows Kits\10\Lib\10.0.xxxxx.0\um\x64" ^
  /LIBPATH:"C:\Program Files (x86)\Windows Kits\10\Lib\10.0.xxxxx.0\ucrt\x64" ^
  /LIBPATH:"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.xx.xxxxx\lib\x64" ^
  /SUBSYSTEM:CONSOLE ^
  /ENTRY:mainCRTStartup ^
  kernel32.lib user32.lib ucrt.lib msvcrt.lib ^
  /OUT:hello.exe
```

或使用 **MSVC link.exe**：

```powershell
link.exe hello.obj ^
  /LIBPATH:"..." ^
  /SUBSYSTEM:CONSOLE ^
  /ENTRY:mainCRTStartup ^
  kernel32.lib ucrt.lib msvcrt.lib ^
  /OUT:hello.exe
```

### 示例：Hello World（方案 A）

```c
// hello.ch
extern "C" {
    func printf(byte^ format, ...) -> int;
}

func main() -> int {
    printf("Hello, World!\n");
    return 0;
}
```

---

## 方案 B：直接调用 Windows API（无 C 库）

### 优势

1. **零依赖**：不依赖 MSVCRT/UCRT
2. **更小的可执行文件**
3. **完全控制**：直接使用 Windows 系统调用

### Windows API 基础知识

#### 1. 控制台输出

使用 `WriteConsoleA` 或 `WriteFile`：

```
kernel32.dll!GetStdHandle(nStdHandle)
kernel32.dll!WriteConsoleA(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, ...)
```

#### 2. 控制台输入

使用 `ReadConsoleA` 或 `ReadFile`：

```
kernel32.dll!ReadConsoleA(hConsoleInput, lpBuffer, nNumberOfCharsToRead, ...)
```

#### 3. 退出程序

```
kernel32.dll!ExitProcess(uExitCode)
```

### 示例：Hello World（方案 B）

```c
// hello_win32.ch

// Windows API 声明
extern "C" {
    // 标准句柄
    const long STD_OUTPUT_HANDLE = -11;
    const long STD_INPUT_HANDLE = -10;
    
    // 获取标准句柄
    func GetStdHandle(long nStdHandle) -> void^;
    
    // 写控制台
    func WriteConsoleA(
        void^ hConsoleOutput,
        void^ lpBuffer,
        long nNumberOfCharsToWrite,
        long^ lpNumberOfCharsWritten,
        void^ lpReserved
    ) -> bool;
    
    // 退出进程
    func ExitProcess(long uExitCode) -> void;
}

func main() -> int {
    // 获取标准输出句柄
    void^ hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    
    // 要输出的字符串
    byte^ msg = "Hello, World from Win32!\n";
    long len = 24;  // 字符串长度
    long written = 0;
    
    // 写控制台
    WriteConsoleA(hStdOut, msg, len, ^written, null);
    
    // 退出
    ExitProcess(0);
    return 0;
}
```

### 链接步骤（方案 B）

```powershell
# 1. 生成 LLVM IR
.\c-hat.exe hello_win32.ch --emit-llvm -o hello_win32.ll

# 2. 编译为目标文件
llc.exe -filetype=obj -O2 hello_win32.ll -o hello_win32.obj

# 3. 链接（只需要 kernel32.lib，不需要 C 库！）
lld-link.exe hello_win32.obj ^
  /LIBPATH:"C:\Program Files (x86)\Windows Kits\10\Lib\10.0.xxxxx.0\um\x64" ^
  /SUBSYSTEM:CONSOLE ^
  /ENTRY:main ^
  kernel32.lib ^
  /NODEFAULTLIB ^  // 不链接默认库
  /OUT:hello_win32.exe
```

---

## 实现计划

### 阶段 1：LLVM IR 生成完善

1. **完善函数声明**
   - 支持 `extern "C"` 声明
   - 支持可变参数（...）
   - 正确的调用约定（cdecl）

2. **完善 main 函数处理**
   - 识别 `main()` 作为入口点
   - 或支持自定义入口点

### 阶段 2：代码生成驱动

在 `c-hat` 编译器中添加命令行选项：

```powershell
# 新的命令行选项
.\c-hat.exe [options] <input.ch>

Options:
  --emit-llvm        只输出 LLVM IR (.ll)
  --emit-obj         输出目标文件 (.obj)，调用 llc
  -o <file>          指定输出文件
  --optimize, -O     优化级别 (-O0, -O1, -O2, -O3)
  --help             显示帮助
```

### 阶段 3：自动调用工具链

在编译器中添加自动编译流程：

```cpp
// 伪代码
void compileAndLink(const std::string &inputFile, const std::string &outputExe) {
  // 1. 生成 LLVM IR
  std::string irFile = outputExe + ".ll";
  generateLLVMIR(inputFile, irFile);
  
  // 2. 调用 llc 生成 .obj
  std::string objFile = outputExe + ".obj";
  runCommand("llc.exe -filetype=obj -O2 " + irFile + " -o " + objFile);
  
  // 3. 调用链接器生成 .exe
  runLinker(objFile, outputExe);
}
```

---

## 实现细节

### 1. 工具路径检测

编译器需要能找到以下工具：

```
llc.exe          → D:\Library\clang+llvm-x86_64-pc-windows-...\bin\llc.exe
lld-link.exe     → 同一目录下的 lld-link.exe
                  或 fallback 到 MSVC link.exe
```

检测策略：
1. 检查环境变量 `PATH`
2. 检查常见安装路径
3. 允许用户通过 `--llc-path` 和 `--linker-path` 选项指定

### 2. Windows SDK 和库路径自动检测

需要找到：
- Windows Kits 库路径
- MSVC 库路径（方案 A）

可以通过注册表或环境变量检测：
- `VSINSTALLDIR`
- `WindowsSdkDir`
- `VCToolsInstallDir`

### 3. c-hat 标准库（基础 I/O）

为了方便使用，我们可以提供一个最小的标准库：

```c
// std/io.ch (c-hat 标准库)
namespace std {
    func print(byte![] s) {
        // 调用 Win32 API 或 printf
    }
    
    func println(byte![] s) {
        print(s);
        print("\n");
    }
    
    func readLine() -> byte![] {
        // 调用 Win32 API 或 fgets
    }
}
```

---

## 推荐实现顺序

1. **第一阶段**：实现方案 B（直接 Win32 API）
   - 不依赖 C 库，更容易调试
   - 实现简单的 Hello World
   - 验证整个流程

2. **第二阶段**：添加方案 A（链接 C 库）
   - 支持 printf、malloc 等
   - 完善 extern "C" 支持

3. **第三阶段**：自动化工具链调用
   - 在 c-hat 编译器中自动调用 llc 和链接器
   - 一键生成 .exe

---

## 总结

两种方案都可行：
- **方案 A**：适合一般用途，可使用 C 标准库
- **方案 B**：适合极简/嵌入式场景，直接调用 Win32 API

推荐先实现**方案 B**验证流程，再添加**方案 A**支持！
