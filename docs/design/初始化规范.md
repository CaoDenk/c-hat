# C^ 初始化规范 (Initialization Specification)

## 1. 核心原则

为了消除 C++ 中初始化语法混乱（`()`, `{}`, `=`, `List{}`）的问题，C^ 制定了严格且统一的初始化规则。

我们坚持以下**符号语义分离**原则：
*   **`=`**：用于 **值赋值** (Basic Types)。
*   **`[]`**：用于 **序列/集合** (Arrays, Lists)。
*   **`{}`**：用于 **对象配置/属性赋值** (Object Initializers)。

## 2. 详细规范

### 2.1 基本类型 (Primitive Types)

基本类型使用 `=` 进行初始化。对于基本类型，C^ **不支持**使用 `{}` 进行初始化。

*   **`=` (赋值)**：标准的初始化方式。
*   **`{}` (禁止)**：`{}` 在 C^ 中专门用于对象属性初始化器 (Object Initializers)，基本类型没有属性，因此不能使用 `{}`。这避免了 C++ 中 `int x{10}` 和 `int x = 10` 的冗余。

```cpp
// 推荐
int a = 10;
char c = 'A';
float f = 3.14;

// 错误示例
// int x { 10 }; // Error: braces are for object properties only
// char y { 'B' }; // Error
```
// 默认初始化 (Zero Initialization)
// C^ 保证所有未显式初始化的变量都被置零，不会出现随机垃圾值
int d; // d == 0
```

### 2.2 数组与集合 (Arrays & Collections)

所有线性数据结构（数组、切片、列表）**必须**使用 `[]` 初始化。**禁止**使用 `{}`。

```cpp
// 1. 数组/切片
int[] arr = [1, 2, 3];         // OK
// int[] arr = {1, 2, 3};      // Error: {} is for objects

// 2. 固定大小数组
int[3] fix = [1, 2, 3];        // OK

// 3. 集合类型 (List, Vector)
// 只要类型提供了接受 T[] 的构造函数，就可以使用 []
List<int> list = [1, 2, 3];    // OK
```

### 2.3 类 (Classes) - 引用类型

类是引用类型，初始化必须明确包含 **实例化** 和 **配置** 两个步骤。

#### 2.3.1 实例化语法

必须使用 `new` 关键字（对于堆对象）或构造函数语法。

```cpp
// 调用默认构造函数
Person^ p = new Person(); 

// 调用带参构造函数
Person^ p = new Person("Alice", 30);
```

#### 2.3.2 对象初始化器 (Object Initializers)

使用 `{}` 来进行**属性/字段的后置配置**。这仅仅是 `set` 访问器的语法糖。

```cpp
// 语法：new Type { Property = Value, ... }
Person^ p = new Person { 
    Name = "Bob", 
    Age = 20 
};
```

#### 2.3.3 禁止隐式赋值初始化 (`A a = {}`)

**规则**：C^ **不支持** `Type var = { ... }` 这种 C/C++ 风格的聚合初始化。

**理由**：
1.  **类型模糊**：`= {}` 隐藏了类型信息，过度依赖左值推导。
2.  **语义混淆**：容易与代码块或 JSON 混淆。
3.  **一致性**：强制要求 `new` 或构造函数，使对象创建行为在代码中显眼且统一。

```cpp
// 错误示例
// Person p = { "Alice", 30 };        // Error: No C-style aggregate init
// Person p = { Name = "Alice" };     // Error: Missing 'new Person'

// 正确示例
Person p = new Person { Name = "Alice" }; // OK: Explicit instantiation
```

### 2.4 结构体 (Structs) - 值类型

结构体通常在栈上分配。虽然它是值类型，但为了保持与 Class 的语法一致性，我们也**禁止**隐式聚合初始化。

```cpp
public struct Point {
    public int x;
    public int y;
    public Point(int x, int y) { ... }
}

// 1. 构造函数初始化 (推荐)
Point p = Point(10, 20);

// 2. 默认构造 + 对象初始化器
Point p = Point { x = 10, y = 20 };

// 3. 错误写法
// Point p = { 10, 20 };      // Error: No aggregate init
// Point p = { x = 10 };      // Error: Missing type name
```

## 3. 总结表

| 类型          | 推荐写法                       | 禁止写法               | 备注              |
| :------------ | :----------------------------- | :--------------------- | :---------------- |
| **基本类型**  | `int x = 10;`                  | `int x(10);`           | 保持 C 风格简单性 |
| **数组**      | `int[] a = [1, 2];`            | `int[] a = {1, 2};`    | `[]` 专用于序列   |
| **类 (Heap)** | `var p = new Person { Id=1 };` | `Person p = { Id=1 };` | 必须显式 `new`    |
| **结构体**    | `Point p = Point(1, 2);`       | `Point p = { 1, 2 };`  | 必须显式类型名    |

## 4. 字符串初始化 (String Initialization)

`string` 在 C^ 中虽然是内置类型，但其行为类似对象（有构造函数）。为了方便使用，我们特化了赋值语法。

### 4.1 赋值初始化 (Assignment)

```cpp
// 推荐：这是最自然的写法，调用 string(cstring) 构造函数
const string s = "hello"; 
```

### 4.2 构造函数初始化 (Constructor)

```cpp
// 也是合法的，显式调用构造函数
// 等价于 const string s = "hello";
string s("hello"); 
```

### 4.3 禁止花括号初始化 (No Brace Init)

C^ **禁止**使用 `{}` 来初始化字符串，以避免与对象属性初始化器 (`Object Initializer`) 混淆。

```cpp
// 错误！C^ 不支持这种 C++ 风格的 Uniform Initialization
// const string s{"hello"}; 
```

**结论**：`const string s = "hello"` 是标准写法。`const string s{"hello"}` 是**非法语法**。这消除了 C++ 中 `()` vs `{}` 的困扰。

## 5. 类型推导与变量声明

### 5.1 类型推导规则

C^ 的类型推导遵循以下严格规则：

1. **var 和 let 的使用限制**
   - 使用 `var` 或 `let` 时，**必须**有初始值，否则无法推导类型
   - 没有初始值的变量必须显式指定类型

2. **类型推导仅限于局部变量**
   - 在函数体内部（局部变量）可以使用 `var` 和 `let` 进行类型推导
   - 在类或结构体的成员变量声明中，**必须**显式指定类型，不能使用类型推导

```cpp
// 正确示例
func foo() -> void {
  var x = 42;          // OK: 局部变量，有初始值，可以推导
  let pi = 3.14;        // OK: 局部变量，有初始值，可以推导
  int y;                // OK: 显式指定类型
}

class Person {
  string name;           // OK: 成员变量，显式指定类型
  int age;               // OK: 成员变量，显式指定类型
  
  // 错误示例：成员变量不能使用类型推导
  // var id;              // Error: 没有初始值，无法推导
  // let score = 100;     // Error: 成员变量不能使用 var/let，必须显式指定类型
}

struct Point {
  int x;                 // OK: 显式指定类型
  int y;                 // OK: 显式指定类型
}
```

### 5.2 总结

| 变量位置     | 允许类型推导 | 必须有初始值         | 必须显式指定类型     |
| :----------- | :----------- | :------------------- | :------------------- |
| **局部变量** | ✅ 是         | 使用 var/let 时 ✅ 是 | 使用 var/let 时 ❌ 否 |
| **成员变量** | ❌ 否         | ❌ 否                 | ✅ 是                 |
