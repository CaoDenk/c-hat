# C^ 类设计文档

## 1. 类的基本概念

### 1.1 类的定义

C^ 采用**成员修饰符风格**（类似 Java/C#），而非 C++ 的块状风格。这使得每个成员的定义更加独立和原子化。

*   **默认可见性**：如果不写修饰符，默认为 `internal`（当前模块/包内可见）。
*   **`public`**：对外部模块可见。
*   **`private`**：仅当前类内部可见。
*   **`protected`**：当前类及其子类可见。
*   **`internal`**：当前模块/包内可见（默认）。

> **关于 friend**：C^ 移除了 C++ 的 `friend` 关键字。我们认为 `friend` 破坏了封装性，且容易导致紧耦合。
> 推荐使用 `internal` 修饰符来实现模块内的友元访问，或者通过公开受控的接口。

```cpp
public class Person {
    // 私有字段 (官方推荐：后缀下划线，利于补全)
    private string name_;
    private int age_;

    // 公开属性
    public get name => name_;      // 显式 getter
    public set name(string v) => name_ = v; // 显式 setter

    // 公开方法
    public func say_hello() {
        print($"Hello, I'm {name_}");
    }
    
    // 内部辅助方法 (默认 internal)
    func calculate_tax() -> int {
        return age_ * 10;
    }
}
```

> **注意**：C^ 强制要求每个成员单独声明访问修饰符，**不支持** C++ 的 `public:` 块状语法。这有利于代码重构和阅读。

### 1.2 `const` vs `let`

C^ 严格区分编译期常量和运行时不可变性。

*   **`const`**：编译期常量 (Compile-time Constant)。等价于 C++ `static constexpr` 或 C# `const`。必须在声明时初始化，且值必须在编译期已知。
*   **`let`**：运行时不可变绑定 (Runtime Immutable Binding)。等价于 C++ `const type`。

```cpp
public class MathConstants {
    // 编译期常量 (隐含 static)
    public const PI = 3.14159;
    
    // 运行时不可变字段
    public let id: int;
    
    public MathConstants(int id) {
        self.id = id; // let 字段只能在构造函数中赋值一次
    }
}
```

### 1.3 属性 (Properties)

C^ 采用分离式属性语法，将 `get` 和 `set` 视为独立的方法声明。

*   **Getter**：`access_modifier get Name -> Type`
*   **Setter**：`access_modifier set Name(Type value)`

```cpp
public class Counter {
    private int _count;

    // Getter
    public get count -> int {
        return _count;
    }

    // Setter
    public set count(int v) {
        if (v >= 0) _count = v;
    }
}
```

### 1.4 Struct vs Class

C^ 严格区分 `struct` 和 `class`，赋予它们完全不同的语义（类似 C#，但更底层）。

| 特性         | struct                            | class                                  |
| :----------- | :-------------------------------- | :------------------------------------- |
| **语义**     | **值类型 (Value Type)**           | **引用/对象类型 (Reference Type)**     |
| **内存**     | 栈上分配，或内嵌在对象中          | 通常堆分配 (通过 `new`)，或栈上 (RAII) |
| **继承**     | **不支持** (但支持 `enum : type`) | **支持** (单继承 + 接口)               |
| **复用**     | **支持嵌入 (Embedding)**          | **支持继承 (Inheritance)**             |
| **虚函数**   | **不支持** (无 vtable)            | **支持**                               |
| **默认访问** | Public                            | Internal                               |
| **用途**     | 高性能数据结构、数学向量、POD     | 业务逻辑、资源管理、多态               |

#### Struct 嵌入 (Composition over Inheritance)
虽然 struct 不支持继承，但支持**匿名嵌入**来实现字段和方法的复用。

```cpp
public struct Point {
    public int x;
    public int y;
    public func reset() { x = 0; y = 0; }
}

public struct Pixel {
    // 嵌入 Point
    public Point; 
    public int color;
}

// 使用
Pixel p;
p.x = 10;    // 直接访问嵌入字段
p.reset();   // 直接调用嵌入方法
```

```cpp
// 紧凑的内存布局，无对象头开销
public struct Vector3 {
    public float x;
    public float y;
    public float z;
    
    // 结构体也可以有方法
    public func length() -> float {
        return sqrt(x*x + y*y + z*z);
    }
}

// 此时 v 在栈上，占用 12 字节
// 使用构造函数或对象初始化器
Vector3 v = Vector3 { x = 1.0f, y = 2.0f, z = 3.0f };
// 或者如果定义了构造函数：Vector3 v(1.0f, 2.0f, 3.0f); 
```

## 7. 不可变成员函数与 Mutable

为了保证不可变对象的线程安全性和逻辑正确性，C^ 引入了类似于 C++ 的不可变成员函数机制（即 C++ 的 const 成员函数），但语法更加统一。

### 7.1 不可变成员函数 (`self!`)

在 C^ 中，我们不使用 `const` 后缀修饰函数，而是直接在 `self` 参数上标记不可变性。

*   **语法**：`func method(self!)`
*   **语义**：在函数体内，`self` 是只读的，无法修改成员变量。

```cpp
class Vector {
    int x;
    int y;

    // 只读方法：self! 表示 self 是不可变的
    public func length(self!) -> float {
        // x = 10; // Error: cannot assign to immutable field
        return sqrt(x*x + y*y);
    }

    // 可变方法：默认 self 是可变的 (self&)
    public func set(int new_x, int new_y) {
        x = new_x;
        y = new_y;
    }
}
```

### 7.2 `mutable` 关键字

在极少数情况下（如缓存、互斥锁），我们需要在常量成员函数中修改特定成员。C^ 引入 `mutable` 关键字来豁免不可变性检查。

```cpp
class Widget {
    // 逻辑状态
    int size;
    
    // 物理状态（缓存）：标记为 mutable
    mutable int cached_area;
    mutable bool is_area_valid;

    public func area(self!) -> int {
        if (!is_area_valid) {
            // 在 self! 方法中修改 mutable 成员是合法的
            cached_area = size * size;
            is_area_valid = true;
        }
        return cached_area;
    }
}
```

### 7.3 Lambda 中的 Mutable

默认情况下，Lambda 捕获的值（按值捕获）在 Lambda 体内是只读的。使用 `mutable` 修饰符可以允许修改捕获的副本。

```cpp
int x = 10;
var f = [x]() mutable {
    x++; // OK: 修改的是副本
    print(x);
};
{
    public ushort source_port;
    public ushort dest_port;
    public uint sequence_num;
    public uint ack_num;
    
    // 位域定义
    public byte data_offset : 4;
    public byte reserved    : 3;
    public byte ns_flag     : 1;
    // ...
}
```

### 1.4 类的实例化

* **栈实例**：`Person p;` 在栈上分配内存
* **堆实例**：`Person^ p = new Person();` 在堆上分配内存
* **初始化**：实例化时会调用构造函数

```cpp
// 栈实例
Person p;
p.name = "Alice";
p.age = 30;

// 堆实例
Person^ p2 = new Person();
p2->name = "Bob";
p2->age = 25;
delete p2; // 手动释放内存
```

### 1.3 访问控制

* **public**：公开成员，任何地方都可以访问
* **private**：私有成员，只有类内部可以访问
* **protected**：保护成员，类内部和派生类可以访问
* **internal**：默认访问级别，当前模块/包内可见

> **注意**：C^ 仅支持 `public` 继承。因此，在继承声明中**不需要**（也不允许）指定 `public` 关键字。所有基类的 public/protected 成员在派生类中保持原有的访问权限。

```cpp
public class Base {
    public int public_member;
    protected int protected_member;
    private int private_member;
}

// 默认就是 public 继承，无需写 : public Base
public class Derived : Base {
    public func access_members() {
        public_member = 1; // 可以访问
        protected_member = 2; // 可以访问
        // private_member = 3; // 不能访问
    }
}
```

## 2. 构造函数与析构函数

### 2.1 构造函数

* **语法**：与类同名的特殊方法
* **作用**：初始化对象状态
* **重载**：支持构造函数重载
* **默认构造函数**：如果没有定义构造函数，编译器会生成默认构造函数

```cpp
public class Person {
    private string name_;
    private int age_;

    // 默认构造函数
    public Person() {
        name_ = "";
        age_ = 0;
    }
    
    // 带参数的构造函数
    public Person(string name, int age) {
        name_ = name;
        age_ = age;
    }
    
    // 委托构造函数
    public Person(string name) : Person(name, 0) {
    }
}

// 实例化
Person p1; // 调用默认构造函数
Person p2("Alice", 30); // 调用带参数的构造函数
Person p3("Bob"); // 调用委托构造函数
```

### 2.2 析构函数

* **语法**：`~ClassName()` 或 `~ { }` (极简写法)
* **作用**：清理对象资源
* **调用时机**：对象销毁时自动调用
* **内存释放**：堆对象的析构函数在 `delete` 时调用

```cpp
public class FileHandler {
    private FILE^ file_;

    public FileHandler(string filename) {
        file_ = fopen(filename.c_str(), "r");
    }
    
    // 极简析构
    public ~ {
        if (file_ != null) {
            fclose(file_);
        }
    }
}

// 使用
func main() {
    FileHandler handler("test.txt");
    // 离开作用域时自动调用析构函数
}
```

### 2.3 拷贝构造函数

* **语法**：`ClassName(const ClassName& other)`
* **作用**：从现有对象创建新对象
* **默认生成**：如果没有定义，编译器会生成默认拷贝构造函数
* **深拷贝**：对于包含指针的类，需要实现深拷贝

```cpp
class String {
    private char^ data_;
    private int length_;
public:
    public String(const char* str) {
        length_ = strlen(str);
        data_ = new char[length_ + 1];
        strcpy(data_, str);
    }
    
    // 拷贝构造函数
    public String(const String& other) {
        length_ = other.length_;
        data_ = new char[length + 1];
        strcpy(data_, other.data_);
    }
    
    public ~ {
        delete[] data_; // 释放字符数组
    }
};
```

### 2.4 移动构造函数

* **语法**：`ClassName(ClassName~ other)`
* **作用**：从临时对象转移资源，避免拷贝开销
* **移动语义**：使用 `~` 后缀标记移动引用，摒弃了 C++ 令人困惑的 `&&`。

```cpp
class String {
    private char^ _data;
    private int _length;
public:
    // 移动构造函数
    public String(String~ other) {
        _data = other._data;
        _length = other._length;
        other._data = null;
        other._length = 0;
    }
};

// 使用移动构造函数
String create_string() {
    return String("Hello");
}

func main() {
    String s = create_string(); // 调用移动构造函数
}
```

## 3. 属性

### 3.1 属性的定义

* **语法**：分离式 `get` / `set` 声明
* **作用**：提供对字段的访问控制和逻辑处理

```cpp
public class Person {
    private int _age;
    public string name; // 公开字段 (POD)
    
    // 属性访问器
    public get age => _age;
    public set age(int v) {
        if (v >= 0) _age = v;
    }
    
    // 只读属性
    public get is_adult => _age >= 18;
};

// 使用属性
Person p;
p.name = "Alice";
p.age = 30; // 调用 set 访问器
printf("Is adult: %d\n", p.is_adult); // 调用 get 访问器
```

### 3.2 访问控制

可以为 get 和 set 指定不同的访问权限。

```cpp
public class Person {
    private string name_;

    public get name => name_;
    
    // 私有 setter
    private set name(string v) {
        name_ = v;
    }
    
    public Person(string name) {
        self.name = name; // 内部调用 private setter
    }
}
```

### 3.3 (已移除 Field 关键字)

C^ 移除了 `field` 关键字。属性必须显式操作后备字段。

```cpp
// 旧设计已废弃
// public int age { get { return field; } }
```

## 4. 方法

### 4.1 实例方法

* **语法**：在类内部定义的函数
* **self 关键字**：使用 `self` 关键字指代当前对象实例（而非指针）
* **调用方式**：通过对象实例调用

```cpp
class Calculator {
public:
    public int add(self!, int a, int b) { // 显式 self! (只读)
        return a + b;
    }
    
    public int multiply(int a, int b) { // 隐式 self
        return a * b;
    }
    
    public func print_info(self!) {
        // 使用 self 访问成员
        // print(self.name); 
    }
};

// 调用实例方法
Calculator calc;
int sum = calc.add(1, 2);
int product = calc.multiply(3, 4);
```

### 4.2 静态方法

* **语法**：使用 `static` 关键字定义
* **特点**：不依赖于对象实例，没有 `self`
* **调用方式**：通过类名直接调用

```cpp
class Math {
public:
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static int max(int a, int b) {
        return a > b ? a : b;
    }
};

// 调用静态方法
int sum = Math.add(1, 2);
int maximum = Math.max(3, 4);
```

### 4.3 虚方法

* **语法**：使用 `virtual` 关键字定义
* **作用**：支持多态，派生类可以覆盖基类方法
* **覆盖**：派生类使用 `override` 关键字覆盖基类方法

```cpp
class Shape {
public:
    public virtual func draw() {
        printf("Drawing shape\n");
    }
    
    public virtual ~Shape() {
    }
};

class Circle : Shape {
public:
    public override func draw() {
        printf("Drawing circle\n");
    }
};

// 多态调用
Shape^ shape = new Circle();
shape->draw(); // 调用 Circle::draw()
delete shape;
```

### 4.4 抽象方法

* **语法**：使用 `abstract` 关键字定义
* **特点**：没有实现，派生类必须实现
* **抽象类**：包含抽象方法的类是抽象类，不能实例化

```cpp
class Shape {
public:
    public abstract func draw();
    
    public virtual ~Shape() {
    }
};

class Rectangle : Shape {
public:
    public override func draw() {
        printf("Drawing rectangle\n");
    }
};

// Shape s; // 错误：不能实例化抽象类
Shape^ s = new Rectangle(); // 正确：可以实例化派生类
s->draw();
```

### 4.5 密封方法 (Final)

* **语法**：使用 `final` 关键字修饰函数名之前
* **作用**：防止派生类覆盖该方法
* **位置**：`final` 关键字位于 `func` 之前，与 `override` / `virtual` 同级。

```cpp
public class Base {
    public virtual func method() {
        printf("Base::method\n");
    }
    
    // final 位于 func 之前
    public final func final_method() {
        printf("Base::final_method\n");
    }
}

public class Derived : Base {
    public override func method() {
        printf("Derived::method\n");
    }
    
    // override func final_method() { } // 错误：不能覆盖 final 方法
}
```

## 5. 运算符重载

### 5.1 基本语法

* **语法**：`access_modifier func operator op(params) { }`
* **作用**：为类定义自定义运算符行为
* **self 关键字**：在参数列表中使用 `self` 指代当前类类型，清晰表达操作数位置。

```cpp
class Vector {
private:
    int x_;
    int y_;
public:
    public Vector(int x, int y) : x_(x), y_(y) {
    }
    
    // 重载 + 运算符 (成员函数形式，左操作数为 self)
    // 相当于: operator+(self&, const Vector& other)
    public func operator+(self!, const Vector& other) -> Vector {
        return Vector(self.x_ + other.x_, self.y_ + other.y_);
    }

    // 重载 + 运算符 (支持 int + Vector)
    // 相当于: operator+(int scalar, self&)
    // 注意：self 必须显式声明类型修饰符
    public static func operator+(int scalar, self!) -> Vector {
        return Vector(self.x_ + scalar, self.y_ + scalar);
    }

    // 重载 + 运算符 (支持 Vector + int)
    public func operator+(self!, int scalar) -> Vector {
        return Vector(self.x_ + scalar, self.y_ + scalar);
    }
    
    // 重载 << 运算符（友元/静态函数）
    // 必须使用 explicit type 或 self
    public static func operator<<(ostream& os, self!) -> ostream& {
        os << "(" << self.x_ << ", " << self.y_ << ")";
        return os;
    }
};

// 使用重载的运算符
Vector v1(1, 2);
Vector v2(3, 4);
Vector v3 = v1 + v2; // 调用 operator+(self, Vector)
Vector v4 = 10 + v1; // 调用 operator+(int, self)
cout << v3 << endl;  // 调用 operator<<
```

### 5.2 常见运算符重载

* **算术运算符**：`+`, `-`, `*`, `/`, `%`
* **比较运算符**：`==`, `!=`, `<`, `>`, `<=`, `>=`
* **赋值运算符**：`=`, `+=`, `-=`, `*=`, `/=`
* **索引运算符**：`[]`
* **函数调用运算符**：`()`

```cpp
class Vector {
public:
    // 重载 == 运算符
    public bool operator==(Vector! other) {
        return x_ == other.x_ && y_ == other.y_;
    }
    
    // 重载 [] 运算符
    public int& operator[](int index) {
        if (index == 0) return x_;
        if (index == 1) return y_;
        throw "Index out of bounds";
    }
};
```

## 6. 嵌套类

### 6.1 嵌套类的定义

* **语法**：在类内部定义另一个类
* **作用**：封装相关的类，提高代码组织性
* **访问控制**：嵌套类可以访问外部类的私有成员

```cpp
public class Outer {
    private int value_;
    
    public class Inner {
        private Outer^ outer_;
        
        public Inner(Outer^ outer) : outer_(outer) {
        }
        
        public func access_outer() {
            outer_->value_ = 42; // 可以访问外部类的私有成员
        }
    }
    
    public Outer() : value_(0) {
    }
    
    public get value => value_;
}

// 使用嵌套类
Outer outer;
Outer::Inner inner(&outer);
inner.access_outer();
printf("Outer value: %d\n", outer.value);
```

### 6.2 静态嵌套类

* **语法**：在类内部定义的静态类
* **特点**：不依赖于外部类实例
* **访问**：只能访问外部类的静态成员

```cpp
public class Outer {
    public static int static_value;
    
    public static class StaticInner {
        public func access_outer() {
            static_value = 42; // 可以访问外部类的静态成员
        }
    }
}

int Outer.static_value = 0;

// 使用静态嵌套类
Outer.StaticInner inner;
inner.access_outer();
printf("Static value: %d\n", Outer.static_value);
```

## 7. 类的设计原则

### 7.1 单一职责原则

* **定义**：一个类应该只有一个引起它变化的原因
* **优点**：提高代码的可维护性和可测试性
* **实践**：将不同职责的代码分离到不同的类中

### 7.2 开放封闭原则

* **定义**：类应该对扩展开放，对修改封闭
* **优点**：提高代码的稳定性和可扩展性
* **实践**：使用抽象类和接口，通过继承扩展功能

### 7.3 里氏替换原则

* **定义**：子类应该能够替换父类而不影响程序的正确性
* **优点**：保证继承体系的正确性
* **实践**：子类应该保持父类的行为契约

### 7.4 依赖倒置原则

* **定义**：依赖于抽象，而不是具体实现
* **优点**：提高代码的灵活性和可测试性
* **实践**：使用接口和抽象类作为依赖

### 7.5 接口隔离原则

* **定义**：客户端不应该依赖它不需要的接口
* **优点**：减少类之间的耦合
* **实践**：将大接口拆分为小接口

## 8. 最佳实践

1. **封装**：将数据和行为封装在类内部，通过接口暴露功能
2. **继承**：合理使用继承，避免深层继承层次
3. **多态**：使用虚函数实现多态，提高代码的灵活性
4. **组合**：优先使用组合而非继承，减少耦合
5. **命名**：使用清晰、描述性的类名和成员名
6. **大小**：控制类的大小，避免过大的类
7. **构造函数**：保持构造函数简单，避免复杂初始化逻辑
8. **析构函数**：确保析构函数正确清理资源，避免内存泄漏
9. **运算符重载**：只在有意义的情况下重载运算符
10. **测试**：为类编写单元测试，确保功能正确

C^ 的类设计结合了 C++ 的灵活性和现代语言的特性，为程序员提供了强大的面向对象编程能力，同时保持了高性能和低开销。