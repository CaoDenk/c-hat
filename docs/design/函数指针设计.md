# C^ 函数指针设计文档

## 1. 概述

C^ 提供一等的“函数指针类型”，用于表达 **不捕获** 的可调用目标（C ABI 兼容、零额外开销），并通过类型前置的写法消除 C 语言 `int (*p)(...)` 的括号迷宫。

## 2. 函数指针基础

### 2.1 语法

* **函数指针类型**：`func(param_types) -> ret_type`
* **声明函数指针变量**：`func(int, int) -> int op;`
* **获取函数地址**：使用前缀 `^` 取址（例如 `^add`）
* **调用函数指针**：直接像调用函数一样使用（例如 `op(1, 2)`）

说明：

- `func(...) -> R` 表示“指向代码的薄指针”，不携带捕获环境
- 需要捕获的可调用对象使用 lambda（闭包）或其他对象类型承载

### 2.2 基本示例

```cpp
func add(int a, int b) -> int {
    return a + b;
}

func subtract(int a, int b) -> int {
    return a - b;
}

func main() {
    // 声明函数指针
    func(int, int) -> int op;
    
    // 赋值为 add 函数地址
    op = ^add;
    int sum = op(10, 5); // 结果为 15
    
    // 赋值为 subtract 函数地址
    op = ^subtract;
    int diff = op(10, 5); // 结果为 5
}
```

## 3. 函数指针作为参数

### 3.1 语法

当函数指针作为参数时，直接使用 `func(...) -> R`：

### 3.2 示例：回调函数

```cpp
func add(int a, int b) -> int {
    return a + b;
}

func multiply(int a, int b) -> int {
    return a * b;
}

func compute(int a, int b, func(int, int) -> int op) -> int {
    return op(a, b);
}

func main() {
    int result1 = compute(10, 5, ^add);      // 结果为 15
    int result2 = compute(10, 5, ^multiply); // 结果为 50
}
```

### 3.3 示例：排序回调

```cpp
struct Person {
    string name;
    int age;
};

func byAge(Person a, Person b) -> bool {
    return a.age < b.age;
}

func byName(Person a, Person b) -> bool {
    return a.name < b.name;
}

func sort(Person[] people, func(Person, Person) -> bool compare) {
    // 排序算法实现
}

func main() {
    Person[] arr = ...;
    sort(arr, ^byAge);  // 按年龄排序
    sort(arr, ^byName); // 按姓名排序
}
```

## 4. 函数指针作为返回值

### 4.1 语法

当函数指针作为返回值时，直接返回 `func(...) -> R`。

### 4.2 示例：工厂函数

```cpp
func add(int a, int b) -> int {
    return a + b;
}

func subtract(int a, int b) -> int {
    return a - b;
}

func getOperation(string op) -> func(int, int) -> int {
    if (op == "+") {
        return ^add;
    } else if (op == "-") {
        return ^subtract;
    }
    return null;
}

func main() {
    func(int, int) -> int op = getOperation("+");
    int result = op(10, 5); // 结果为 15
}
```

## 5. 函数指针的类型别名

使用 `using` 可以为复杂的函数指针类型创建别名，提高可读性：

```cpp
using BinaryOp = func(int, int) -> int;

func add(int a, int b) -> int {
    return a + b;
}

func compute(int a, int b, BinaryOp op) -> int {
    return op(a, b);
}

func main() {
    BinaryOp op = ^add;
    int result = compute(10, 5, op);
}
```

## 6. 函数指针数组

### 6.1 示例：函数表

```cpp
func add(int a, int b) -> int {
    return a + b;
}

func subtract(int a, int b) -> int {
    return a - b;
}

func multiply(int a, int b) -> int {
    return a * b;
}

func divide(int a, int b) -> int {
    return a / b;
}

func main() {
    func(int, int) -> int[] ops = [^add, ^subtract, ^multiply, ^divide];
    
    int result = ops[2](10, 5); // 调用 multiply，结果为 50
}
```

## 7. 设计原则

### 7.1 语法一致性

- `func(...) -> R` 避免 C 风格括号噪声，读写顺序与 `func name(...) -> R` 一致
- 取址统一使用前缀 `^expr`，与变量/数组元素取址一致
- 调用仍使用 `op(args...)`，不引入额外语法

### 7.2 零成本抽象

- `func(...) -> R` 在底层实现上与 C 函数指针完全一致
- 不引入额外的运行时开销
- 与 C/C++ 函数指针完全二进制兼容

### 7.3 类型安全

- 函数指针的类型包括返回类型和所有参数类型
- 编译器进行严格的类型检查，防止类型不匹配
- 支持类型别名，提高代码可读性

## 8. 与 C/C++ 的互操作性

### 8.1 与 C 函数指针互操作

C^ 的 `func(...) -> R` 与 C 的 `R (*)(...)` 完全二进制兼容：

```cpp
// C 头文件视角
// typedef int (*C_BinaryOp)(int, int);
// int call_c_func(C_BinaryOp op, int a, int b);

// C^ 声明
extern "C" {
    func call_c_func(func(int, int) -> int op, int a, int b) -> int;
}

func add(int a, int b) -> int {
    return a + b;
}

func main() {
    int result = call_c_func(^add, 10, 5);
}
```

## 9. 最佳实践

1. **使用类型别名**：为回调类型起一个明确的名字（`using Compare = func(T, T) -> bool;`）
2. **保持不捕获**：需要捕获状态时用 lambda/对象，不要把状态塞进全局
3. **空值检查**：作为可选回调返回时，调用前先判断是否为 `null`

## 10. 完整示例

```cpp
using MathFunc = func(int, int) -> int;

func add(int a, int b) -> int {
    return a + b;
}

func subtract(int a, int b) -> int {
    return a - b;
}

func multiply(int a, int b) -> int {
    return a * b;
}

func applyOperation(int a, int b, MathFunc op) -> int {
    return op(a, b);
}

func getOperation(string name) -> MathFunc {
    match (name) {
        "add" => return ^add,
        "subtract" => return ^subtract,
        "multiply" => return ^multiply,
        default => return null,
    }
}

func main() {
    // 基本用法
    MathFunc addFunc = ^add;
    int sum = addFunc(10, 5);
    
    // 作为参数
    int product = applyOperation(10, 5, ^multiply);
    
    // 作为返回值
    MathFunc subFunc = getOperation("subtract");
    int diff = subFunc(10, 5);
}
```
