# C^ 标准库分层架构：从公理到大厦

本文档阐述 C^ 标准库是如何从最底层的语言公理（Axioms）一步步构建起来的。这种分层设计确保了语言核心的纯净性，并赋予了开发者完全掌控系统的能力。

## 架构概览

标准库大厦由下至上分为四层。每一层都只依赖于比它更底层的层级，严禁反向依赖。

| 层级 | 名称 | 包含内容 | 依赖关系 | 核心特征 |
| :--- | :--- | :--- | :--- | :--- |
| **L3** | **生态扩展层** (Ecosystem) | `IO`, `Net`, `Async`, `File` | 依赖 L2 | 操作系统绑定，富功能 |
| **L2** | **动态管理层** (Dynamic) | `String`, `List<T>`, `Box<T>`, `Map` | 依赖 L1 + Heap | 涉及堆内存分配，RAII |
| **L1** | **核心抽象层** (Core) | `Slice<T>`, `Option<T>`, `Result`, `Range` | 依赖 L0 | **零依赖**，纯逻辑抽象，栈/寄存器操作 |
| **L0** | **语言公理层** (Axioms) | `int`, `bool`, `ptr`, `array`, `literal_view` | **无依赖** | 编译器内置原语，物理事实 |

---

## Level 0: 语言公理 (The Axioms)

这一层不是库，而是**物理事实**。它们是编译器直接感知的类型，不存在于任何头文件中。

### 1. 基础标量 (Scalars)
*   `int`, `uint`, `float`, `bool`, `char` (32-bit Unicode scalar).
*   这些是 CPU 寄存器直接操作的单元。

### 2. 内存原子 (Memory Atoms)
这是 C^ 与其他高级语言最大的不同点。我们认为数组和指针是构建世界的原子，而非标准库封装的类。

*   **`T^` (Pointer)**: 内存地址。不包含长度，不包含所有权，只是一个数字。
*   **`T[N]` (Array)**: **固定大小的连续内存块**。
    *   地位：**内置值类型**。
    *   语义：它是栈上（或结构体内）的一块肉。`int[3]` 的大小就是 12 字节。
    *   作用：它是所有数据结构的存储基石。
*   **`literal_view`**: **只读代码段视图**。
    *   地位：**内置原语**。
    *   结构：内部仅包含 `{ ptr: byte!^, len: usize }`。
    *   作用：它是字符串字面量（如 `"hello"`）的物理形态，是构建字符串库的起点。

---

## Level 1: 核心抽象 (The Core)

这一层是“标准库”的起点。它完全运行在栈上，不触碰堆内存，因此可以在任何环境（包括裸机、OS 内核）中使用。

### 1. 切片 (Slice<T>) —— 数组的通用接口
虽然 `T[N]` 是基础类型，但它太死板（长度固定）。`Slice<T>` 是 L1 层最重要的抽象。

*   **定义**：它是对 L0 层 `ptr` 和 length 的结构化封装。
*   **去魔法化**：编译器并不强制要求 `Slice` 必须叫这个名字，只要它符合结构布局。但在标准库中，我们定义了它。
*   **作用**：它统一了对 `T[N]` (栈数组) 和 `literal_view` (静态数据) 的访问方式。

```cpp
// L1 层构建代码示例
struct Slice<T> {
    var ptr: T^;
    var len: usize;
    
    // L1 层的方法只涉及指针运算，不分配内存
    func operator[](usize index) -> T& {
        check_bounds(index); // 简单的断言
        return *(ptr + index);
    }
}
```

### 2. 词汇类型 (Vocabulary Types)
*   `Option<T>`: 替代 Null 指针。
*   `Result<T, E>`: 替代异常机制。
*   `Range`: 如 `0..10`，用于循环。

---

## Level 2: 动态管理层 (The Dynamic Layer)

这一层引入了 **Heap (堆)** 和 **Allocator (分配器)**。这是“现代编程”开始的地方。

### 1. 字符串 (String)
`String` 是 L2 层的典型代表。它不再只是一个视图（L0/L1），它拥有资源的所有权。

*   **构建方式**：
    *   它内部持有一个 `Slice<byte>`（L1 能力）。
    *   它引入了 `Capacity` 概念。
    *   它实现了 `Unshare/COW` 机制（依赖堆分配器）。
    *   它提供了从 `literal_view` (L0) 构造的能力。

```cpp
struct String {
    // 组合 L1 的 Slice
    var view: Slice<byte>; 
    var capacity: usize;
    
    // 依赖 L0 的 literal_view 进行初始化
    public String(literal_view lit) {
        // 优化：对于字面量，直接指向 L0 的静态内存，处于 Static 模式
        this.view.ptr = lit.ptr;
        this.view.len = lit.len;
        this.capacity = 0; // 标记为 Static/RoData
    }
}
```

### 2. 动态列表 (List<T>)
*   本质是 `T[N]` (L0) 的动态版本。
*   使用 L1 的 `Slice<T>` 作为其对外视图。

---

## Level 3: 生态扩展层 (The Ecosystem)

这一层与操作系统强绑定。

*   **IO**: `File`, `Console`。它们将 L2 的 `String` 或 L1 的 `Slice<byte>` 传递给 OS 的系统调用。
*   **Async**: `Task`, `Future`。
*   **Net**: `Socket`, `Http`.

---

## 总结：构建大厦的艺术

C^ 的设计不仅是为了提供好用的库，更是为了展示**如何构建**这些库。

1.  **L0 (公理)** 提供了物理材料：内存块 (`array`)、地址 (`ptr`)、常量数据 (`literal_view`)。
2.  **L1 (核心)** 提供了逻辑胶水：用 `Slice` 统一访问接口，用 `Option` 处理逻辑分支。
3.  **L2 (动态)** 赋予了生命：管理资源生命周期，实现自动扩容和所有权管理。
4.  **L3 (生态)** 连接了世界：与外部系统交互。

用户可以随时切入任何一层。写 OS 内核时，你可能只用 L0 和 L1；写业务系统时，你大量使用 L2 和 L3。这就是 C^ 的**统一性**与**灵活性**。
