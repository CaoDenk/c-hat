
# C^ 引用设计文档

## 1. 引用基础

C^ 中的引用设计采用了 **`&` 符号** 来表达引用语义，与 C++ 类似但有重要改进。引用设计的核心目标是：

1. **副作用可见**：在调用处显式标记可变引用传递，让代码审查者一眼看出参数可能被修改
2. **与指针区分清晰**：使用 `&` 表示引用，`^` 表示指针，避免混淆
3. **安全便捷**：可变引用必须显式标记，不可变引用可以隐式传递，既安全又便捷

### 1.1 可变引用 (Mutable Reference)

* **用途**：允许函数修改传入的参数
* **语法**：使用 `&` 后缀修饰类型
* **声明**：`type& param`
* **调用**：必须显式使用 `&` 前缀标记参数，如 `f(&a)`

```cpp
// 声明：接受可变引用参数
func increment(int& x) {
    x++; // 直接修改外部变量
}

func main() {
    int a = 42;
    increment(&a); // 必须显式使用 & 标记，警示副作用
    // 此时 a 为 43
}
```

### 1.2 不可变引用 (Immutable Reference)

* **用途**：高效读取参数，但保证不修改
* **语法**：使用 `!&` 后缀（不可变类型 + 引用）
* **声明**：`type!& param`
* **调用**：可以直接传递变量（推荐），也允许显式使用 `&`（但建议警告）

```cpp
// 声明：接受不可变引用参数
func print_value(int!& x) {
    // x++; // Error: 无法修改不可变引用
    print(x); // 可以读取
}

func main() {
    int a = 42;
    print_value(a); // 推荐：直接传递，因为是只读的（无副作用）
    print_value(&a); // 允许，但建议警告：对不可变引用使用 & 会误导读者
}
```

### 1.3 返回引用

* **用途**：函数返回对某个对象的引用
* **语法**：返回类型使用 `&` 后缀
* **返回**：必须显式使用 `&` 前缀标记返回表达式

```cpp
class Counter {
private:
    int value = 0;
public:
    func get_value(self) -> int& {
        return &self.value; // 必须显式使用 &
    }
};

func main() {
    Counter c;
    c.get_value() = 42; // 可以通过返回的引用修改值
}
```

## 2. 引用设计原则

### 2.1 副作用可见性

C^ 引用设计的核心理念是 **"显式副作用"**。在 C++ 中，仅看到 `foo(x)` 无法判断 `x` 是否会被修改，而在 C^ 中：

- `foo(&x)` → 明确表示 `x` 可能被修改（可变引用）
- `foo(x)` → 明确表示 `x` 不会被修改（要么是值传递，要么是不可变引用）

这让代码的可读性和可维护性大幅提升。

### 2.2 与指针的区分

C^ 严格区分引用和指针：

| 特性            | 引用 (`&`)     | 指针 (`^`)             |
| --------------- | -------------- | ---------------------- |
| 声明            | `type&`        | `type^`                |
| 取地址/创建引用 | `&expr`        | `^expr`                |
| 用途            | 别名、避免拷贝 | 内存地址操作、动态分配 |
| 可为 null       | ❌ 永远有效     | ✅ 可以为 null          |
| 重新绑定        | ❌ 不能         | ✅ 可以                 |

```cpp
// 引用 vs 指针对比
func demo() {
    int x = 42;
    
    // 引用：别名，不能重新绑定
    int& r = &x;
    r = 100; // 修改 x
    // int y = 200;
    // r = &y; // Error: 不能重新绑定引用
    
    // 指针：可以重新绑定
    int^ p = ^x;
    p^ = 100; // 修改 x
    int y = 200;
    p = ^y; // 可以重新绑定
}
```

### 2.3 引用的生命周期

引用必须始终指向有效的对象：

```cpp
int& bad_func() {
    int x = 42;
    return &x; // Error: 返回局部变量的引用，生命周期结束
}

int& good_func(int& x) {
    return &x; // OK: 返回传入的引用，生命周期由调用者保证
}
```

## 3. 引用与函数

### 3.1 引用参数

```cpp
// 交换两个整数
func swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

func main() {
    int x = 1;
    int y = 2;
    swap(&x, &y); // 必须显式使用 &
    // x = 2, y = 1
}
```

### 3.2 大对象传递

对于大型对象，使用不可变引用可以避免拷贝开销：

```cpp
class BigObject {
    // 包含大量数据
};

// 使用不可变引用，避免拷贝
func process_big_object(BigObject!& obj) {
    // 读取 obj，但不修改
}

func main() {
    BigObject big;
    process_big_object(big); // 推荐：隐式传递，方便且安全
}
```

### 3.3 引用与重载

#### 3.3.1 可变引用 vs 不可变引用

引用可以参与函数重载：

```cpp
func foo(int& x) {
    print("可变引用");
}

func foo(int!& x) {
    print("不可变引用");
}

func main() {
    int a = 42;
    foo(a); // 调用不可变引用版本（无副作用默认）
    foo(&a); // 调用可变引用版本（显式表达允许修改）
}
```

#### 3.3.2 不可变引用 vs 值传递（禁止同时重载）

**设计规则**：不允许同时存在值传递和不可变引用的重载，避免歧义。

```cpp
// 错误：不能同时存在值传递和不可变引用的重载
func foo(int x) { }        // Error: 不能与 foo(int!&) 同时存在
func foo(int!& x) { }

// 只能选择其中一个：
func foo(int x) { }        // 值传递
// 或者
func foo(int!& x) { }     // 不可变引用

// 如果需要两者，可以重命名函数来区分：
func foo_by_value(int x) { }
func foo_by_ref(int!& x) { }
```

**理由**：
1. 简单明确，没有歧义
2. 符合"显式"设计理念
3. 避免意外行为

**允许的重载组合**：
- `foo(int&)` 和 `foo(int!&)` ✅ 允许
- `foo(int)` 和 `foo(int&)` ✅ 允许
- `foo(int)` 和 `foo(int!&)` ❌ 不允许

## 4. 引用与类

### 4.1 self 引用

成员函数中，`self` 是对当前对象的引用，不需要显式写 `self&`：

```cpp
class Person {
private:
    string name;
public:
    func set_name(self, string new_name) {
        self.name = new_name; // self 自动是引用
    }
    
    func get_name(self!) -> string!& {
        return &self.name; // 返回不可变引用
    }
};
```

### 4.2 常成员函数（两种标记方式）

C^ 支持两种方式标记不可变成员函数：

#### 方式 1：在参数列表中标记 `self!`（推荐）

```cpp
class Person {
public:
    func get_name(self!) -> string {
        return self.name; // 不能修改 self
    }
    
    func set_name(self, string name) {
        self.name = name; // 可以修改 self
    }
};
```

#### 方式 2：在函数名后面标记 `!`

```cpp
class Person {
public:
    func get_name()! -> string {
        return self.name; // 不能修改 self
    }
    
    func set_name(self, string name) {
        self.name = name; // 可以修改 self
    }
};
```

#### 两种方式可以共存

两种标记方式是等价的，都表示该函数不会修改对象。

**同时使用两种方式会产生警告（冗余），但不会报错**：

```cpp
class Person {
public:
    // 警告：冗余的不可变限定符
    func get_name(self!)! -> string {
        return self.name;
    }
};
```

**设计理由**：
1. 两种方式都支持，给用户选择自由
2. 方式 1 与普通参数的不可变标记 `int!` 一致
3. 方式 2 与 C++ 的 `const` 成员函数类似，用户熟悉
4. 同时使用时警告而不是错误，给用户更好的体验

## 5. 引用与表达式

### 5.1 引用作为左值

引用可以作为左值使用：

```cpp
func get_ref(int& x) -> int& {
    return &x;
}

func main() {
    int a = 42;
    get_ref(a) = 100; // 通过返回的引用赋值
}
```

### 5.2 引用初始化

引用必须在声明时初始化：

```cpp
func main() {
    int x = 42;
    int& r1 = &x; // OK
    int!& r2 = &x; // OK
    int!& r3 = x; // OK（不可变引用初始化时也可以隐式）
    
    // int& r2; // Error: 引用必须初始化
}
```

## 6. 引用与移动语义

### 6.1 引用与右值

**所有引用（可变和不可变）都不能绑定到临时对象（右值）**：

```cpp
func foo(int& x) { }
func bar(int!& x) { }

func main() {
    // foo(42); // Error: 不能将临时对象绑定到可变引用
    // bar(42); // Error: 不能将临时对象绑定到不可变引用
    int x = 42;
    foo(&x); // OK
    bar(x); // OK
}
```

### 6.2 右值引用

右值引用使用 `~` 符号（详见移动语义设计文档）：

```cpp
func foo(string~ s) {
    // s 是右值引用，可以接管资源
}

func main() {
    foo(string("hello")); // OK: 临时对象
    string s = "world";
    foo(s~); // OK: 显式移动
}
```

## 7. 引用与类型系统

### 7.1 引用类型的结构

引用类型在 AST 中的表示：
- `ReferenceType`：表示引用类型，包含一个 `baseType` 字段
- `ReadonlyType`：表示不可变类型，也包含一个 `baseType` 字段

**类型组合顺序**：
- `int!&` 表示 `ReadonlyType(ReferenceType(PrimitiveType(int)))`
- 即：先有引用，再是不可变

```cpp
// 不可变引用
int!& ref1; // Readonly(Reference(int))

// 数组引用
int[]& ref2; // Reference(Array(int))

// 指针的引用
int^& ref3; // Reference(Pointer(int))

// 泛型引用
T& ref4; // Reference(T)
```

### 7.2 引用表达式（RefExpr）

调用点的 `&expr` 会创建一个 `RefExpr` 表达式节点：

```cpp
func main() {
    int x = 42;
    &x; // RefExpr 节点，类型为 int&
}
```

`RefExpr` 的语义：
- 只能作用于可寻址的左值（变量、成员访问等）
- 不能作用于临时对象（右值）
- 结果类型为 `T&`，其中 `T` 是 `expr` 的类型

### 7.3 引用的类型推导

使用 `var` 或 `let` 可以自动推导引用类型：

```cpp
func main() {
    int x = 42;
    var r = &x; // r 的类型是 int&
    let cr = &x; // cr 的类型是 int!&（let 自动添加不可变）
}
```

### 7.4 类型转换规则

**隐式转换**：
- `T&` → `T!&`：可变引用可以隐式转换为不可变引用
- `T` → `T!&`：值可以隐式转换为不可变引用（仅限函数参数传递）

**显式转换**：
- `T!&` → `T&`：需要显式转换（不安全，不推荐）

```cpp
func takes_immutable(int!& x) { }
func takes_mutable(int& x) { }

func main() {
    int x = 42;
    int& r = &x;
    
    takes_immutable(r); // OK: T& → T!& 隐式转换
    takes_immutable(x); // OK: T → T!& 隐式转换
    
    int!& cr = &x;
    // takes_mutable(cr); // Error: 不能隐式转换
}
```

## 8. 语义分析检查

### 8.1 引用参数检查

在 `SemanticAnalyzer::analyzeFunctionCall` 中进行以下检查：

1. **可变引用参数检查**：
   - 如果形参类型是 `T&`，则实参必须是 `RefExpr`（即必须显式使用 `&`）
   - 如果实参不是 `RefExpr`，报错："可变引用参数必须显式使用 & 标记"

2. **不可变引用参数检查**：
   - 如果形参类型是 `T!&`，则实参可以是：
     - 普通值（隐式转换）
     - `RefExpr`（允许，但建议警告）
   - 如果实参是 `RefExpr`，发出警告："对不可变引用参数使用 & 会误导读者"

3. **右值绑定检查**：
   - 所有引用参数（可变和不可变）都不能绑定到临时对象（右值）
   - 如果实参是右值，报错："引用不能绑定到临时对象"

### 8.2 RefExpr 检查

在 `SemanticAnalyzer::analyzeRefExpr` 中进行以下检查：

1. **左值检查**：
   - `&expr` 中的 `expr` 必须是可寻址的左值
   - 如果 `expr` 是右值，报错："& 只能作用于可寻址的左值"

2. **类型推导**：
   - `RefExpr` 的类型是 `T&`，其中 `T` 是 `expr` 的类型

### 8.3 引用初始化检查

在 `SemanticAnalyzer::analyzeVariableDecl` 中进行以下检查：

1. **可变引用初始化**：
   - 如果变量类型是 `T&`，则初始化表达式必须是 `RefExpr`

2. **不可变引用初始化**：
   - 如果变量类型是 `T!&`，则初始化表达式可以是：
     - `RefExpr`
     - 普通值（仅限局部变量声明，不能是函数返回值）

3. **必须初始化**：
   - 所有引用类型变量必须在声明时初始化

### 8.4 返回引用检查

在 `SemanticAnalyzer::analyzeReturnStmt` 中进行以下检查：

1. **显式标记检查**：
   - 如果函数返回类型是引用类型，则返回表达式必须是 `RefExpr`（即必须显式使用 `&`）

2. **生命周期检查**：
   - 尽力检测返回局部变量引用的情况

## 9. 引用安全

### 9.1 悬垂引用

编译器会尽力检测悬垂引用：

```cpp
int& bad() {
    int x = 42;
    return &x; // 编译器警告或错误：返回局部变量的引用
}
```

### 9.2 引用别名

引用创建别名，修改引用会影响原对象：

```cpp
func main() {
    int x = 42;
    int& r = &x;
    r = 100; // x 也变成 100
}
```

## 10. 最佳实践

### 10.1 何时使用引用

1. **需要修改参数** → 使用可变引用 `type&`
2. **大对象只读访问** → 使用不可变引用 `type!&`
3. **返回内部成员** → 使用返回引用
4. **小对象** → 优先使用值传递

### 10.2 编码风格

```cpp
// 推荐：& 紧贴类型
func foo(int& x) { }

// 调用时 & 紧贴变量
foo(&x);
```

## 11. 与 C++ 的对比

| 特性           | C++              | C^                               |
| -------------- | ---------------- | -------------------------------- |
| 引用声明       | `int& x`         | `int& x`（语法相同，但语义不同） |
| 引用传递调用   | `foo(x)`（隐式） | `foo(&x)`（显式，仅可变引用）    |
| 不可变引用     | `const int& x`   | `int!& x`                        |
| 不可变引用调用 | `foo(x)`（隐式） | `foo(x)`（隐式，推荐）           |
| 副作用可见性   | ❌ 不可见         | ✅ 可见（可变引用必须显式）       |
| 指针符号       | `*`              | `^`                              |
| 引用符号       | `&`              | `&`                              |
| 右值绑定       | `const T&` 可以  | 所有引用都不可以                 |

## 12. 与 C# 的对比

| 特性           | C#           | C^               |
| -------------- | ------------ | ---------------- |
| 引用声明       | `ref int x`  | `int& x`         |
| 引用传递调用   | `foo(ref x)` | `foo(&x)`        |
| 不可变引用     | `in int x`   | `int!& x`        |
| 不可变引用调用 | `foo(x)`     | `foo(x)`（推荐） |
| 副作用可见性   | ✅ 可见       | ✅ 可见           |

## 13. AST 节点设计

### 13.1 ReferenceType

位置：`src/ast/types/ReferenceType.h`

```cpp
class ReferenceType : public Type {
public:
  ReferenceType(std::unique_ptr<Type> baseType);
  NodeType getType() const override { return NodeType::ReferenceType; }
  std::string toString() const override;
  std::unique_ptr<Type> baseType;
};
```

### 13.2 RefExpr（待创建）

位置：`src/ast/expressions/RefExpr.h`

```cpp
class RefExpr : public Expression {
public:
  RefExpr(std::unique_ptr<Expression> expr);
  NodeType getType() const override { return NodeType::RefExpr; }
  std::string toString() const override;
  std::unique_ptr<Expression> expr;
};
```

需要在 `NodeType` 枚举中添加 `RefExpr`。

## 14. 引用操作速查表

| 操作           | 语法            | 说明                     |
| -------------- | --------------- | ------------------------ |
| 声明可变引用   | `type& ref;`    | 声明可变引用             |
| 声明不可变引用 | `type!& ref;`   | 声明不可变引用           |
| 创建引用       | `&expr`         | 创建对 expr 的引用       |
| 传递可变引用   | `foo(&x)`       | 必须显式传递可变引用     |
| 传递不可变引用 | `foo(x)`        | 推荐：隐式传递不可变引用 |
| 传递不可变引用 | `foo(&x)`       | 允许，但建议警告         |
| 返回引用       | `return &expr;` | 返回对 expr 的引用       |

## 15. 设计决策回顾

参考设计决策文档：
- [005_引用语法选择_ref关键字vs符号.md](../choose/005_引用语法选择_ref关键字vs符号.md)
- [006_引用传参显式性规则_可变必显式只读可隐式.md](../choose/006_引用传参显式性规则_可变必显式只读可隐式.md)

C^ 选择了使用 `&` 符号而不是 `ref` 关键字，原因包括：

1. **符号一致性**：与 `!`（不可变）、`~`（移动）形成统一的符号标记体系
2. **副作用可见**：`&x` 在调用点清晰表意"可能被修改"
3. **不引入新关键字**：保持关键字集合的克制
4. **与指针严格区分**：`&` 用于引用，`^` 用于指针，降低混淆

同时采用"可变必显式，只读可隐式"的规则：
- `T&`：`f(&x)` 必须显式，保证副作用可见
- `T!&`：`f(x)` 作为主路径，`f(&x)` 允许但建议 warning

