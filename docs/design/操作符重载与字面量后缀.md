# C^ 操作符重载与自定义字面量设计

C^ 允许开发者通过操作符重载和自定义字面量后缀来扩展语言的表达能力。

## 1. 自定义字面量 (User-defined Literals)

为了支持特定领域的数值或对象表示（如物理单位、大数、特定编码字符串），C^ 允许用户定义字面量后缀。

### 1.1 语法规则
*   **形式**：`operator"" suffix`。
*   **开放命名**：除了内置的数值后缀（如 `f`, `l`, `u` 及其组合），用户可以定义**任意名称**的后缀，**无需下划线开头**。
    *   **保留后缀**：`f`, `l`, `u`, `F`, `L`, `U` 及其组合（如 `ul`, `LL`）。这些是语言内置的，不可重载。
    *   **推荐规范**：虽然允许任意名称，但建议避免使用可能与未来标准冲突的极短名称。
*   **参数类型**：支持整数、浮点数、字符和字符串。

### 1.2 标准库后缀 (Standard Library Suffixes)

为了支持 AI 和高性能计算，C^ 标准库利用本节所述的**自定义字面量机制**，提供了半精度浮点数支持。

*   `bf`：**BFloat16** (Brain Floating Point)。例如 `1.0bf`。
*   `fp`：**Float16** (IEEE 754 Half Precision)。例如 `1.0fp`。

```cpp
// 标准库实现示例 (伪代码)
public func operator"" fp(long double x) -> fp16 {
    return fp16(x);
}
```

### 1.3 示例：物理单位 (数值后缀)

```cpp
// 定义后缀 km (千米) -> 米
public func operator"" km(long double x) -> double {
    return (double)x * 1000.0;
}

// 定义后缀 s (秒) -> 秒
public func operator"" s(unsigned long long x) -> double {
    return (double)x;
}

func main() {
    double dist = 1.5km; // 1500.0
    double time = 30s;   // 30.0
    
    print("Speed: " + (dist / time) + " m/s");
}
```

### 1.4 字符串字面量：仅支持前缀 (Prefix Only)

**设计决策**：为了避免歧义并支持高级插值功能，C^ **规定字符串字面量仅支持前缀重载**，不支持后缀。

#### 为什么选择前缀？(Design Rationale)

1.  **组合性与清晰度 (Composability & Clarity)**
    *   C^ 的原始字符串使用 `#"..."#` 语法（禁用转义）。前缀能与此语法自然组合。
    *   **前缀模式**：`regex#"C:\Windows"#` —— 结构清晰，先声明意图（Regex），再提供内容（Raw String）。
    *   **后缀模式**：`#"C:\Windows"#regex` —— 语义重心后置，且在视觉上容易与结尾的 `#` 混淆。

2.  **插值一致性 (Interpolation Consistency)**
    *   这是 C^ 选择前缀的最核心理由。
    *   C^ 支持自定义插值语法 `$prefix"..."`（如 `$sql"..."`）。
    *   **前缀模式**：`$xml"<tag>{val}</tag>"` —— 视觉重心在开头，清晰表明这是一个 "XML 插值构建器"。
    *   **后缀模式**：`$"<tag>{val}</tag>"xml` —— 语义割裂，`$` 在头，`xml` 在尾，中间的插值逻辑由谁定义？非常混乱。

3.  **IDE 友好性 (IDE Support)**
    *   当用户输入 `xml"` 时，IDE 立刻知道后续内容是 XML，可以立即启用 XML 语法高亮和自动补全。
    *   如果是后缀模式 `"..."xml`，IDE 只有在用户敲完最后一个字符时才知道这是 XML，体验极差。

4.  **自然语言直觉**
    *   前缀类似函数调用 `func(arg)`（动词-宾语），如 `json"..."` 读作 "Parse JSON string"。
    *   后缀类似 `arg.func()`，但对于字面量来说，前缀的"构造器"语义更强。

#### 示例：自定义前缀

C^ 支持自定义**前缀**，用于改变字符串或字符的构造行为。

```cpp
// 1. 定义字符串前缀 json"..."
// 接收参数：原始 UTF-8 字节数组
public static func operator "json"(byte[] raw) -> JsonObject {
    return JsonParser.parse(string_view(raw));
}

// 2. 定义字符前缀 u8'...'
public static func operator "u8"(char code_point) -> byte {
    return (byte)code_point;
}

// 3. 结合插值 (自定义插值提案)
// 支持用户提出的 XML 构建场景
// var node = $xml"<add key='qos' value='{level}' />";
public static func operator "$xml"(usize len, usize args) -> XmlHandler {
    return XmlHandler(len, args);
}

func main() {
    // 语义清晰：先看到 json，通过 json 规则解析内容
    var config = json"{ \"id\": 1 }"; 
    
    var b = u8'A'; 
}
```

---

## 2. 操作符重载 (Operator Overloading)

C^ 支持大多数标准操作符的重载，但为了保持代码的可读性和理性，施加了一些限制。

### 2.1 核心原则：显式 Self 与可变性控制

为了实现比 C++ 更强大且优雅的控制力，C^ 要求在操作符重载中**显式声明 `self`**。

这不仅统一了语法，更重要的是赋予了开发者对 **"可变性 (Mutability)"** 的精确控制：
*   **`self`**：表示对象本身（隐式可变引用）。用于需要修改自身的操作符（如 `+=`, `++`, `[]`赋值）。
*   **`self!`**：表示对象只读（隐式不可变引用）。用于不修改自身的操作符（如 `+`, `==`, `[]`读取）。

```cpp
class Vector2 {
    public float x;
    public float y;

    // 1. 二元操作符：+
    // 语义：只读自身 (self!)，返回新对象
    public func operator+(self!, Vector2 rhs) -> Vector2 {
        return Vector2(self.x + rhs.x, self.y + rhs.y);
    }

    // 2. 复合赋值：+=
    // 语义：修改自身 (self)
    public func operator+=(self, Vector2 rhs) {
        self.x += rhs.x;
        self.y += rhs.y;
    }
    
    // 3. 判等：==
    // 语义：只读自身 (self!)
    public func operator==(self!, Vector2 rhs) -> bool {
        return self.x == rhs.x && self.y == rhs.y;
    }
}
```

### 2.2 可重载运算符列表 (Overloadable Operators)

以下运算符均支持重载。为了保持语义清晰，C^ 并没有像 Scala 那样允许定义任意符号的操作符，而是限定在一个固定的集合内。

| 类别       | 运算符                      | 说明                                                                         |
| :--------- | :-------------------------- | :--------------------------------------------------------------------------- |
| **算术**   | `+` `-` `*` `/` `%`         | 标准算术运算                                                                 |
| **位运算** | `&` `                       | ` `^` `~` `<<` `>>`                                                          | 标准位运算 (`~` 仅限前缀重载，后缀 `~` 为移动语义不可重载) |
| **逻辑**   | `!` `&&` `                  |                                                                              | `                                                          | `&&` 和 ` |  | ` 即使重载也**保留短路特性** (Short-circuiting) |
| **比较**   | `==` `!=` `<` `>` `<=` `>=` | 必须返回 `bool`                                                              |
| **赋值**   | `=` `+=` `-=` `*=` `/=` ... | 复合赋值运算符通常由编译器自动基于二元运算符生成，但也允许显式重载以优化性能 |
| **特殊**   | `[]` `()` `->`              | 下标、调用、成员访问 (Arrow)                                                 |
| **幂运算** | `**`                        | 右结合幂运算 (需库实现)                                                      |
| **自增减** | `++` `--`                   | 支持前缀和后缀                                                               |

### 2.3 特殊操作符详解

#### 下标操作符 `[]`
通过区分 `self` 和 `self!`，我们可以轻松实现下标的读写重载。

```cpp
class Array<T> {
    // 1. 读操作：arr[i]
    // 语义：self! (只读)
    public func operator[](self!, int index) -> T {
        return _data[index];
    }
    
    // 2. 写操作：arr[i] = val
    // 语义：self (可变)，返回引用
    // 注意：C^ 通常通过返回引用来支持赋值，或者定义 operator[]=
    public func operator[](self, int index) -> T& {
        return &_data[index];
    }
}
```

#### 函数调用操作符 `()`
```cpp
class Adder {
    // 语义：self! (无状态修改)
    public func operator()(self!, int a, int b) -> int {
        return a + b;
    }
}
```

#### 成员访问操作符 `->` (Arrow Operator)

C^ 允许重载 `->` 以支持智能指针和代理模式 (Proxy Pattern)。为了保持一致性，`operator->` 也必须显式声明 `self`（通常是 `self!`）。

*   **Drilling Down 规则**：
    *   `operator->` 必须返回一个**指针**（裸指针或智能指针）或者**另一个定义了 `operator->` 的对象**。
    *   当编译器遇到 `obj->member` 时，它会递归调用 `operator->`，直到获得一个裸指针 `T^`，然后访问 `T` 的 `member`。

```cpp
// 智能指针实现示例
class UniquePtr<T> {
    private T^ _ptr;

    // 重载 -> 返回裸指针
    // 显式声明 self! (只读)
    public func operator->(self!) -> T^ {
        return self._ptr;
    }
}

class Wrapper<T> {
    private UniquePtr<T> _uptr;

    // 重载 -> 返回 UniquePtr (它也重载了 ->)
    public func operator->(self!) -> UniquePtr<T> {
        return self._uptr;
    }
}

func main() {
    Wrapper<User> w = ...;
    // 编译器行为：
    // 1. w->name 调用 Wrapper.operator->(w) 返回 UniquePtr<User>
    // 2. UniquePtr.operator->(uptr) 返回 User^
    // 3. User^ 访问 name
    w->name = "Alice"; 
}
```

### 2.4 前缀与后缀运算符区分 (Prefix vs Suffix)

C^ 强制使用 **"显式 Self + 空操作数 (Void Operand)"** 规则来区分一元运算符的前缀和后缀形式。这种设计消除了隐式规则，实现了真正的 "所见即所得"。

#### 规则定义
一元运算符被视为一种特殊的二元函数，其中 `void` 关键字占据了缺失操作数的位置。

*   **Prefix (前缀)**：`op x`
    *   **映射**：`operator op(void, x)`
    *   **逻辑**：`void` 在左，`x` 在右。
    *   **成员函数**：`func operator op(void, self)`

*   **Suffix (后缀)**：`x op`
    *   **映射**：`operator op(x, void)`
    *   **逻辑**：`x` 在左，`void` 在右。
    *   **成员函数**：`func operator op(self, void)`

#### 示例代码

```cpp
class Number {
    public int val;

    // 1. 前缀自增：++n
    // 语义：void ++ self
    // 必须显式写出 void 和 self，且顺序不能错
    public func operator++(void, self) -> Number {
        self.val += 1;
        return self;
    }

    // 2. 后缀自增：n++
    // 语义：self ++ void
    // self 在前，void 在后，清晰对应 n++
    public func operator++(self, void) -> Number {
        var temp = self;
        self.val += 1;
        return temp;
    }
    
    // 3. 一元负号：-n (Prefix)
    // 语义：void - self! (只读)
    public func operator-(void, self!) -> Number {
        return Number(-self.val);
    }
}
```

> **设计哲学**：这种设计虽然比 C++ (`operator++()` vs `operator++(int)`) 多写了几个字符，但它彻底消除了"为什么 int 代表后缀"的困惑，并且让 `self` 的语义（默认引用）变得显式且可控。

### 2.7 静态 vs 成员 (Static vs Member)

**用户常见疑问**："操作符重载必须像 C# 那样是 `static` 的吗？"

**答案**：**不是**。C^ 灵活地支持两种方式，并推荐根据场景选择：

1.  **成员函数 (Member Function) —— 推荐默认方式**
    *   **适用场景**：操作符的左操作数是当前类实例（如 `vec1 + vec2`）。
    *   **优点**：可以直接访问私有成员；`self` 显式声明，语义清晰。
    *   **示例**：
        ```cpp
        class Vector {
            // 成员函数：self! + rhs
            public func operator+(self!, Vector rhs) -> Vector { ... }
        }
        ```

2.  **静态函数 (Static Function) / 扩展方法**
    *   **适用场景**：
        *   **字面量重载**：`operator "json"` 必须是 `static`。
        *   **扩展现有类型**：为 `double` 增加 `**` 运算符（你无法修改 `double` 的源码）。
        *   **对称性操作符**：左操作数不是类本身（如 `2.0 * vec`）。
    *   **示例**：
        ```cpp
        // 静态扩展：允许 2.0 * vec
        public static func operator*(double lhs, Vector rhs) -> Vector {
            return rhs * lhs; // 复用成员 operator*
        }
        ```

### 2.8 禁止重载的操作符

为了防止语言语义崩坏，以下操作符**禁止重载**：

*   `.` (成员访问) - **禁止重载**
*   `?:` (三元条件) - **禁止重载**
*   `sizeof` - **禁止重载**
*   `typeof` - **禁止重载**

注意：`::` (作用域解析符) 已被移除，C^ 统一使用 `.` 进行作用域访问。

### 2.6 幂运算符 `**`

C^ 语法层面预留了幂运算符 `**` 的解析支持（优先级高于乘除，右结合），但**核心语言并未定义其对基础类型（如 `int`, `double`）的默认行为**。

这意味着 `2 ** 3` 在没有任何库支持的情况下是非法的。这种设计是为了将幂运算的实现策略（是调用 `pow` 函数，还是快速幂算法，还是大数运算）完全交给标准库或第三方库来决定。

*   **优先级**：高于乘除 `*` `/`，右结合（Right-associative）。
    *   `2 * 3 ** 2` 解析为 `2 * (3 ** 2)`。
    *   `2 ** 3 ** 2` 解析为 `2 ** (3 ** 2)`。

```cpp
// 标准库或数学库扩展
class Math {
    // 为 double 类型提供幂运算扩展 (Extension Method)
    // 注意：C^ 允许通过扩展方法为基础类型增加操作符
    public static func operator**(double base, double exp) -> double {
        return std.math.pow(base, exp);
    }
}

func main() {
    // 只有引入了上述定义后，以下代码才合法
    double x = 2.0 ** 3.0; // 8.0
}
```

## 3. 总结

*   **自定义后缀**：支持强大的编译期或运行时转换。
*   **操作符重载**：语法直观，支持成员与全局两种形式，严格限制可重载集合以防滥用。
