# 异常捕获兜底方案设计

## 问题提出

在异常处理系统中，我们支持任意类型都可以作为异常抛出，那么：
- 如何设计一个兜底的方案来捕获所有类型的异常？
- 采用类似 C++ 的 `catch(...)` 方式是否合适？

## 推荐方案：类似 C++ 的 `catch(...)` 语法

我们推荐采用类似 C++ 的方式，使用 `catch(...)` 作为兜底方案：

```cpp
try {
    throw 42;
} catch (int e) {
    println("捕获到 int 类型异常: ", e);
} catch (...) {
    println("捕获到未知类型异常");
}
```

### 方案特点

1. **语法简洁，与 C++ 风格一致**
2. **按顺序匹配**：先匹配具体类型的 catch 块，最后由 `catch(...)` 兜底
3. **`catch(...)` 捕获所有未处理的异常**，但无法访问异常对象的值

## 完整示例

### 示例 1：使用 `catch(...)` 作为兜底
```cpp
func test_any_exception() {
    try {
        throw 42;  // 抛出 int 类型
        // throw "error message";  // 抛出 string 类型
        // throw true;  // 抛出 bool 类型
    } catch (int e) {
        println("捕获到 int 类型异常: ", e);
    } catch (string e) {
        println("捕获到 string 类型异常: ", e);
    } catch (bool e) {
        println("捕获到 bool 类型异常: ", e);
    } catch (...) {
        println("捕获到未知类型异常");
    }
}
```

### 示例 2：使用自定义类型作为异常
```cpp
class MyError {
    int code;
    string message;
    
    this(int code, string message) {
        this.code = code;
        this.message = message;
    }
}

func test_custom_exception() {
    try {
        throw MyError(404, "Not Found");
    } catch (MyError e) {
        println("错误代码: ", e.code);
        println("错误信息: ", e.message);
    } catch (...) {
        println("兜底捕获");
    }
}
```

## 语法设计

### 具体类型捕获
```cpp
catch (Type variable) {
    // 处理特定类型的异常
}
```

### 兜底捕获
```cpp
catch (...) {
    // 捕获所有未处理的异常，无法访问异常值
}
```

## 实现要点

### 1. 按顺序匹配
- catch 块按出现顺序进行匹配
- 第一个匹配的 catch 块会被执行
- 后续的 catch 块会被忽略
- `catch(...)` 必须放在最后

### 2. 类型匹配
- 精确类型匹配
- 不支持隐式类型转换（如 int 不能匹配 long）

### 3. 代码生成
- 在 LLVM IR 层面，需要保存异常的类型信息
- 对于 `catch(...)`，只需要知道有异常发生，不需要访问异常值

## 结论

采用类似 C++ 的 `catch(...)` 方式作为兜底方案是**合适的**，它具有：
- 简洁的语法
- 与 C++ 风格一致
- 按顺序匹配的清晰语义
- 良好的可读性

我们推荐采用这种设计。
