# C^ 构造与析构设计文档

为了解决 C++ 中构造函数样板代码多、类名重构困难等问题，C^ 引入了更现代、更优雅的生命周期管理语法。

## 1. 核心设计：类名构造与匿名析构

C^ 采用了更加极简的设计风格：构造函数回归类名（保持 C 系传统），而析构函数则极致简化。

*   **构造函数**：使用 **`ClassName(...)`**。保持了 C++/Java/C# 的习惯，一眼识别。
*   **析构函数**：使用 **`~ClassName()`**。必须包含类名和括号，保持与构造函数形式的一致性。

```cpp
class Window {
    // 构造函数
    public Window() {
        print("Window created");
    }

    // 析构函数
    public ~Window() {
        print("Window destroyed");
    }
}
```

## 2. 成员初始化语法糖 (Member Init Sugar)

这是 C^ 最"优雅"的特性之一。为了避免 `self.x = x` 这种毫无意义的重复，C^ 允许在参数列表中直接绑定成员。

### 2.1 初始化列表 (Initialization List)

为了保证对象的完全初始化和避免不必要的默认构造，C^ 采用了类似 C++ 的初始化列表语法，但更加严格。

*   **语法**：`constructor(...) : field(expr), ...`
*   **执行顺序**：初始化列表在构造函数体**之前**执行。
*   **强制性**：对于引用类型、`const` 字段或没有默认构造函数的成员，**必须**在初始化列表中初始化。

```cpp
class User {
    string name;
    int age;
    int id;

    // 推荐写法：使用初始化列表
    public User(string n, int a, int id_offset) 
        : name(n), age(a), id(100 + id_offset) 
    {
        // 构造函数体仅用于副作用（如打印日志）
        print("User " + name + " created");
    }
}
```

## 3. 基类构造与 `base` 关键字

在单继承模型下，引入 `base` 关键字是 C^ 的一项重要设计决策。

### 3.1 为什么使用 `base`？
1.  **解耦与重构友好**：当基类名称发生变化（例如 `class Button : Widget` 改为 `class Button : Control`）时，构造函数中的 `base(...)` 调用无需修改。
2.  **消除冗余**：避免了在每个构造函数中重复书写冗长的基类名称。
3.  **语义清晰**：在单继承语境下，`base` 明确指代唯一的父类，消除了歧义。

```cpp
class Derived : LongAndComplexBaseClassName {
    // 推荐：使用 base
    public Derived(int x) : base(x) { ... }
    
    // 不推荐（但兼容）：硬编码基类名
    // public Derived(int x) : LongAndComplexBaseClassName(x) { ... }
}
```

### 3.2 调用基类方法
`base` 同样用于在成员函数中调用被覆盖的基类方法：

```cpp
override func update() {
    base.update(); // 清晰调用父类逻辑
    // ... 子类逻辑 ...
}
```

## 4. 显式与隐式构造 (Explicit & Implicit)

C^ 对构造函数的隐式调用行为进行了严格控制，引入了 `explicit` 和 `implicit` 关键字。

### 4.1 默认规则：Explicit

默认情况下，单参数构造函数是 **explicit** 的。这意味着它**禁止**隐式转换。这与 C++ 相反（C++ 默认隐式），旨在防止意外的类型转换。

```cpp
class BigInt {
    public BigInt(int v) { ... }
}

func process(BigInt b) { ... }

// 错误！禁止隐式转换 int -> BigInt
// process(10); 

// 正确：必须显式调用构造函数
process(BigInt(10));
```

### 4.2 隐式许可：Implicit

如果你希望允许类似赋值的语法（如 `string s = "hello"`），必须将构造函数显式标记为 **`implicit`**。这通常用于“无损”或“自然”的类型转换（如从字面量构造）。

```cpp
class MyString {
    // 允许 implicit conversion from literal_view
    public implicit MyString(literal_view s) { ... }
}

func log(MyString s) { ... }

// 正确：允许隐式转换
log("System Start"); 
MyString s = "Hello";
```

## 5. 完整的生命周期示例

```cpp
class FileHandle {
    private int fd;
    public string path;

    // 1. 构造函数
    public FileHandle(string path) : path(path) {
        self.fd = open(path.c_str(), O_RDONLY);
        if (self.fd < 0) throw IOException("Failed to open file");
    }

    // 2. 析构函数 (RAII)
    public ~FileHandle() {
        if (self.fd >= 0) {
            close(self.fd);
            print("File closed");
        }
    }
}
```

## 6. 对象初始化器 (Object Initializers)

C^ 引入了对象初始化器 `{}`，用于在对象构造后立即设置公开字段或属性。

### 6.1 语义规则

表达式 `Type var  { key = value; }` 严格等价于：

1.  调用 `Type` 的**默认构造函数**（或无参构造函数）。
2.  依次对指定的 `key` 执行**属性赋值**（Setter）或**字段赋值**。

```cpp
class Window {
    public string title;
    public int width;
    public int height;

    public Window() { ... } // 必须有无参构造函数
}

// 对象初始化器写法
Window win = {
    title = "Main Window",
    width = 800,
    height = 600
};

// 等价于：
// Window win = Window();
// win.title = "Main Window";
// win.width = 800;
// win.height = 600;
```

### 6.2 限制与约束

*   **必须可写 (Setter)**：对于属性，**必须**拥有可访问的 `set` 访问器；对于字段，必须不是 `const` 或只读的。如果 `capacity` 只有 `get` 没有 `set`，则 `{ capacity = 100 }` 会导致**编译错误**。
*   **普通成员字段**：只要是 `public` 的普通字段（非属性），也可以直接在 `{}` 中赋值。
    *   **字段 vs 属性**：虽然字段可以直接赋值，但使用属性（Property）能提供更好的**封装性**（如校验值范围、触发事件等）。建议在库设计中优先使用属性。

```cpp
class Data {
    public int simple_field;      // 普通字段
    public int checked_prop {     // 属性
        get => _val;
        set { if (value > 0) _val = value; }
    }
    private int _val;
}

// 都可以初始化
Data d = { 
    simple_field = 10, 
    checked_prop = 20 
};
```

*   **仅限 Public 成员**：只能初始化 `public` 的字段或属性。
*   **必须有默认构造**：如果类没有无参构造函数，则无法使用 `{}` 初始化语法（除非作为结构体聚合初始化）。
*   **正交性**：`{}` 初始化与构造函数参数是正交的。你不能在 `{}` 中调用带参构造函数。

```cpp
// 错误示例
// Window w = { "Title", width = 100 }; // Error: 混淆了构造函数参数和属性赋值
```

## 7. 总结

*   **传统与现代结合**：保留类名构造，降低认知负担；使用 `~ClassName()` 标准析构，形式统一。
*   **简洁**：`User(...) : name(...)` 提供了清晰的初始化路径。
*   **清晰**：`base(...)` 明确指代父类构造。
