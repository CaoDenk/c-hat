# 设计决策 006：引用传参显式性规则（可变必显式，只读可隐式）

**日期**：2026-02-16  
**状态**：建议采纳

## 1. 背景

C^ 的引用语义最初对标 C# 的 `ref`：如果函数形参是“可修改的引用”，那么调用点必须显式标记，让阅读者一眼看出副作用风险。

与此同时，C^ 也引入了不可变类型修饰 `!`、移动/右值修饰 `~`、以及显式取址 `^` 等一套“表达式级显式标记”的体系。引用传参规则需要与这套体系保持一致，并且不能妨碍泛型与完美转发的实现。

相关文档：
- [005_引用语法选择_ref关键字vs符号.md](file:///d:/projects/CppProjs/c-hat/docs/choose/005_%E5%BC%95%E7%94%A8%E8%AF%AD%E6%B3%95%E9%80%89%E6%8B%A9_ref%E5%85%B3%E9%94%AE%E5%AD%97vs%E7%AC%A6%E5%8F%B7.md)
- [003_完美转发与显式引用的冲突.md](file:///d:/projects/CppProjs/c-hat/docs/choose/003_%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%BC%95%E7%94%A8%E7%9A%84%E5%86%B2%E7%AA%81.md)
- [函数设计.md](file:///d:/projects/CppProjs/c-hat/docs/design/%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1.md)

## 2. 设计目标

- **副作用可见**：调用点能直接看出“这个实参可能被修改”。
- **不强迫为只读付出噪声**：只读借用应当像普通传参一样自然。
- **别名关系可见**：返回引用时能直接看出“返回的是借用而非副本”。
- **与类型系统一致**：是否允许隐式，应由“是否可变/是否可能产生副作用”决定，而不是由“语法恰好是引用”决定。
- **不阻塞泛型与转发**：规则要能与 `(T&~)x` 的转发强转共存。

## 3. 规则（建议）

### 3.1 可变引用：必须显式 `&`

形参类型为 `T&`：

- 调用点必须写 `f(&x)`
- `f(x)` 报错

理由：`T&` 代表“允许被修改的借用”，显式 `&` 是对副作用的强提示。

### 3.2 只读引用：允许隐式，显式 `&` 允许但不推荐

形参类型为 `T!&`：

- 允许 `f(x)`（推荐）
- 同时允许 `f(&x)`，但建议给 warning：对 `T!&` 使用 `&` 会误导读者以为存在修改意图

理由：`T!&` 不允许写入，本质上没有“会被修改”的风险，允许隐式传递能显著减少噪声；而保留 `f(&x)` 作为可选写法，能在重载存在时提供显式选择空间（见 4.2）。

### 3.3 右值/移动：用 `~` 表达生命周期转移

形参类型为 `T~`：

- 允许 `f(临时值)`（例如 `f(T(...))`）
- 对命名变量需要显式 `f(x~)` 以表达资源转移

这与“副作用显式”同一哲学：`~` 让“生命周期在此结束/资源被接管”在调用点可见。

### 3.4 返回引用：不因只读而省略 `&`

若函数返回类型为 `T&` 或 `T!&`，`return` 语句必须写成 `return &expr;`。

理由：即使是只读引用，返回“借用”也会引入别名与生命周期约束。让 `&` 出现在 `return` 处，可以在审查时快速定位“这里返回的是引用而非值”，并减少把局部变量引用返回出去的误用风险。

## 4. 关键边界情形

### 4.1 `&` 仅用于把可寻址左值标记为“可变借用”

- `&x` 只能作用于可寻址的左值
- `&临时值` 不合法

这保持 `&` 的含义单一：把“普通左值”变成“可变引用实参”。

### 4.2 重载选择与显式意图

当存在：

```cpp
func f(int& x);
func f(int!& x);
```

推荐规则：

- `f(x)` 选择 `f(int!& x)`（无副作用默认）
- `f(&x)` 选择 `f(int& x)`（显式表达允许修改）

这让 `&` 成为明确的“我允许你修改它”的信号，而不是仅仅“我在传引用”。

### 4.3 与完美转发共存

在显式引用规则下，泛型“万能引用”场景应使用显式转发强转：

- 形参：`Args&~... args`
- 转发：`(Args&~)args`

这样既保留了调用点对 `T&` 的显式要求，也不会把转发变成调用点的噪声负担。

## 5. 结论

建议采用“**可变必显式，只读可隐式**”：

- `T&`：`f(&x)` 必须显式，保证副作用可见
- `T!&`：`f(x)` 作为主路径，`f(&x)` 允许但建议 warning

这同时满足“像 C# `ref` 一样显式表达可变借用”与“像现代语言一样让只读借用自然”的两类诉求，并与 C^ 的 `!`/`~` 显式语义体系一致。
