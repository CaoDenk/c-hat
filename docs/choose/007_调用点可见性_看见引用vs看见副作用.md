# 设计评估 007：调用点可见性（看见“传引用” vs 看见“会修改”）

**日期**：2026-02-16  
**状态**：评估中（推荐结论见第 6 节）

## 1. 问题陈述

在 C^ 的引用传参设计里，如果 `&` 前缀被定义为“允许修改（可变借用）”的显式信号，那么对只读引用 `T!&` 允许 `f(x)` 会带来一个现象：

- 调用点 `print_value(a)` 看不出它是“值传递”还是“只读引用传递”
- 调用点 `print_value(&a)` 看得出“显式借用”，但它又不会真的修改（因为形参是 `T!&`），容易误导

因此出现一个取舍问题：

> 在调用点，“看出来这是引用传递”更重要，还是“看出来会不会修改实参”更重要？

## 2. 两种“可见性”的本质差异

### 2.1 看见“会修改”（可变副作用）

这是 **语义风险**：它决定了调用者需要做哪些心理准备与防御性推理，例如：

- 实参在调用后是否仍保持原值
- 是否会影响后续逻辑与不变量
- 是否引入数据竞争/并发问题（未来扩展时更明显）

### 2.2 看见“传引用”（是否发生别名/借用）

这是 **性能与生命周期模型**：它更多影响：

- 是否发生拷贝（性能）
- 是否发生借用（别名与生命周期约束）

但对只读引用来说，“传引用”本身通常不引入行为层面的意外变化（不能写入），它的风险主要在“生命周期正确性”，而这更适合由类型系统与返回规则兜底，而不是让每个调用点都承担噪声。

## 3. 候选策略

### 3.1 策略 A：所有引用传参都必须显式 `&`（纯 C# ref 风格）

- `f(int& x)`：调用必须 `f(&a)`
- `f(int!& x)`：调用也必须 `f(&a)`

优点：

- 调用点永远能看出“这里是引用/借用”
- 规则简单，不需要解释“为什么只读可以不写”

缺点：

- 大量只读参数（尤其是大对象、切片、字符串 view）会被 `&` 噪声淹没，降低可读性
- 与 C^ 已经存在的“显式副作用标记”目标冲突：`&` 不再专指“可能修改”，而变成“只是借用”
- 与重载意图更难对齐：`&` 不再能表达“我允许你修改它”

### 3.2 策略 B：仅可变引用必须显式 `&`（当前推荐方向）

- `f(int& x)`：必须 `f(&a)`（显式副作用）
- `f(int!& x)`：允许 `f(a)`（无副作用默认），`f(&a)` 允许但建议 warning（冗余/误导）

优点：

- `&` 的含义稳定：它在调用点代表“可变借用/允许修改”，副作用可见性强
- 只读借用保持简洁，利于大量日常 API（打印、比较、哈希、遍历等）
- 重载选择直观：`f(a)` 偏向只读版本，`f(&a)` 偏向可写版本

缺点：

- 调用点 `f(a)` 无法区分“按值拷贝”还是“只读借用”

### 3.3 策略 C：引入第二个显式标记用于只读借用（例如 `in`）

例如：

- `f(int!& x)`：调用必须 `f(in a)` 或 `f(!&a)` 之类

优点：

- 同时满足“看见借用”与“看见不修改”

缺点：

- 引入新关键字/新符号体系，风格成本高
- 语法与教学负担增加
- 与既有 `!`/`&`/`~` 的组合关系更复杂

## 4. “看不出传引用”真的会造成什么问题？

对 `f(int!& x)`，调用点看不出“值 vs 只读借用”，主要会带来两类担忧：

1. **性能担忧**：读者担心是否发生拷贝  
2. **语义担忧**：读者担心是否发生可观测行为变化

其中第 2 点在 `T!&` 场景下几乎可以排除：因为不能写入，外部状态不会因该参数而被修改；而第 1 点（性能）可以通过以下方式缓解：

- 签名处一眼可见：`func print_value(int!& x)` 已经说明它不会拷贝
- IDE/hover/跳转即可看到签名
- 对大对象 API 形成惯例：读接口看签名，而不是试图从调用点推断 ABI

换句话说：**把调用点变得更吵，换来的主要是“性能推断的便利”，而不是“语义风险的降低”。**

## 5. 为什么“看见会修改”通常更重要？

因为它直接影响正确性推理：

- 看到 `f(&a)`，读者必须假设 `a` 可能被改变，需要回溯 `f` 的实现或契约
- 看到 `f(a)`（只读版本），读者可以放心把它当作纯读取/观察行为

对比之下，“这是值还是只读借用”更多是性能/实现细节层面的推理；而 C^ 设计的一贯方向是：

- 在调用点用符号表达 **意图与风险**（`&` 代表可变副作用，`~` 代表资源转移）
- 把 ABI/拷贝策略更多交给类型与签名表达，而不是让每一次调用都显式标注

## 6. 推荐结论

在 C^ 的总体设计目标下，优先级建议为：

1. **调用点可见“会不会修改”**（语义风险最高）  
2. **签名处可见“是值还是引用/只读借用”**（性能与契约）  

因此推荐采用策略 B：

- `T&`：调用必须 `&`（显式副作用）
- `T!&`：调用默认省略 `&`（只读默认），显式写 `&` 允许但建议 warning（避免误导）
- 返回引用（含 `T!&`）：`return &expr;` 不省略（因为返回借用引入别名与生命周期约束）

这能让 `&` 在调用点保持单一含义：**“我把这个实参交给你修改”**，而不是“我只是想避免拷贝”。
