# 设计决策 001：恢复 C++ 风格析构函数语法

**日期**：2026-02-09
**状态**：已采纳

## 1. 背景

在 C^ 语言的早期设计中，为了追求极致的简洁性，我们曾尝试引入匿名析构函数语法 `~ { ... }`，移除了传统的 `~ClassName()` 形式。

原设计（已废弃）：
```cpp
class Window {
    public ~ {
        // cleanup
    }
}
```

然而，经过深入的实践评估与社区反馈，我们决定**撤销**这一改动，恢复并强制使用标准的 C++ 风格析构函数语法。

新设计（当前标准）：
```cpp
class Window {
    public ~Window() {
        // cleanup
    }
}
```

## 2. 决策理由

### 2.1 一致性 (Consistency)
构造函数使用 `ClassName(...)` 形式，而析构函数如果使用 `~ { ... }`，则在视觉和逻辑上造成了不对称。恢复 `~ClassName()` 使得构造与析构在形式上保持完美的对应关系（生命周期的开始与结束）。

### 2.2 可读性与可搜索性 (Readability & Greppability)
*   **搜索困难**：在大型代码库中搜索析构函数时，`~ClassName` 是一个非常精确的关键字。而搜索 `~` 会匹配到大量的按位取反操作符、Markdown 格式符等无关内容，导致搜索几乎不可用。
*   **视觉定位**：在长文件中，`~ClassName` 能让阅读者一眼确认当前是在哪个类的析构函数中，而单纯的 `~` 缺乏上下文信息，容易让人迷失。

### 2.3 接口声明的完整性
在接口文件（`.chi`）或 `extern` 块中声明析构函数时，原设计面临尴尬的局面：
*   原设计：`public ~;` —— 看起来像是一个未完成的语句或语法错误。
*   现设计：`public ~ClassName();` —— 清晰、完整，符合函数声明的标准形式。

### 2.4 工具链友好性
IDE 和静态分析工具在处理具名函数时通常比处理匿名块更健壮。`~ClassName` 天然提供了符号锚点，便于代码导航、重构和文档生成。

## 3. 备选方案对比

### 3.1 方案 A：`~ { }` (原极简方案)
*   **优点**：极致简洁，无冗余。
*   **缺点**：
    1.  **语义模糊**：`~` 易被误读为操作符。
    2.  **扩展性差**：无 `()` 槽位，无法添加修饰符（如 `noexcept`）。
    3.  **接口声明怪异**：`public ~;` 像语法错误。

### 3.2 方案 B：`~() { }` (带括号的匿名方案)
这是对方案 A 的改进，增加了括号。
*   **优点**：
    *   有括号，看起来更像函数。
    *   解决了扩展性问题（可以在括号后加修饰符）。
    *   重构友好（类名修改时不需改析构）。
*   **缺点**：
    1.  **对称性破缺**：构造函数是 `Window()`，析构函数如果是 `~()`，两者在视觉上不对称。`~Window()` 才是 `Window()` 的逻辑逆运算。
    2.  **搜索性依然较差**：搜索 `~()` 虽然比 `~` 好一点，但依然不如 `~ClassName` 精确。
    3.  **视觉歧义**：`~()` 容易被误认为是 `operator~()` 的重载声明，或者某种闭包语法。

### 3.3 方案 C：`~ClassName()` (最终选择)
*   **优点**：
    *   **完美对称**：`Window()` vs `~Window()`。
    *   **搜索友好**：全局搜索 `~Window` 极快定位。
    *   **符合直觉**：C++ 开发者的第一反应。
*   **缺点**：
    *   略微冗余（需要重写类名）。

## 4. 结论

为了保证语言的**一致性**、**可维护性**和**专业性**，C^ 决定回归经典，采用 `~ClassName()` 作为析构函数的唯一标准语法。虽然 `~() {}` 解决了一部分问题，但其打破了构造/析构的命名对称性（Symmetry），且未能提供最佳的可读性。
