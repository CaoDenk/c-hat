# 设计决策 005：引用使用符号 `&`，不引入 `ref` 关键字

**日期**：2026-02-10  
**状态**：已采纳

## 1. 背景

引用（Reference）是 C^ 的核心能力之一：它让函数能在不拷贝对象的情况下访问/修改外部值，并能表达“别名（alias）”语义。

但引用语法同时也是可读性与可维护性的敏感点：

- C++ 的 `T&` 在调用处通常写成 `foo(x)`，副作用是否发生不可见。
- C# 的 `ref` 要求“声明处”和“调用处”同时显式，副作用非常清晰，但引入了关键字与额外的语法重量。

本决策讨论：C^ 是否应当引入类似 C# 的 `ref` 关键字，还是坚持目前的符号化设计。

相关设计文档：
- [函数设计.md](file:///d:/projects/CppProjs/c-hat/docs/design/函数设计.md)
- [指针设计.md](file:///d:/projects/CppProjs/c-hat/docs/design/指针设计.md)
- [语法.md](file:///d:/projects/CppProjs/c-hat/docs/design/语法.md)

## 2. 设计目标

- **副作用可见**：一眼看出某次调用是否可能修改实参。
- **减少关键字**：避免为了单一特性增加新的保留字。
- **与现有符号体系一致**：与 `!`（不可变）、`~`（移动）形成统一的“显式标记”风格。
- **与指针区分清晰**：指针的物理地址操作由 `^` 负责，引用不应被误读为“取地址/解引用”。

## 3. 候选方案

### 3.1 方案 A：引入 `ref` 关键字（C# 风格）

- 声明：`func f(ref int x)` / `ref int`（取决于具体语法选择）
- 调用：`f(ref a)`
- 返回引用：`return ref expr`

优点：
- `ref` 可搜索性强，审查/grep 很友好。
- 语义与 C# 用户心智模型高度一致。

缺点：
- 增加关键字与语法分叉，破坏 C^ 目前“符号标记”的一致性。
- 与 `~`（移动）并列时，表达式层面会出现多种关键字/符号混搭，风格不统一。

### 3.2 方案 B：使用符号 `&`（当前方案）

- 声明：`func f(int& x)`
- 调用：`f(&a)`
- 返回引用：`return &expr`

优点：
- 副作用可见：`&a` 在调用点清晰表意“可能被修改”。
- 不引入新关键字，语法更紧凑。
- 与 `~`、`!` 一致：都用符号表达“传递/权限/生命周期”的显式意图。
- 与指针严格区分：指针地址运算统一使用 `^`（见 [指针设计.md](file:///d:/projects/CppProjs/c-hat/docs/design/指针设计.md)），降低把 `&` 误读为“取地址”的概率。

缺点：
- 单独搜索 `&` 噪声较高（但可以用模式搜索，如 `\(&[A-Za-z_]` 或搜索签名 `T&`）。

### 3.3 方案 C：双语法并存（`ref` 与 `&` 都支持）

优点：
- 兼容两类用户偏好。

缺点：
- 形成长期风格分裂，代码一致性下降。
- 教学/文档/格式化工具负担增加。

### 3.4 方案 D：仅在声明处写 `T&`，调用处隐式（C++ 风格）

优点：
- 调用处最简。

缺点：
- 违背“副作用可见”的核心目标。
- 与 C^ 其它显式标记（`~`、`!`）的设计方向冲突。

## 4. 最终选择

选择 **方案 B：使用符号 `&`**，并明确以下规则：

1. **可变引用参数必须在调用处显式标记**  
   若形参类型为 `T&`，调用时必须写 `f(&a)`。

2. **只读引用允许隐式传递**  
   若形参类型为 `T!&`，允许 `f(a)`（因为无副作用）。

3. **返回引用必须显式标记**  
   若返回类型为 `T&`，必须写 `return &expr;`，等价于 C# 的 `return ref expr;`。

4. **`self` 不携带 `&`**  
   `self` 代表当前实例，不写 `self&`。需要区分只读/可写时，使用类型系统（例如未来可扩展为 `self!`）而不是叠加 `&`。

## 5. 为什么不引入 `ref`

核心原因是：C^ 已经用符号化完成了 C# `ref` 的“显式性”目标，同时保持了关键字集合的克制与风格一致性。

- C# 通过关键字 `ref` 达成“显式副作用”。
- C^ 通过 `&` 达成“显式副作用”，并与 `~`（移动显式）形成同一套表达式级标记体系。

如果未来发现大型工程对可搜索性有更强需求，优先考虑：

- 代码格式化规则（例如强制 `&` 与标识符之间无空格/有空格的一致约束，便于模式搜索）。
- 诊断/静态分析规则（例如对 `T&` 形参的调用点进行审查提示）。

而不是引入第二套等价语法。

