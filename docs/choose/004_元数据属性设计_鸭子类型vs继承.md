# 元数据属性 (Attribute) 设计规范：鸭子类型 vs 继承

## 1. 问题背景

在 C^ 的反射系统中，我们需要一种机制来为类型、函数、字段等实体附加自定义元数据（Attributes）。
用户可能会定义如下属性：

```cpp
// 比如一个序列化标记
struct Serialize {
    string name;
}

// 应用属性
[Serialize(name = "id")]
int my_id;
```

核心问题在于：**如何定义和约束这些属性类型？**
是强制要求继承特定基类（OOP 风格），还是采用松散的鸭子类型（Generic/Concept 风格）？

## 2. 方案比较

### 方案 A：继承基类 (Inheritance / Marker Interface)

类似 C# (`System.Attribute`) 或 Java (`Annotation` 接口)。强制要求所有自定义属性必须继承自系统提供的基类。

```cpp
// 系统定义
abstract class Attribute {}

// 用户定义
struct Serializable : Attribute { // 强制继承
    string name;
}
```

*   **优点**：
    *   **类型明确**：一眼就能看出 `Serializable` 是个属性。
    *   **容器统一**：反射 API 可以返回 `Attribute[]` 数组，利用多态处理。
    *   **防误用**：防止用户意外将普通业务 Struct 当作属性挂载。
*   **缺点**：
    *   **侵入性**：必须修改 Struct 定义，增加了耦合。
    *   **OOP 包袱**：C^ 倾向于组合优于继承，强制继承违背设计哲学。
    *   **限制性**：基本类型（如 `string` 或 `int`）不能直接作为属性（必须包装）。

### 方案 B：鸭子类型 + 异构容器 (Duck Typing / Structural) —— **推荐**

类似 C++23 提案或 Rust。**任何编译期常量**都可以作为属性，只要它能被构造。

```cpp
// 用户定义：就是一个普通 struct
struct Serializable {
    string name;
}

// 甚至可以直接用基本类型
[ "Description", 100 ] 
func foo() {}
```

*   **优点**：
    *   **零侵入**：任何现有的 Struct 都可以直接用作属性，无需修改定义。
    *   **极大灵活**：支持基本类型、第三方库类型。
    *   **符合元编程直觉**：反射就是处理数据，数据即 Struct。
*   **缺点**：
    *   **容器复杂**：`@T.attributes` 返回的不能是简单的同质数组，必须是 **编译期异构元组 (Heterogeneous Tuple)**。

## 3. 详细设计 (推荐方案 B)

### 3.1 定义属性

属性不需要继承任何基类，也不需要实现特定接口。它仅仅是一个数据载体。

```cpp
// 定义一个普通结构体
struct Route {
    string path;
    string method = "GET";
}
```

### 3.2 使用属性

使用 `[]` 语法将实例化后的常量对象附加到声明上。

```cpp
[Route(path = "/api/users")] // 构造 Route 对象
class UserController { ... }
```

### 3.3 反射获取

由于属性类型各异，`@T.attributes` 返回的是一个 **编译期元组 (Tuple)**。
我们需要配合 `comptime for` 或标准库提供的 **类型过滤器** 来查找特定属性。

```cpp
// 假设 @UserController.attributes 返回 (Route{...}, Description{...})

// 方式 1：编译期遍历 (通用)
comptime for (var attr : @UserController.attributes) {
    // 使用 is 运算符判断类型
    if (attr is Route) {
        print(attr.path);
    }
}

// 方式 2：标准库辅助函数 (更常用)
// std.meta.get_attribute<T>(meta) -> T?
if (const route = std.meta.get_attribute<Route>(@UserController)) {
    print(route.path);
}
```

### 3.4 约束与验证 (Concept)

如果我们希望限制某些 Struct 只能作为属性使用（防止误用），或者限制属性只能用于特定目标（如只能用于函数），我们可以引入 **元属性 (Meta-Attribute)** 来标记属性定义本身。

这是一种“可选的约束”，而非“强制的继承”。

```cpp
// 使用 @AttributeUsage 限制该属性只能用于类
[AttributeUsage(target = Target.Class)]
struct Route { ... }
```

## 4. 结论

采用 **方案 B (鸭子类型)**。

1.  **一致性**：与 C^ 的静态反射设计（Compile-time Duck Typing）保持一致。
2.  **灵活性**：允许用户自由组织元数据结构。
3.  **实现**：`@T.attributes` 返回元组，配合标准库 `get_attribute<T>` 实现精确查询。

此方案避免了不必要的继承层级，符合 C^ 现代化、轻量级的设计理念。
